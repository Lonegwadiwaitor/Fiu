--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (dostring):
REMARK builtin assert/1+
    5: local function dostring (x) return assert(loadstring(x))() end
GETIMPORT R2 1 [loadstring]
MOVE R3 R0
CALL R2 1 -1
FASTCALL 1 L0
GETIMPORT R1 3 [assert]
CALL R1 -1 1
L0: CALL R1 0 -1
RETURN R1 -1

Function 1 (gen):
  150:   if n==0 then coroutine.yield(c)
JUMPXEQKN R1 K0 L0 NOT [0]
GETIMPORT R2 3 [coroutine.yield]
MOVE R3 R0
CALL R2 1 0
  156: end
RETURN R0 0
  152:     for _, a in pairs(x) do
L0: GETIMPORT R2 5 [pairs]
GETUPVAL R3 0
CALL R2 1 3
FORGPREP_NEXT R2 L2
  153:       gen(c..a, n-1)
L1: GETUPVAL R7 1
MOVE R9 R0
MOVE R10 R6
CONCAT R8 R9 R10
SUBK R9 R1 K6 [1]
CALL R7 2 0
  152:     for _, a in pairs(x) do
L2: FORGLOOP R2 L1 2
  156: end
RETURN R0 0

Function 2 (??):
  158: for s in coroutine.wrap(function () gen("", len) end) do
GETUPVAL R0 0
LOADK R1 K0 ['']
LOADN R2 4
CALL R0 2 0
RETURN R0 0

Function 3 (??):
    3: print('testing scanner')
GETIMPORT R0 1 [print]
LOADK R1 K2 ['testing scanner']
CALL R0 1 0
    5: local function dostring (x) return assert(loadstring(x))() end
DUPCLOSURE R0 K3 ['dostring']
REMARK builtin assert/1
   12: assert('\n\"\'\\' == [[
LOADB R2 1
FASTCALL1 1 R2 L0
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1+
   16: assert(string.find("\a\b\f\n\r\t\v", "^%c%c%c%c%c%c%c$"))
L0: GETIMPORT R2 8 [string.find]
LOADK R3 K9 []
LOADK R4 K10 ['^%c%c%c%c%c%c%c$']
CALL R2 2 -1
FASTCALL 1 L1
GETIMPORT R1 5 [assert]
CALL R1 -1 0
REMARK builtin assert/1
   19: assert("\09912" == 'c12')
L1: LOADB R2 1
FASTCALL1 1 R2 L2
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   20: assert("\99ab" == 'cab')
L2: LOADB R2 1
FASTCALL1 1 R2 L3
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   21: assert("\099" == '\99')
L3: LOADB R2 1
FASTCALL1 1 R2 L4
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   22: assert("\099\n" == 'c\10')
L4: LOADB R2 1
FASTCALL1 1 R2 L5
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   23: assert('\0\0\0alo' == '\0' .. '\0\0' .. 'alo')
L5: LOADK R4 K11 []
LOADK R5 K12 []
LOADK R6 K13 ['alo']
CONCAT R3 R4 R6
JUMPXEQKS R3 K14 L6 []
LOADB R2 0 +1
L6: LOADB R2 1
L7: FASTCALL1 1 R2 L8
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   25: assert(010 .. 020 .. -030 == "1020-30")
L8: LOADN R4 10
LOADN R5 20
LOADN R6 -30
CONCAT R3 R4 R6
JUMPXEQKS R3 K15 L9 ['1020-30']
LOADB R2 0 +1
L9: LOADB R2 1
L10: FASTCALL1 1 R2 L11
GETIMPORT R1 5 [assert]
CALL R1 1 0
   29: var = string.rep('a', 15000)
L11: GETIMPORT R1 17 [string.rep]
LOADK R2 K18 ['a']
LOADN R3 15000
CALL R1 2 1
SETGLOBAL R1 K19 ['var']
   30: prog = string.format("%s = 5", var)
GETIMPORT R1 21 [string.format]
LOADK R2 K22 ['%s = 5']
GETGLOBAL R3 K19 ['var']
CALL R1 2 1
SETGLOBAL R1 K23 ['prog']
   31: dostring(prog)
MOVE R1 R0
GETGLOBAL R2 K23 ['prog']
CALL R1 1 0
REMARK builtin assert/1
   32: assert(dostring("return " .. var) == 5)
MOVE R3 R0
LOADK R5 K24 ['return ']
GETGLOBAL R6 K19 ['var']
CONCAT R4 R5 R6
CALL R3 1 1
JUMPXEQKN R3 K25 L12 [5]
LOADB R2 0 +1
L12: LOADB R2 1
L13: FASTCALL1 1 R2 L14
GETIMPORT R1 5 [assert]
CALL R1 1 0
   33: var = nil
L14: LOADNIL R1
SETGLOBAL R1 K19 ['var']
   34: print('+')
GETIMPORT R1 1 [print]
LOADK R2 K26 ['+']
CALL R1 1 0
REMARK builtin assert/1
   37: assert("\n\t" == [[
LOADB R2 1
FASTCALL1 1 R2 L15
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   40: assert([[
L15: LOADB R2 1
FASTCALL1 1 R2 L16
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK builtin assert/1
   43: assert([[ [ ]] ~= [[ ] ]])
L16: LOADB R2 1
FASTCALL1 1 R2 L17
GETIMPORT R1 5 [assert]
CALL R1 1 0
   45: b = "001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789"
L17: LOADK R1 K27 ['00123456789012345678901234567890'...]
SETGLOBAL R1 K28 ['b']
REMARK builtin assert/1
REMARK builtin string.len/1
   46: assert(string.len(b) == 960)
GETGLOBAL R4 K28 ['b']
FASTCALL1 43 R4 L18
GETIMPORT R3 30 [string.len]
CALL R3 1 1
L18: JUMPXEQKN R3 K31 L19 [960]
LOADB R2 0 +1
L19: LOADB R2 1
L20: FASTCALL1 1 R2 L21
GETIMPORT R1 5 [assert]
CALL R1 1 0
   47: prog = [=[
L21: LOADK R1 K32 []
SETGLOBAL R1 K23 ['prog']
   93: print('+')
GETIMPORT R1 1 [print]
LOADK R2 K26 ['+']
CALL R1 1 0
   94: x = nil
LOADNIL R1
SETGLOBAL R1 K33 ['x']
   95: dostring(prog)
MOVE R1 R0
GETGLOBAL R2 K23 ['prog']
CALL R1 1 0
REMARK builtin assert/1
   96: assert(x)
GETGLOBAL R2 K33 ['x']
FASTCALL1 1 R2 L22
GETIMPORT R1 5 [assert]
CALL R1 1 0
   98: prog = nil
L22: LOADNIL R1
SETGLOBAL R1 K23 ['prog']
   99: a = nil
LOADNIL R1
SETGLOBAL R1 K18 ['a']
  100: b = nil
LOADNIL R1
SETGLOBAL R1 K28 ['b']
  104: prog = [[
LOADK R1 K34 []
SETGLOBAL R1 K23 ['prog']
  118: for _, n in pairs{"\n", "\r", "\n\r", "\r\n"} do
GETIMPORT R1 36 [pairs]
REMARK allocation: table array 4
NEWTABLE R2 0 4
LOADK R4 K37 []
LOADK R5 K38 []
LOADK R6 K39 []
LOADK R7 K40 []
SETLIST R2 R4 4 [1]
CALL R1 1 3
FORGPREP_NEXT R1 L24
  119:   local prog, nn = string.gsub(prog, "\n", n)
L23: GETIMPORT R6 42 [string.gsub]
GETGLOBAL R7 K23 ['prog']
LOADK R8 K37 []
MOVE R9 R5
CALL R6 3 2
  118: for _, n in pairs{"\n", "\r", "\n\r", "\r\n"} do
L24: FORGLOOP R1 L23 2
  126: a = [==[]=]==]
LOADK R1 K43 [']=']
SETGLOBAL R1 K18 ['a']
REMARK builtin assert/1
  127: assert(a == "]=")
GETGLOBAL R3 K18 ['a']
JUMPXEQKS R3 K43 L25 [']=']
LOADB R2 0 +1
L25: LOADB R2 1
L26: FASTCALL1 1 R2 L27
GETIMPORT R1 5 [assert]
CALL R1 1 0
  129: a = [==[[===[[=[]]=][====[]]===]===]==]
L27: LOADK R1 K44 ['[===[[=[]]=][====[]]===]===']
SETGLOBAL R1 K18 ['a']
REMARK builtin assert/1
  130: assert(a == "[===[[=[]]=][====[]]===]===")
GETGLOBAL R3 K18 ['a']
JUMPXEQKS R3 K44 L28 ['[===[[=[]]=][====[]]===]===']
LOADB R2 0 +1
L28: LOADB R2 1
L29: FASTCALL1 1 R2 L30
GETIMPORT R1 5 [assert]
CALL R1 1 0
  132: a = [====[[===[[=[]]=][====[]]===]===]====]
L30: LOADK R1 K44 ['[===[[=[]]=][====[]]===]===']
SETGLOBAL R1 K18 ['a']
REMARK builtin assert/1
  133: assert(a == "[===[[=[]]=][====[]]===]===")
GETGLOBAL R3 K18 ['a']
JUMPXEQKS R3 K44 L31 ['[===[[=[]]=][====[]]===]===']
LOADB R2 0 +1
L31: LOADB R2 1
L32: FASTCALL1 1 R2 L33
GETIMPORT R1 5 [assert]
CALL R1 1 0
  135: a = [=[]]]]]]]]]=]
L33: LOADK R1 K45 [']]]]]]]]']
SETGLOBAL R1 K18 ['a']
REMARK builtin assert/1
  136: assert(a == "]]]]]]]]")
GETGLOBAL R3 K18 ['a']
JUMPXEQKS R3 K45 L34 [']]]]]]]]']
LOADB R2 0 +1
L34: LOADB R2 1
L35: FASTCALL1 1 R2 L36
GETIMPORT R1 5 [assert]
CALL R1 1 0
REMARK allocation: table array 4
  147: local x = {"=", "[", "]", "\n"}
L36: NEWTABLE R1 0 4
LOADK R2 K46 ['=']
LOADK R3 K47 ['[']
LOADK R4 K48 [']']
LOADK R5 K37 []
SETLIST R1 R2 4 [1]
  149: local function gen (c, n)
DUPCLOSURE R2 K49 ['gen']
CAPTURE VAL R1
CAPTURE VAL R2
  158: for s in coroutine.wrap(function () gen("", len) end) do
GETIMPORT R3 52 [coroutine.wrap]
DUPCLOSURE R4 K53 []
CAPTURE VAL R2
CALL R3 1 3
FORGPREP R3 L40
REMARK builtin assert/1
  159:   assert(s == loadstring("return [====[\n"..s.."]====]")())
L37: GETIMPORT R10 55 [loadstring]
LOADK R12 K56 []
MOVE R13 R6
LOADK R14 K57 [']====]']
CONCAT R11 R12 R14
CALL R10 1 1
CALL R10 0 1
JUMPIFEQ R6 R10 L38
LOADB R9 0 +1
L38: LOADB R9 1
L39: FASTCALL1 1 R9 L40
GETIMPORT R8 5 [assert]
CALL R8 1 0
  158: for s in coroutine.wrap(function () gen("", len) end) do
L40: FORGLOOP R3 L37 1
  180: print('OK')
GETIMPORT R3 1 [print]
LOADK R4 K58 ['OK']
CALL R3 1 0
  181: 
RETURN R0 0

]====]
end