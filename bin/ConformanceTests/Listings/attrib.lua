--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (assert):
   10:     asserted += 1 
GETUPVAL R0 0
ADDK R0 R0 K0 [1]
SETUPVAL R0 0
   11:     print("Assert called: ", asserted)
GETIMPORT R0 2 [print]
LOADK R1 K3 ['Assert called: ']
GETUPVAL R2 0
CALL R0 2 0
REMARK builtin assert/1+
   12:     return old_assert(...)
GETVARARGS R1 -1
FASTCALL 1 L0
GETUPVAL R0 1
CALL R0 -1 -1
L0: RETURN R0 -1

Function 1 (f):
   20: function f() return 10, 11, 12 end
LOADN R0 10
LOADN R1 11
LOADN R2 12
RETURN R0 3

Function 2 (??):
REMARK allocation: table hash 0
   27:   local f = function (n) local x = {}; for i=1,n do x[i]=i print'hello' end;
NEWTABLE R1 0 0
LOADN R4 1
MOVE R2 R0
LOADN R3 1
FORNPREP R2 L1
L0: SETTABLE R4 R1 R4
GETIMPORT R5 1 [print]
LOADK R6 K2 ['hello']
CALL R5 1 0
FORNLOOP R2 L0
REMARK builtin table.unpack/1
   28:                          return unpack(x) end;
L1: FASTCALL1 53 R1 L2
MOVE R3 R1
GETUPVAL R2 0
CALL R2 1 -1
L2: RETURN R2 -1

Function 3 (f):
   78: function f(a) return a end
RETURN R0 1

Function 4 (??):
    3: print("testing assignments, logical operators, and constructors")
GETIMPORT R0 1 [print]
LOADK R1 K2 ['testing assignments, logical ope'...]
CALL R0 1 0
    5: local unpack = table.unpack
GETIMPORT R0 5 [table.unpack]
    7: local asserted = 4
LOADN R1 4
    8: local old_assert = assert 
GETIMPORT R2 7 [assert]
REMARK allocation: closure with 2 upvalues
    9: local function assert(...)
NEWCLOSURE R3 P0
CAPTURE REF R1
CAPTURE VAL R2
   17: a, b = 1, 2+3
LOADN R4 1
LOADN R5 5
SETGLOBAL R4 K8 ['a']
SETGLOBAL R5 K9 ['b']
   18: assert(a==1 and b==5)
MOVE R4 R3
LOADB R5 0
GETGLOBAL R6 K8 ['a']
JUMPXEQKN R6 K10 L1 NOT [1]
GETGLOBAL R6 K9 ['b']
JUMPXEQKN R6 K11 L0 [5]
LOADB R5 0 +1
L0: LOADB R5 1
L1: CALL R4 1 0
REMARK allocation: table hash 0
   19: a={}
NEWTABLE R4 0 0
SETGLOBAL R4 K8 ['a']
   20: function f() return 10, 11, 12 end
DUPCLOSURE R4 K12 ['f']
SETGLOBAL R4 K13 ['f']
   21: a.x, b, a[1] = 1, 2, f()
GETGLOBAL R4 K8 ['a']
GETGLOBAL R5 K8 ['a']
LOADN R6 1
LOADN R7 2
GETGLOBAL R8 K13 ['f']
CALL R8 0 1
SETTABLEKS R6 R4 K14 ['x']
SETGLOBAL R7 K9 ['b']
SETTABLEN R8 R5 1
   22: assert(a.x==1 and b==2 and a[1]==10)
MOVE R4 R3
LOADB R5 0
GETGLOBAL R7 K8 ['a']
GETTABLEKS R6 R7 K14 ['x']
JUMPXEQKN R6 K10 L3 NOT [1]
LOADB R5 0
GETGLOBAL R6 K9 ['b']
JUMPXEQKN R6 K15 L3 NOT [2]
GETGLOBAL R7 K8 ['a']
GETTABLEN R6 R7 1
JUMPXEQKN R6 K16 L2 [10]
LOADB R5 0 +1
L2: LOADB R5 1
L3: CALL R4 1 0
   23: a[f()], b, a[f()+3] = f(), a, 'x'
GETGLOBAL R4 K8 ['a']
GETGLOBAL R5 K13 ['f']
CALL R5 0 1
GETGLOBAL R6 K8 ['a']
GETGLOBAL R8 K13 ['f']
CALL R8 0 1
ADDK R7 R8 K17 [3]
GETGLOBAL R8 K13 ['f']
CALL R8 0 1
GETGLOBAL R9 K8 ['a']
LOADK R10 K14 ['x']
SETTABLE R8 R4 R5
SETGLOBAL R9 K9 ['b']
SETTABLE R10 R6 R7
   24: assert(a[10] == 10 and b == a and a[13] == 'x')
MOVE R4 R3
LOADB R5 0
GETGLOBAL R7 K8 ['a']
GETTABLEN R6 R7 10
JUMPXEQKN R6 K16 L5 NOT [10]
LOADB R5 0
GETGLOBAL R6 K9 ['b']
GETGLOBAL R7 K8 ['a']
JUMPIFNOTEQ R6 R7 L5
GETGLOBAL R7 K8 ['a']
GETTABLEN R6 R7 13
JUMPXEQKS R6 K14 L4 ['x']
LOADB R5 0 +1
L4: LOADB R5 1
L5: CALL R4 1 0
   27:   local f = function (n) local x = {}; for i=1,n do x[i]=i print'hello' end;
DUPCLOSURE R4 K18 []
CAPTURE VAL R0
   29:   local a,b,c
LOADNIL R5
LOADNIL R6
LOADNIL R7
   30:   a,b = 0, f(1)
LOADN R5 0
MOVE R8 R4
LOADN R9 1
CALL R8 1 1
MOVE R6 R8
   31:   print(a == 0, b == 1)
GETIMPORT R8 1 [print]
JUMPXEQKN R5 K19 L6 [0]
LOADB R9 0 +1
L6: LOADB R9 1
L7: JUMPXEQKN R6 K10 L8 [1]
LOADB R10 0 +1
L8: LOADB R10 1
L9: CALL R8 2 0
   32:   assert(a == 0 and b == 1)
MOVE R8 R3
LOADB R9 0
JUMPXEQKN R5 K19 L11 NOT [0]
JUMPXEQKN R6 K10 L10 [1]
LOADB R9 0 +1
L10: LOADB R9 1
L11: CALL R8 1 0
   33:   A,b = 0, f(1)
LOADN R8 0
MOVE R9 R4
LOADN R10 1
CALL R9 1 1
MOVE R6 R9
SETGLOBAL R8 K20 ['A']
   34:   assert(A == 0 and b == 1)
MOVE R8 R3
LOADB R9 0
GETGLOBAL R10 K20 ['A']
JUMPXEQKN R10 K19 L13 NOT [0]
JUMPXEQKN R6 K10 L12 [1]
LOADB R9 0 +1
L12: LOADB R9 1
L13: CALL R8 1 0
   35:   a,b,c = 0,5,f(4)
LOADN R5 0
LOADN R6 5
MOVE R8 R4
LOADN R9 4
CALL R8 1 1
MOVE R7 R8
   36:   assert(a==0 and b==5 and c==1)
MOVE R8 R3
LOADB R9 0
JUMPXEQKN R5 K19 L15 NOT [0]
LOADB R9 0
JUMPXEQKN R6 K11 L15 NOT [5]
JUMPXEQKN R7 K10 L14 [1]
LOADB R9 0 +1
L14: LOADB R9 1
L15: CALL R8 1 0
   37:   a,b,c = 0,5,f(0)
LOADN R5 0
LOADN R6 5
MOVE R8 R4
LOADN R9 0
CALL R8 1 1
MOVE R7 R8
   38:   assert(a==0 and b==5 and c==nil)
MOVE R8 R3
LOADB R9 0
JUMPXEQKN R5 K19 L17 NOT [0]
LOADB R9 0
JUMPXEQKN R6 K11 L17 NOT [5]
JUMPXEQKNIL R7 L16
LOADB R9 0 +1
L16: LOADB R9 1
L17: CALL R8 1 0
   42: a, b, c, d = 1 and nil, 1 or nil, (1 and (nil or 1)), 6
LOADNIL R4
LOADN R5 1
LOADN R6 1
LOADN R7 6
SETGLOBAL R4 K8 ['a']
SETGLOBAL R5 K9 ['b']
SETGLOBAL R6 K21 ['c']
SETGLOBAL R7 K22 ['d']
   43: assert(not a and b and c and d==6)
MOVE R4 R3
GETGLOBAL R6 K8 ['a']
NOT R5 R6
JUMPIFNOT R5 L19
GETGLOBAL R5 K9 ['b']
JUMPIFNOT R5 L19
GETGLOBAL R5 K21 ['c']
JUMPIFNOT R5 L19
GETGLOBAL R6 K22 ['d']
JUMPXEQKN R6 K23 L18 [6]
LOADB R5 0 +1
L18: LOADB R5 1
L19: CALL R4 1 0
   45: d = 20
LOADN R4 20
SETGLOBAL R4 K22 ['d']
   46: a, b, c, d = f()
GETGLOBAL R4 K13 ['f']
CALL R4 0 4
SETGLOBAL R4 K8 ['a']
SETGLOBAL R5 K9 ['b']
SETGLOBAL R6 K21 ['c']
SETGLOBAL R7 K22 ['d']
   47: assert(a==10 and b==11 and c==12 and d==nil)
MOVE R4 R3
LOADB R5 0
GETGLOBAL R6 K8 ['a']
JUMPXEQKN R6 K16 L21 NOT [10]
LOADB R5 0
GETGLOBAL R6 K9 ['b']
JUMPXEQKN R6 K24 L21 NOT [11]
LOADB R5 0
GETGLOBAL R6 K21 ['c']
JUMPXEQKN R6 K25 L21 NOT [12]
GETGLOBAL R6 K22 ['d']
JUMPXEQKNIL R6 L20
LOADB R5 0 +1
L20: LOADB R5 1
L21: CALL R4 1 0
   48: a,b = f(), 1, 2, 3, f()
GETGLOBAL R4 K13 ['f']
CALL R4 0 1
LOADN R5 1
GETGLOBAL R6 K13 ['f']
CALL R6 0 1
SETGLOBAL R4 K8 ['a']
SETGLOBAL R5 K9 ['b']
   49: assert(a==10 and b==1)
MOVE R4 R3
LOADB R5 0
GETGLOBAL R6 K8 ['a']
JUMPXEQKN R6 K16 L23 NOT [10]
GETGLOBAL R6 K9 ['b']
JUMPXEQKN R6 K10 L22 [1]
LOADB R5 0 +1
L22: LOADB R5 1
L23: CALL R4 1 0
   51: print(a<b == false, a>b == true)
GETIMPORT R4 1 [print]
GETGLOBAL R7 K8 ['a']
GETGLOBAL R8 K9 ['b']
JUMPIFLT R7 R8 L24
LOADB R6 0 +1
L24: LOADB R6 1
L25: JUMPXEQKB R6 0 L26
LOADB R5 0 +1
L26: LOADB R5 1
L27: GETGLOBAL R8 K8 ['a']
GETGLOBAL R9 K9 ['b']
JUMPIFLT R9 R8 L28
LOADB R7 0 +1
L28: LOADB R7 1
L29: JUMPXEQKB R7 1 L30
LOADB R6 0 +1
L30: LOADB R6 1
L31: CALL R4 2 0
   52: assert(a<b == false and a>b == true)
MOVE R4 R3
LOADB R5 0
GETGLOBAL R7 K8 ['a']
GETGLOBAL R8 K9 ['b']
JUMPIFLT R7 R8 L32
LOADB R6 0 +1
L32: LOADB R6 1
L33: JUMPXEQKB R6 0 L37 NOT
GETGLOBAL R7 K8 ['a']
GETGLOBAL R8 K9 ['b']
JUMPIFLT R8 R7 L34
LOADB R6 0 +1
L34: LOADB R6 1
L35: JUMPXEQKB R6 1 L36
LOADB R5 0 +1
L36: LOADB R5 1
L37: CALL R4 1 0
   53: assert((10 and 2) == 2)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   54: assert((10 or 2) == 10)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   55: assert((10 or assert(nil)) == 10)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   56: assert(not (nil and assert(nil)))
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   57: assert((nil or "alo") == "alo")
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   58: assert((nil and 10) == nil)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   59: assert((false and 10) == false)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   60: assert((true or 10) == true)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   61: assert((false or 10) == 10)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   62: assert(false ~= nil)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   63: assert(nil ~= false)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   64: assert(not nil == true)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   65: assert(not not nil == false)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   66: assert(not not 1 == true)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   67: assert(not not a == true)
MOVE R4 R3
GETGLOBAL R8 K8 ['a']
NOT R7 R8
NOT R6 R7
JUMPXEQKB R6 1 L38
LOADB R5 0 +1
L38: LOADB R5 1
L39: CALL R4 1 0
   68: assert(not not (6 or nil) == true)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   69: assert(not not (nil and 56) == false)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   70: assert(not not (nil and true) == false)
MOVE R4 R3
LOADB R5 1
CALL R4 1 0
   71: print('---')
GETIMPORT R4 1 [print]
LOADK R5 K26 ['---']
CALL R4 1 0
REMARK allocation: table hash 0
   73: a = {}
NEWTABLE R4 0 0
SETGLOBAL R4 K8 ['a']
   74: a[true] = 20
GETGLOBAL R4 K8 ['a']
LOADB R5 1
LOADN R6 20
SETTABLE R6 R4 R5
   75: a[false] = 10
GETGLOBAL R4 K8 ['a']
LOADB R5 0
LOADN R6 10
SETTABLE R6 R4 R5
   76: assert(a[1<2] == 20 and a[1>2] == 10)
MOVE R4 R3
LOADB R5 0
GETGLOBAL R7 K8 ['a']
LOADB R8 1
GETTABLE R6 R7 R8
JUMPXEQKN R6 K27 L41 NOT [20]
GETGLOBAL R7 K8 ['a']
LOADB R8 0
GETTABLE R6 R7 R8
JUMPXEQKN R6 K16 L40 [10]
LOADB R5 0 +1
L40: LOADB R5 1
L41: CALL R4 1 0
   78: function f(a) return a end
DUPCLOSURE R4 K28 ['f']
SETGLOBAL R4 K13 ['f']
REMARK allocation: table hash 2
   80: local a = {}
NEWTABLE R4 2 1
   81: for i=3000,-3000,-1 do a[i] = i; end
LOADN R7 3000
LOADN R5 -3000
LOADN R6 -1
FORNPREP R5 L43
L42: SETTABLE R7 R4 R7
FORNLOOP R5 L42
   82: a[10e30] = "alo"; a[true] = 10; a[false] = 20
L43: LOADK R5 K29 [9.9999999999999996e+30]
LOADK R6 K30 ['alo']
SETTABLE R6 R4 R5
LOADB R5 1
LOADN R6 10
SETTABLE R6 R4 R5
LOADB R5 0
LOADN R6 20
SETTABLE R6 R4 R5
   83: assert(a[10e30] == 'alo' and a[not 1] == 20 and a[10<20] == 10)
MOVE R5 R3
LOADB R6 0
LOADK R8 K29 [9.9999999999999996e+30]
GETTABLE R7 R4 R8
JUMPXEQKS R7 K30 L45 NOT ['alo']
LOADB R6 0
LOADB R8 0
GETTABLE R7 R4 R8
JUMPXEQKN R7 K27 L45 NOT [20]
LOADB R8 1
GETTABLE R7 R4 R8
JUMPXEQKN R7 K16 L44 [10]
LOADB R6 0 +1
L44: LOADB R6 1
L45: CALL R5 1 0
   84: a[print] = assert
GETIMPORT R5 1 [print]
SETTABLE R3 R4 R5
   85: a[f] = print
GETGLOBAL R5 K13 ['f']
GETIMPORT R6 1 [print]
SETTABLE R6 R4 R5
   86: a[a] = a
SETTABLE R4 R4 R4
   87: assert(a[a][a][a][a][print] == assert)
MOVE R5 R3
GETTABLE R11 R4 R4
GETTABLE R10 R11 R4
GETTABLE R9 R10 R4
GETTABLE R8 R9 R4
GETIMPORT R9 1 [print]
GETTABLE R7 R8 R9
JUMPIFEQ R7 R3 L46
LOADB R6 0 +1
L46: LOADB R6 1
L47: CALL R5 1 0
   88: a[print](a[a[f]] == a[print])
GETIMPORT R6 1 [print]
GETTABLE R5 R4 R6
GETGLOBAL R9 K13 ['f']
GETTABLE R8 R4 R9
GETTABLE R7 R4 R8
GETIMPORT R9 1 [print]
GETTABLE R8 R4 R9
JUMPIFEQ R7 R8 L48
LOADB R6 0 +1
L48: LOADB R6 1
L49: CALL R5 1 0
   89: a = nil
LOADNIL R4
REMARK allocation: table hash 4 array 9
   91: a = {10,9,8,7,6,5,4,3,2; [-3]='a', [f]=print, a='a', b='ab'}
NEWTABLE R5 4 9
LOADN R6 10
LOADN R7 9
LOADN R8 8
LOADN R9 7
LOADN R10 6
LOADN R11 5
LOADN R12 4
LOADN R13 3
LOADN R14 2
SETLIST R5 R6 9 [1]
LOADN R15 -3
LOADK R16 K8 ['a']
SETTABLE R16 R5 R15
GETGLOBAL R15 K13 ['f']
GETIMPORT R16 1 [print]
SETTABLE R16 R5 R15
LOADK R15 K8 ['a']
SETTABLEKS R15 R5 K8 ['a']
LOADK R15 K31 ['ab']
SETTABLEKS R15 R5 K9 ['b']
MOVE R4 R5
   92: a, a.x, a.y = a, a[-3]
MOVE R5 R4
LOADN R8 -3
GETTABLE R6 R4 R8
LOADNIL R7
SETTABLEKS R6 R4 K14 ['x']
SETTABLEKS R7 R4 K32 ['y']
MOVE R4 R5
   94: assert(a[1]==10 and a[-3]==a.a and a[f]==print and a.x=='a' and not a.y)
MOVE R5 R3
LOADB R6 0
GETTABLEN R7 R4 1
JUMPXEQKN R7 K16 L50 NOT [10]
LOADB R6 0
LOADN R8 -3
GETTABLE R7 R4 R8
GETTABLEKS R8 R4 K8 ['a']
JUMPIFNOTEQ R7 R8 L50
LOADB R6 0
GETGLOBAL R8 K13 ['f']
GETTABLE R7 R4 R8
GETIMPORT R8 1 [print]
JUMPIFNOTEQ R7 R8 L50
LOADB R6 0
GETTABLEKS R7 R4 K14 ['x']
JUMPXEQKS R7 K8 L50 NOT ['a']
GETTABLEKS R7 R4 K32 ['y']
NOT R6 R7
L50: CALL R5 1 0
   96: print(f(a))
GETIMPORT R5 1 [print]
GETGLOBAL R6 K13 ['f']
MOVE R7 R4
CALL R6 1 -1
CALL R5 -1 0
   98: a[1], f(a)[2], b, c = {['alo']=assert}, 10, a[1], a[f], 6, 10, 23, f(a), 2
GETGLOBAL R5 K13 ['f']
MOVE R6 R4
CALL R5 1 1
REMARK allocation: table hash 1
NEWTABLE R6 1 0
SETTABLEKS R3 R6 K30 ['alo']
LOADN R7 10
GETTABLEN R8 R4 1
GETGLOBAL R10 K13 ['f']
GETTABLE R9 R4 R10
GETGLOBAL R10 K13 ['f']
MOVE R11 R4
CALL R10 1 1
SETTABLEN R6 R4 1
SETTABLEN R7 R5 2
SETGLOBAL R8 K9 ['b']
SETGLOBAL R9 K21 ['c']
   99: a[1].alo(a[2]==10 and b==10 and c==print)
GETTABLEN R6 R4 1
GETTABLEKS R5 R6 K30 ['alo']
LOADB R6 0
GETTABLEN R7 R4 2
JUMPXEQKN R7 K16 L52 NOT [10]
LOADB R6 0
GETGLOBAL R7 K9 ['b']
JUMPXEQKN R7 K16 L52 NOT [10]
GETGLOBAL R7 K21 ['c']
GETIMPORT R8 1 [print]
JUMPIFEQ R7 R8 L51
LOADB R6 0 +1
L51: LOADB R6 1
L52: CALL R5 1 0
  101: a[2^31] = 10; a[2^31+1] = 11; a[-2^31] = 12;
LOADK R5 K33 [2147483648]
LOADN R6 10
SETTABLE R6 R4 R5
LOADK R5 K34 [2147483649]
LOADN R6 11
SETTABLE R6 R4 R5
LOADK R5 K35 [-2147483648]
LOADN R6 12
SETTABLE R6 R4 R5
  102: a[2^32] = 13; a[-2^32] = 14; a[2^32+1] = 15; a[10^33] = 16;
LOADK R5 K36 [4294967296]
LOADN R6 13
SETTABLE R6 R4 R5
LOADK R5 K37 [-4294967296]
LOADN R6 14
SETTABLE R6 R4 R5
LOADK R5 K38 [4294967297]
LOADN R6 15
SETTABLE R6 R4 R5
LOADK R5 K39 [9.9999999999999995e+32]
LOADN R6 16
SETTABLE R6 R4 R5
  104: assert(a[2^31] == 10 and a[2^31+1] == 11 and a[-2^31] == 12 and
MOVE R5 R3
LOADB R6 0
LOADK R8 K33 [2147483648]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K16 L54 NOT [10]
LOADB R6 0
LOADK R8 K34 [2147483649]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K24 L54 NOT [11]
LOADB R6 0
LOADK R8 K35 [-2147483648]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K25 L54 NOT [12]
LOADB R6 0
  105:        a[2^32] == 13 and a[-2^32] == 14 and a[2^32+1] == 15 and
LOADK R8 K36 [4294967296]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K40 L54 NOT [13]
LOADB R6 0
LOADK R8 K37 [-4294967296]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K41 L54 NOT [14]
LOADB R6 0
LOADK R8 K38 [4294967297]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K42 L54 NOT [15]
  106:        a[10^33] == 16)
LOADK R8 K39 [9.9999999999999995e+32]
GETTABLE R7 R4 R8
JUMPXEQKN R7 K43 L53 [16]
LOADB R6 0 +1
L53: LOADB R6 1
  104: assert(a[2^31] == 10 and a[2^31+1] == 11 and a[-2^31] == 12 and
L54: CALL R5 1 0
  108: a = nil
LOADNIL R4
  112:   local a,i,j,b
LOADNIL R5
LOADNIL R6
LOADNIL R7
LOADNIL R8
REMARK allocation: table array 2
  113:   a = {'a', 'b'}; i=1; j=2; b=a
NEWTABLE R9 0 2
LOADK R10 K8 ['a']
LOADK R11 K9 ['b']
SETLIST R9 R10 2 [1]
MOVE R5 R9
LOADN R6 1
LOADN R7 2
MOVE R8 R5
  114:   i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i
ADD R9 R6 R7
MOVE R10 R7
MOVE R11 R6
MOVE R12 R8
SETTABLE R6 R5 R6
SETTABLE R7 R5 R7
SETTABLE R6 R5 R9
MOVE R6 R10
MOVE R5 R11
MOVE R7 R12
  115:   assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and
MOVE R9 R3
LOADB R10 0
JUMPXEQKN R6 K15 L56 NOT [2]
LOADB R10 0
GETTABLEN R11 R8 1
JUMPXEQKN R11 K10 L56 NOT [1]
LOADB R10 0
JUMPXEQKN R5 K10 L56 NOT [1]
LOADB R10 0
JUMPIFNOTEQ R7 R8 L56
LOADB R10 0
GETTABLEN R11 R8 2
JUMPXEQKN R11 K15 L56 NOT [2]
  116:          b[3] == 1)
GETTABLEN R11 R8 3
JUMPXEQKN R11 K10 L55 [1]
LOADB R10 0 +1
L55: LOADB R10 1
  115:   assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and
L56: CALL R9 1 0
  119: print('OK')
GETIMPORT R5 1 [print]
LOADK R6 K44 ['OK']
CALL R5 1 0
  120: 
CLOSEUPVALS R1
RETURN R0 0

]====]
end