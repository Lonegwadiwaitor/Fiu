--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (f):
REMARK allocation: table template 1
   37:  local a; function f(x) x={a=1}; x={x=1}; x={G=1} end
DUPTABLE R1 1
LOADN R2 1
SETTABLEKS R2 R1 K0 ['a']
MOVE R0 R1
REMARK allocation: table template 1
DUPTABLE R1 3
LOADN R2 1
SETTABLEKS R2 R1 K2 ['x']
MOVE R0 R1
REMARK allocation: table template 1
DUPTABLE R1 5
LOADN R2 1
SETTABLEKS R2 R1 K4 ['G']
MOVE R0 R1
RETURN R0 0

Function 1 (f):
REMARK builtin type/1
   41:   if type(i) ~= 'number' then return i,'jojo'; end;
FASTCALL1 40 R0 L0
MOVE R2 R0
GETIMPORT R1 1 [type]
CALL R1 1 1
L0: JUMPXEQKS R1 K2 L1 ['number']
MOVE R1 R0
LOADK R2 K3 ['jojo']
RETURN R1 2
   42:   if i > 0 then return i, f(i-1); end;
L1: LOADN R1 0
JUMPIFNOTLT R1 R0 L2
MOVE R1 R0
GETGLOBAL R2 K4 ['f']
SUBK R3 R0 K5 [1]
CALL R2 1 -1
RETURN R1 -1
   43: end
L2: RETURN R0 0

Function 2 (??):
   57:   if i < 10 then return 'a';
LOADN R1 10
JUMPIFNOTLT R0 R1 L0
LOADK R1 K0 ['a']
RETURN R1 1
   58:   elseif i < 20 then return 'b';
L0: LOADN R1 20
JUMPIFNOTLT R0 R1 L1
LOADK R1 K1 ['b']
RETURN R1 1
   59:   elseif i < 30 then return 'c';
L1: LOADN R1 30
JUMPIFNOTLT R0 R1 L2
LOADK R1 K2 ['c']
RETURN R1 1
   61: end
L2: RETURN R0 0

Function 3 (f):
   77:   local x = 1;
LOADN R1 1
   80:     if b==1 then local b=1; x=10; break
L0: JUMPXEQKN R0 K0 L1 NOT [1]
LOADN R1 10
   86:   return x;
RETURN R1 1
   81:     elseif b==2 then x=20; break;
L1: JUMPXEQKN R0 K1 L2 NOT [2]
LOADN R1 20
   86:   return x;
RETURN R1 1
   82:     elseif b==3 then x=30;
L2: JUMPXEQKN R0 K2 L3 NOT [3]
LOADN R1 30
JUMP L5
REMARK builtin math.sin/1
   83:     else local a,b,c,d=math.sin(1); x=x+1;
L3: LOADN R3 1
FASTCALL1 24 R3 L4
GETIMPORT R2 5 [math.sin]
CALL R2 1 4
L4: ADDK R1 R1 K0 [1]
   85:   until x>=12;
L5: LOADN R2 12
JUMPIFLE R2 R1 L6
JUMPBACK L0
   86:   return x;
L6: RETURN R1 1

Function 4 (??):
   93:   if i < 10 then return 'a'
LOADN R1 10
JUMPIFNOTLT R0 R1 L0
LOADK R1 K0 ['a']
RETURN R1 1
   94:   elseif i < 20 then return 'b'
L0: LOADN R1 20
JUMPIFNOTLT R0 R1 L1
LOADK R1 K1 ['b']
RETURN R1 1
   95:   elseif i < 30 then return 'c'
L1: LOADN R1 30
JUMPIFNOTLT R0 R1 L2
LOADK R1 K2 ['c']
RETURN R1 1
   96:   else return 8
L2: LOADN R1 8
RETURN R1 1

Function 5 (f):
  114:     if i>0 then i=i-1;
L0: LOADN R1 0
JUMPIFNOTLT R1 R0 L1
SUBK R0 R0 K0 [1]
JUMP L2
  115:     else return; end;
L1: RETURN R0 0
  113:   while 1 do
L2: JUMPBACK L0
  117: end;
RETURN R0 0

Function 6 (g):
  121:     if i>0 then i=i-1
L0: LOADN R1 0
JUMPIFNOTLT R1 R0 L1
SUBK R0 R0 K0 [1]
JUMP L2
  122:     else return end
L1: RETURN R0 0
  120:   while 1 do
L2: JUMPBACK L0
  124: end
RETURN R0 0

Function 7 (f):
  129:   function f () return 1,2,3; end
LOADN R0 1
LOADN R1 2
LOADN R2 3
RETURN R0 3

Function 8 (g):
  139: function g() f(); return; end;
GETUPVAL R0 0
CALL R0 0 0
RETURN R0 0

Function 9 (g):
  141: function g() return nil or f() end
GETUPVAL R0 0
CALL R0 0 1
RETURN R0 1

Function 10 (g):
  159:   if not (a>=b or c or d and e or nil) then return 0; else return 1; end;
JUMPIFLE R1 R0 L1
JUMPIF R2 L1
JUMPIFNOT R3 L0
JUMPIF R4 L1
L0: LOADN R5 0
RETURN R5 1
L1: LOADN R5 1
RETURN R5 1

Function 11 (h):
  163:   while (a>=b or c or (d and e) or nil) do return 1; end;
L0: JUMPIFLE R1 R0 L1
JUMPIF R2 L1
JUMPIFNOT R3 L2
JUMPIF R4 L1
JUMP L2
L1: LOADN R5 1
RETURN R5 1
JUMPBACK L0
  164:   return 0;
L2: LOADN R5 0
RETURN R5 1

Function 12 (F):
  192:   return a,2,3
MOVE R1 R0
LOADN R2 2
LOADN R3 3
RETURN R1 3

Function 13 (ID):
  202: function ID(x) return x end
RETURN R0 1

Function 14 (f):
  205:   local b = t.n
GETTABLEKS R2 R0 K0 ['n']
REMARK builtin math.floor/1
  206:   local res = (math.floor(i/c)%b)+1
GETGLOBAL R7 K2 ['c']
DIV R6 R1 R7
FASTCALL1 12 R6 L0
GETIMPORT R5 5 [math.floor]
CALL R5 1 1
L0: MOD R4 R5 R2
ADDK R3 R4 K1 [1]
  207:   c = c*b
GETGLOBAL R5 K2 ['c']
MUL R4 R5 R2
SETGLOBAL R4 K2 ['c']
  208:   return t[res]
GETTABLE R4 R0 R3
RETURN R4 1

Function 15 (??):
    3: print "testing syntax"
GETIMPORT R0 1 [print]
LOADK R1 K2 ['testing syntax']
CALL R0 1 0
REMARK builtin assert/1
    7: assert(2^3^2 == 2^(3^2));
LOADB R1 1
FASTCALL1 1 R1 L0
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
    8: assert(2^3*4 == (2^3)*4);
L0: LOADB R1 1
FASTCALL1 1 R1 L1
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
    9: assert(2^-2 == 1/4 and -2^- -2 == - - -4);
L1: LOADB R1 1
FASTCALL1 1 R1 L2
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   10: assert(not nil and 2 and not(2>3 or 3<2));
L2: LOADB R1 1
FASTCALL1 1 R1 L3
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   11: assert(-3-1-5 == 0+0-9);
L3: LOADB R1 1
FASTCALL1 1 R1 L4
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   12: assert(-2^2 == -4 and (-2)^2 == 4 and 2*2-3-1 == 0);
L4: LOADB R1 1
FASTCALL1 1 R1 L5
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   13: assert(2*1+3/3 == 3 and 1+2 .. 3*1 == "33");
L5: LOADN R3 3
LOADN R4 3
CONCAT R2 R3 R4
JUMPXEQKS R2 K5 L6 ['33']
LOADB R1 0 +1
L6: LOADB R1 1
L7: FASTCALL1 1 R1 L8
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   14: assert(not(2+1 > 3*1) and "a".."b" > "a");
L8: LOADK R3 K6 ['a']
LOADK R4 K7 ['b']
CONCAT R2 R3 R4
LOADK R3 K6 ['a']
JUMPIFLT R3 R2 L9
LOADB R1 0 +1
L9: LOADB R1 1
L10: FASTCALL1 1 R1 L11
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   16: assert(not ((true or false) and nil))
L11: LOADB R1 1
FASTCALL1 1 R1 L12
GETIMPORT R0 4 [assert]
CALL R0 1 0
REMARK builtin assert/1
   17: assert(      true or false  and nil)
L12: LOADB R1 1
FASTCALL1 1 R1 L13
GETIMPORT R0 4 [assert]
CALL R0 1 0
   19: local a,b = 1,nil;
L13: LOADN R0 1
LOADNIL R1
REMARK builtin assert/1
   20: assert(-(1 or 2) == -1 and (1 and 2)+(-1.25 or -4) == 0.75);
LOADB R3 1
FASTCALL1 1 R3 L14
GETIMPORT R2 4 [assert]
CALL R2 1 0
   21: x = ((b or a)+1 == 2 and (10 or a)+1 == 11); assert(x);
L14: LOADB R2 0
MOVE R4 R0
ADDK R3 R4 K8 [1]
JUMPXEQKN R3 K9 L15 NOT [2]
LOADB R2 1
L15: SETGLOBAL R2 K10 ['x']
REMARK builtin assert/1
GETGLOBAL R3 K10 ['x']
FASTCALL1 1 R3 L16
GETIMPORT R2 4 [assert]
CALL R2 1 0
   22: x = (((2<3) or 1) == true and (2<3 and 4) == 4); assert(x);
L16: LOADB R2 1
SETGLOBAL R2 K10 ['x']
REMARK builtin assert/1
GETGLOBAL R3 K10 ['x']
FASTCALL1 1 R3 L17
GETIMPORT R2 4 [assert]
CALL R2 1 0
   24: x,y=1,2;
L17: LOADN R2 1
LOADN R3 2
SETGLOBAL R2 K10 ['x']
SETGLOBAL R3 K11 ['y']
REMARK builtin assert/1
   25: assert((x>y) and x or y == 2);
GETGLOBAL R4 K10 ['x']
GETGLOBAL R5 K11 ['y']
JUMPIFNOTLT R5 R4 L18
GETGLOBAL R3 K10 ['x']
JUMPIF R3 L20
L18: GETGLOBAL R4 K11 ['y']
JUMPXEQKN R4 K9 L19 [2]
LOADB R3 0 +1
L19: LOADB R3 1
L20: FASTCALL1 1 R3 L21
GETIMPORT R2 4 [assert]
CALL R2 1 0
   26: x,y=2,1;
L21: LOADN R2 2
LOADN R3 1
SETGLOBAL R2 K10 ['x']
SETGLOBAL R3 K11 ['y']
REMARK builtin assert/1
   27: assert((x>y) and x or y == 2);
GETGLOBAL R4 K10 ['x']
GETGLOBAL R5 K11 ['y']
JUMPIFNOTLT R5 R4 L22
GETGLOBAL R3 K10 ['x']
JUMPIF R3 L24
L22: GETGLOBAL R4 K11 ['y']
JUMPXEQKN R4 K9 L23 [2]
LOADB R3 0 +1
L23: LOADB R3 1
L24: FASTCALL1 1 R3 L25
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK builtin assert/1
   29: assert(1234567890 == tonumber('1234567890') and 1234567890+1 == 1234567891)
L25: LOADB R3 0
REMARK builtin tonumber/1
LOADK R5 K12 ['1234567890']
FASTCALL1 62 R5 L26
GETIMPORT R4 14 [tonumber]
CALL R4 1 1
L26: JUMPXEQKN R4 K15 L27 NOT [1234567890]
LOADB R3 1
L27: FASTCALL1 1 R3 L28
GETIMPORT R2 4 [assert]
CALL R2 1 0
   37:  local a; function f(x) x={a=1}; x={x=1}; x={G=1} end
L28: DUPCLOSURE R2 K16 ['f']
SETGLOBAL R2 K17 ['f']
   40: function f (i)
DUPCLOSURE R2 K18 ['f']
SETGLOBAL R2 K17 ['f']
REMARK allocation: table array 3
   45: x = {f(3), f(5), f(10);};
NEWTABLE R2 0 3
GETGLOBAL R3 K17 ['f']
LOADN R4 3
CALL R3 1 1
GETGLOBAL R4 K17 ['f']
LOADN R5 5
CALL R4 1 1
GETGLOBAL R5 K17 ['f']
LOADN R6 10
CALL R5 1 -1
SETLIST R2 R3 -1 [1]
SETGLOBAL R2 K10 ['x']
REMARK builtin assert/1
   46: assert(x[1] == 3 and x[2] == 5 and x[3] == 10 and x[4] == 9 and x[12] == 1);
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 1
JUMPXEQKN R4 K19 L30 NOT [3]
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 2
JUMPXEQKN R4 K20 L30 NOT [5]
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 3
JUMPXEQKN R4 K21 L30 NOT [10]
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 4
JUMPXEQKN R4 K22 L30 NOT [9]
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 12
JUMPXEQKN R4 K8 L29 [1]
LOADB R3 0 +1
L29: LOADB R3 1
L30: FASTCALL1 1 R3 L31
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK builtin assert/1
   47: assert(x[nil] == nil)
L31: GETGLOBAL R5 K10 ['x']
LOADNIL R6
GETTABLE R4 R5 R6
JUMPXEQKNIL R4 L32
LOADB R3 0 +1
L32: LOADB R3 1
L33: FASTCALL1 1 R3 L34
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK allocation: table array 3
   48: x = {f'alo', f'xixi', nil};
L34: NEWTABLE R2 0 3
GETGLOBAL R3 K17 ['f']
LOADK R4 K23 ['alo']
CALL R3 1 1
GETGLOBAL R4 K17 ['f']
LOADK R5 K24 ['xixi']
CALL R4 1 1
LOADNIL R5
SETLIST R2 R3 3 [1]
SETGLOBAL R2 K10 ['x']
REMARK builtin assert/1
   49: assert(x[1] == 'alo' and x[2] == 'xixi' and x[3] == nil);
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 1
JUMPXEQKS R4 K23 L36 NOT ['alo']
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 2
JUMPXEQKS R4 K24 L36 NOT ['xixi']
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 3
JUMPXEQKNIL R4 L35
LOADB R3 0 +1
L35: LOADB R3 1
L36: FASTCALL1 1 R3 L37
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK allocation: table array 1
   50: x = {f'alo'..'xixi'};
L37: NEWTABLE R2 0 1
GETGLOBAL R6 K17 ['f']
LOADK R7 K23 ['alo']
CALL R6 1 1
MOVE R4 R6
LOADK R5 K24 ['xixi']
CONCAT R3 R4 R5
SETLIST R2 R3 1 [1]
SETGLOBAL R2 K10 ['x']
REMARK builtin assert/1
   51: assert(x[1] == 'aloxixi')
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 1
JUMPXEQKS R4 K25 L38 ['aloxixi']
LOADB R3 0 +1
L38: LOADB R3 1
L39: FASTCALL1 1 R3 L40
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK allocation: table array 1
   52: x = {f{}}
L40: NEWTABLE R2 0 1
GETGLOBAL R3 K17 ['f']
REMARK allocation: table hash 0
NEWTABLE R4 0 0
CALL R3 1 -1
SETLIST R2 R3 -1 [1]
SETGLOBAL R2 K10 ['x']
REMARK builtin assert/1
   53: assert(x[2] == 'jojo' and type(x[1]) == 'table')
LOADB R3 0
GETGLOBAL R5 K10 ['x']
GETTABLEN R4 R5 2
JUMPXEQKS R4 K26 L43 NOT ['jojo']
REMARK builtin type/1
GETGLOBAL R6 K10 ['x']
GETTABLEN R5 R6 1
FASTCALL1 40 R5 L41
GETIMPORT R4 28 [type]
CALL R4 1 1
L41: JUMPXEQKS R4 K29 L42 ['table']
LOADB R3 0 +1
L42: LOADB R3 1
L43: FASTCALL1 1 R3 L44
GETIMPORT R2 4 [assert]
CALL R2 1 0
   56: local f = function (i)
L44: DUPCLOSURE R2 K30 []
REMARK builtin assert/1
   63: assert(f(3) == 'a' and f(12) == 'b' and f(26) == 'c' and f(100) == nil)
LOADB R4 0
MOVE R5 R2
LOADN R6 3
CALL R5 1 1
JUMPXEQKS R5 K6 L46 NOT ['a']
LOADB R4 0
MOVE R5 R2
LOADN R6 12
CALL R5 1 1
JUMPXEQKS R5 K7 L46 NOT ['b']
LOADB R4 0
MOVE R5 R2
LOADN R6 26
CALL R5 1 1
JUMPXEQKS R5 K31 L46 NOT ['c']
MOVE R5 R2
LOADN R6 100
CALL R5 1 1
JUMPXEQKNIL R5 L45
LOADB R4 0 +1
L45: LOADB R4 1
L46: FASTCALL1 1 R4 L47
GETIMPORT R3 4 [assert]
CALL R3 1 0
   65: for i=1,1000 do break; end;
L47: LOADN R5 1
LOADN R3 1000
LOADN R4 1
FORNPREP R3 L48
JUMP L48
FORNLOOP R3 L48
   66: n=100;
L48: LOADN R3 100
SETGLOBAL R3 K32 ['n']
   67: i=3;
LOADN R3 3
SETGLOBAL R3 K33 ['i']
REMARK allocation: table hash 0
   68: t = {};
NEWTABLE R3 0 0
SETGLOBAL R3 K34 ['t']
   69: a=nil
LOADNIL R0
   70: while not a do
L49: JUMPIF R0 L54
   71:   a=0; for i=1,n do for i=i,1,-1 do a=a+1; t[i]=1; end; end;
LOADN R0 0
LOADN R5 1
GETGLOBAL R3 K32 ['n']
LOADN R4 1
FORNPREP R3 L53
L50: MOVE R8 R5
LOADN R6 1
LOADN R7 -1
FORNPREP R6 L52
L51: ADDK R0 R0 K8 [1]
GETGLOBAL R9 K34 ['t']
LOADN R10 1
SETTABLE R10 R9 R8
FORNLOOP R6 L51
L52: FORNLOOP R3 L50
   70: while not a do
L53: JUMPBACK L49
REMARK builtin assert/1
   73: assert(a == n*(n+1)/2 and i==3);
L54: LOADB R4 0
GETGLOBAL R7 K32 ['n']
GETGLOBAL R9 K32 ['n']
ADDK R8 R9 K8 [1]
MUL R6 R7 R8
DIVK R5 R6 K9 [2]
JUMPIFNOTEQ R0 R5 L56
GETGLOBAL R5 K33 ['i']
JUMPXEQKN R5 K19 L55 [3]
LOADB R4 0 +1
L55: LOADB R4 1
L56: FASTCALL1 1 R4 L57
GETIMPORT R3 4 [assert]
CALL R3 1 0
REMARK builtin assert/1
   74: assert(t[1] and t[n] and not t[0] and not t[n+1])
L57: GETGLOBAL R5 K34 ['t']
GETTABLEN R4 R5 1
JUMPIFNOT R4 L58
GETGLOBAL R5 K34 ['t']
GETGLOBAL R6 K32 ['n']
GETTABLE R4 R5 R6
JUMPIFNOT R4 L58
GETGLOBAL R6 K34 ['t']
LOADN R7 0
GETTABLE R5 R6 R7
NOT R4 R5
JUMPIFNOT R4 L58
GETGLOBAL R6 K34 ['t']
GETGLOBAL R8 K32 ['n']
ADDK R7 R8 K8 [1]
GETTABLE R5 R6 R7
NOT R4 R5
L58: FASTCALL1 1 R4 L59
GETIMPORT R3 4 [assert]
CALL R3 1 0
   76: function f(b)
L59: DUPCLOSURE R2 K35 ['f']
REMARK builtin assert/1
   89: assert(f(1) == 10 and f(2) == 20 and f(3) == 30 and f(4)==12)
LOADB R4 0
MOVE R5 R2
LOADN R6 1
CALL R5 1 1
JUMPXEQKN R5 K21 L61 NOT [10]
LOADB R4 0
MOVE R5 R2
LOADN R6 2
CALL R5 1 1
JUMPXEQKN R5 K36 L61 NOT [20]
LOADB R4 0
MOVE R5 R2
LOADN R6 3
CALL R5 1 1
JUMPXEQKN R5 K37 L61 NOT [30]
MOVE R5 R2
LOADN R6 4
CALL R5 1 1
JUMPXEQKN R5 K38 L60 [12]
LOADB R4 0 +1
L60: LOADB R4 1
L61: FASTCALL1 1 R4 L62
GETIMPORT R3 4 [assert]
CALL R3 1 0
   92: local f = function (i)
L62: DUPCLOSURE R3 K39 []
REMARK builtin assert/1
  100: assert(f(3) == 'a' and f(12) == 'b' and f(26) == 'c' and f(100) == 8)
LOADB R5 0
MOVE R6 R3
LOADN R7 3
CALL R6 1 1
JUMPXEQKS R6 K6 L64 NOT ['a']
LOADB R5 0
MOVE R6 R3
LOADN R7 12
CALL R6 1 1
JUMPXEQKS R6 K7 L64 NOT ['b']
LOADB R5 0
MOVE R6 R3
LOADN R7 26
CALL R6 1 1
JUMPXEQKS R6 K31 L64 NOT ['c']
MOVE R6 R3
LOADN R7 100
CALL R6 1 1
JUMPXEQKN R6 K40 L63 [8]
LOADB R5 0 +1
L63: LOADB R5 1
L64: FASTCALL1 1 R5 L65
GETIMPORT R4 4 [assert]
CALL R4 1 0
  102: local a, b = nil, 23
L65: LOADNIL R4
LOADN R5 23
REMARK allocation: table array 2
  103: x = {f(100)*2+3 or a, a or b+2}
NEWTABLE R6 0 2
MOVE R10 R3
LOADN R11 100
CALL R10 1 1
MULK R9 R10 K9 [2]
ADDK R8 R9 K19 [3]
OR R7 R8 R4
ORK R8 R4 K41 [25]
SETLIST R6 R7 2 [1]
SETGLOBAL R6 K10 ['x']
REMARK builtin assert/1
  104: assert(x[1] == 19 and x[2] == 25)
LOADB R7 0
GETGLOBAL R9 K10 ['x']
GETTABLEN R8 R9 1
JUMPXEQKN R8 K42 L67 NOT [19]
GETGLOBAL R9 K10 ['x']
GETTABLEN R8 R9 2
JUMPXEQKN R8 K41 L66 [25]
LOADB R7 0 +1
L66: LOADB R7 1
L67: FASTCALL1 1 R7 L68
GETIMPORT R6 4 [assert]
CALL R6 1 0
REMARK allocation: table template 2
  105: x = {f=2+3 or a, a = b+2}
L68: DUPTABLE R6 43
LOADN R7 5
SETTABLEKS R7 R6 K17 ['f']
LOADN R7 25
SETTABLEKS R7 R6 K6 ['a']
SETGLOBAL R6 K10 ['x']
REMARK builtin assert/1
  106: assert(x.f == 5 and x.a == 25)
LOADB R7 0
GETGLOBAL R9 K10 ['x']
GETTABLEKS R8 R9 K17 ['f']
JUMPXEQKN R8 K20 L70 NOT [5]
GETGLOBAL R9 K10 ['x']
GETTABLEKS R8 R9 K6 ['a']
JUMPXEQKN R8 K41 L69 [25]
LOADB R7 0 +1
L69: LOADB R7 1
L70: FASTCALL1 1 R7 L71
GETIMPORT R6 4 [assert]
CALL R6 1 0
REMARK allocation: table template 1
  108: a={y=1}
L71: DUPTABLE R6 44
LOADN R7 1
SETTABLEKS R7 R6 K11 ['y']
MOVE R4 R6
REMARK allocation: table array 1
  109: x = {a.y}
NEWTABLE R6 0 1
GETTABLEKS R7 R4 K11 ['y']
SETLIST R6 R7 1 [1]
SETGLOBAL R6 K10 ['x']
REMARK builtin assert/1
  110: assert(x[1] == 1)
GETGLOBAL R9 K10 ['x']
GETTABLEN R8 R9 1
JUMPXEQKN R8 K8 L72 [1]
LOADB R7 0 +1
L72: LOADB R7 1
L73: FASTCALL1 1 R7 L74
GETIMPORT R6 4 [assert]
CALL R6 1 0
  112: function f(i)
L74: DUPCLOSURE R3 K45 ['f']
  119: function g(i)
DUPCLOSURE R6 K46 ['g']
SETGLOBAL R6 K47 ['g']
  126: f(10); g(10);
MOVE R6 R3
LOADN R7 10
CALL R6 1 0
GETGLOBAL R6 K47 ['g']
LOADN R7 10
CALL R6 1 0
  129:   function f () return 1,2,3; end
DUPCLOSURE R3 K48 ['f']
  130:   local a, b, c = f();
MOVE R6 R3
CALL R6 0 3
REMARK builtin assert/1
  131:   assert(a==1 and b==2 and c==3)
LOADB R10 0
JUMPXEQKN R6 K8 L76 NOT [1]
LOADB R10 0
JUMPXEQKN R7 K9 L76 NOT [2]
JUMPXEQKN R8 K19 L75 [3]
LOADB R10 0 +1
L75: LOADB R10 1
L76: FASTCALL1 1 R10 L77
GETIMPORT R9 4 [assert]
CALL R9 1 0
  132:   a, b, c = (f());
L77: MOVE R12 R3
CALL R12 0 1
MOVE R9 R12
LOADNIL R10
LOADNIL R11
MOVE R6 R9
MOVE R7 R10
MOVE R8 R11
REMARK builtin assert/1
  133:   assert(a==1 and b==nil and c==nil)
LOADB R10 0
JUMPXEQKN R6 K8 L79 NOT [1]
LOADB R10 0
JUMPXEQKNIL R7 L79 NOT
JUMPXEQKNIL R8 L78
LOADB R10 0 +1
L78: LOADB R10 1
L79: FASTCALL1 1 R10 L80
GETIMPORT R9 4 [assert]
CALL R9 1 0
  136: local a,b = 3 and f();
L80: MOVE R8 R3
CALL R8 0 1
MOVE R6 R8
LOADNIL R7
REMARK builtin assert/1
  137: assert(a==1 and b==nil)
LOADB R9 0
JUMPXEQKN R6 K8 L82 NOT [1]
JUMPXEQKNIL R7 L81
LOADB R9 0 +1
L81: LOADB R9 1
L82: FASTCALL1 1 R9 L83
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK allocation: closure with 1 upvalues
  139: function g() f(); return; end;
L83: NEWCLOSURE R8 P8
CAPTURE REF R3
SETGLOBAL R8 K47 ['g']
REMARK builtin assert/1
  140: assert(g() == nil)
GETGLOBAL R10 K47 ['g']
CALL R10 0 1
JUMPXEQKNIL R10 L84
LOADB R9 0 +1
L84: LOADB R9 1
L85: FASTCALL1 1 R9 L86
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK allocation: closure with 1 upvalues
  141: function g() return nil or f() end
L86: NEWCLOSURE R8 P9
CAPTURE REF R3
SETGLOBAL R8 K47 ['g']
  142: a,b = g()
GETGLOBAL R8 K47 ['g']
CALL R8 0 2
MOVE R6 R8
MOVE R7 R9
REMARK builtin assert/1
  143: assert(a==1 and b==nil)
LOADB R9 0
JUMPXEQKN R6 K8 L88 NOT [1]
JUMPXEQKNIL R7 L87
LOADB R9 0 +1
L87: LOADB R9 1
L88: FASTCALL1 1 R9 L89
GETIMPORT R8 4 [assert]
CALL R8 1 0
  145: print'+';
L89: GETIMPORT R8 1 [print]
LOADK R9 K49 ['+']
CALL R8 1 0
  148: f = [[
LOADK R3 K50 []
  154: f = string.gsub(f, "%s+", "\n");   -- force a SETLINE between opcodes
GETIMPORT R8 53 [string.gsub]
MOVE R9 R3
LOADK R10 K54 ['%s+']
LOADK R11 K55 []
CALL R8 3 1
MOVE R3 R8
  155: f,a = loadstring(f)();
GETIMPORT R8 57 [loadstring]
MOVE R9 R3
CALL R8 1 1
CALL R8 0 2
MOVE R3 R8
MOVE R6 R9
REMARK builtin assert/1
  156: assert(a.a == 1 and a.b)
LOADB R9 0
GETTABLEKS R10 R6 K6 ['a']
JUMPXEQKN R10 K8 L90 NOT [1]
GETTABLEKS R9 R6 K7 ['b']
L90: FASTCALL1 1 R9 L91
GETIMPORT R8 4 [assert]
CALL R8 1 0
  158: function g (a,b,c,d,e)
L91: DUPCLOSURE R8 K58 ['g']
SETGLOBAL R8 K47 ['g']
  162: function h (a,b,c,d,e)
DUPCLOSURE R8 K59 ['h']
SETGLOBAL R8 K60 ['h']
REMARK builtin assert/1
  167: assert(f(2,1) == true and g(2,1) == 1 and h(2,1) == 1)
LOADB R9 0
MOVE R10 R3
LOADN R11 2
LOADN R12 1
CALL R10 2 1
JUMPXEQKB R10 1 L93 NOT
LOADB R9 0
GETGLOBAL R10 K47 ['g']
LOADN R11 2
LOADN R12 1
CALL R10 2 1
JUMPXEQKN R10 K8 L93 NOT [1]
GETGLOBAL R10 K60 ['h']
LOADN R11 2
LOADN R12 1
CALL R10 2 1
JUMPXEQKN R10 K8 L92 [1]
LOADB R9 0 +1
L92: LOADB R9 1
L93: FASTCALL1 1 R9 L94
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK builtin assert/1
  168: assert(f(1,2,'a') == 'a' and g(1,2,'a') == 1 and h(1,2,'a') == 1)
L94: LOADB R9 0
MOVE R10 R3
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKS R10 K6 L96 NOT ['a']
LOADB R9 0
GETGLOBAL R10 K47 ['g']
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKN R10 K8 L96 NOT [1]
GETGLOBAL R10 K60 ['h']
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKN R10 K8 L95 [1]
LOADB R9 0 +1
L95: LOADB R9 1
L96: FASTCALL1 1 R9 L97
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK builtin assert/2
  169: assert(f(1,2,'a')
L97: MOVE R10 R3
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKNIL R10 L98 NOT
LOADB R9 0 +1
L98: LOADB R9 1
L99: FASTCALL2K 1 R9 K61 L100 ['']
LOADK R10 K61 ['']
GETIMPORT R8 4 [assert]
CALL R8 2 0
REMARK builtin assert/1
  172: assert(f(1,2,'a') == 'a' and g(1,2,'a') == 1 and h(1,2,'a') == 1)
L100: LOADB R9 0
MOVE R10 R3
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKS R10 K6 L102 NOT ['a']
LOADB R9 0
GETGLOBAL R10 K47 ['g']
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKN R10 K8 L102 NOT [1]
GETGLOBAL R10 K60 ['h']
LOADN R11 1
LOADN R12 2
LOADK R13 K6 ['a']
CALL R10 3 1
JUMPXEQKN R10 K8 L101 [1]
LOADB R9 0 +1
L101: LOADB R9 1
L102: FASTCALL1 1 R9 L103
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK builtin assert/1
  173: assert(f(1,2,nil,1,'x') == 'x' and g(1,2,nil,1,'x') == 1 and
L103: LOADB R9 0
MOVE R10 R3
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADN R14 1
LOADK R15 K10 ['x']
CALL R10 5 1
JUMPXEQKS R10 K10 L105 NOT ['x']
LOADB R9 0
GETGLOBAL R10 K47 ['g']
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADN R14 1
LOADK R15 K10 ['x']
CALL R10 5 1
JUMPXEQKN R10 K8 L105 NOT [1]
  174:                                    h(1,2,nil,1,'x') == 1)
GETGLOBAL R10 K60 ['h']
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADN R14 1
LOADK R15 K10 ['x']
CALL R10 5 1
JUMPXEQKN R10 K8 L104 [1]
LOADB R9 0 +1
L104: LOADB R9 1
L105: FASTCALL1 1 R9 L106
  173: assert(f(1,2,nil,1,'x') == 'x' and g(1,2,nil,1,'x') == 1 and
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK builtin assert/1
  175: assert(f(1,2,nil,nil,'x') == nil and g(1,2,nil,nil,'x') == 0 and
L106: LOADB R9 0
MOVE R10 R3
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADNIL R14
LOADK R15 K10 ['x']
CALL R10 5 1
JUMPXEQKNIL R10 L108 NOT
LOADB R9 0
GETGLOBAL R10 K47 ['g']
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADNIL R14
LOADK R15 K10 ['x']
CALL R10 5 1
JUMPXEQKN R10 K62 L108 NOT [0]
  176:                                      h(1,2,nil,nil,'x') == 0)
GETGLOBAL R10 K60 ['h']
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADNIL R14
LOADK R15 K10 ['x']
CALL R10 5 1
JUMPXEQKN R10 K62 L107 [0]
LOADB R9 0 +1
L107: LOADB R9 1
L108: FASTCALL1 1 R9 L109
  175: assert(f(1,2,nil,nil,'x') == nil and g(1,2,nil,nil,'x') == 0 and
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK builtin assert/1
  177: assert(f(1,2,nil,1,nil) == nil and g(1,2,nil,1,nil) == 0 and
L109: LOADB R9 0
MOVE R10 R3
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADN R14 1
LOADNIL R15
CALL R10 5 1
JUMPXEQKNIL R10 L111 NOT
LOADB R9 0
GETGLOBAL R10 K47 ['g']
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADN R14 1
LOADNIL R15
CALL R10 5 1
JUMPXEQKN R10 K62 L111 NOT [0]
  178:                                    h(1,2,nil,1,nil) == 0)
GETGLOBAL R10 K60 ['h']
LOADN R11 1
LOADN R12 2
LOADNIL R13
LOADN R14 1
LOADNIL R15
CALL R10 5 1
JUMPXEQKN R10 K62 L110 [0]
LOADB R9 0 +1
L110: LOADB R9 1
L111: FASTCALL1 1 R9 L112
  177: assert(f(1,2,nil,1,nil) == nil and g(1,2,nil,1,nil) == 0 and
GETIMPORT R8 4 [assert]
CALL R8 1 0
REMARK builtin assert/1
  180: assert(1 and 2<3 == true and 2<3 and 'a'<'b' == true)
L112: LOADK R11 K6 ['a']
LOADK R12 K7 ['b']
JUMPIFLT R11 R12 L113
LOADB R10 0 +1
L113: LOADB R10 1
L114: JUMPXEQKB R10 1 L115
LOADB R9 0 +1
L115: LOADB R9 1
L116: FASTCALL1 1 R9 L117
GETIMPORT R8 4 [assert]
CALL R8 1 0
  181: x = 2<3 and not 3; assert(x==false)
L117: LOADB R8 0
SETGLOBAL R8 K10 ['x']
REMARK builtin assert/1
GETGLOBAL R10 K10 ['x']
JUMPXEQKB R10 0 L118
LOADB R9 0 +1
L118: LOADB R9 1
L119: FASTCALL1 1 R9 L120
GETIMPORT R8 4 [assert]
CALL R8 1 0
  182: x = 2<1 or (2>1 and 'a'); assert(x=='a')
L120: LOADK R8 K6 ['a']
SETGLOBAL R8 K10 ['x']
REMARK builtin assert/1
GETGLOBAL R10 K10 ['x']
JUMPXEQKS R10 K6 L121 ['a']
LOADB R9 0 +1
L121: LOADB R9 1
L122: FASTCALL1 1 R9 L123
GETIMPORT R8 4 [assert]
CALL R8 1 0
  186:   local a; if nil then a=1; else a=2; end;    -- this nil comes as PUSHNIL 2
L123: LOADNIL R8
LOADN R8 2
REMARK builtin assert/1
  187:   assert(a==2)
JUMPXEQKN R8 K9 L124 [2]
LOADB R10 0 +1
L124: LOADB R10 1
L125: FASTCALL1 1 R10 L126
GETIMPORT R9 4 [assert]
CALL R9 1 0
  190: function F(a)
L126: DUPCLOSURE R8 K63 ['F']
SETGLOBAL R8 K64 ['F']
  195: a,b = F(1)~=nil; assert(a == true and b == nil);
GETGLOBAL R10 K64 ['F']
LOADN R11 1
CALL R10 1 1
JUMPXEQKNIL R10 L127 NOT
LOADB R8 0 +1
L127: LOADB R8 1
L128: LOADNIL R9
MOVE R6 R8
MOVE R7 R9
REMARK builtin assert/1
LOADB R9 0
JUMPXEQKB R6 1 L130 NOT
JUMPXEQKNIL R7 L129
LOADB R9 0 +1
L129: LOADB R9 1
L130: FASTCALL1 1 R9 L131
GETIMPORT R8 4 [assert]
CALL R8 1 0
  196: a,b = F(nil)==nil; assert(a == true and b == nil)
L131: GETGLOBAL R10 K64 ['F']
LOADNIL R11
CALL R10 1 1
JUMPXEQKNIL R10 L132
LOADB R8 0 +1
L132: LOADB R8 1
L133: LOADNIL R9
MOVE R6 R8
MOVE R7 R9
REMARK builtin assert/1
LOADB R9 0
JUMPXEQKB R6 1 L135 NOT
JUMPXEQKNIL R7 L134
LOADB R9 0 +1
L134: LOADB R9 1
L135: FASTCALL1 1 R9 L136
GETIMPORT R8 4 [assert]
CALL R8 1 0
  202: function ID(x) return x end
L136: DUPCLOSURE R8 K65 ['ID']
SETGLOBAL R8 K66 ['ID']
  204: function f(t, i)
DUPCLOSURE R3 K67 ['f']
REMARK allocation: table hash 1 array 4
  211: local arg = {" ( 1 < 2 ) ", " ( 1 >= 2 ) ", " F ( ) ", "  nil "; n=4}
NEWTABLE R8 1 4
LOADK R9 K68 [' ( 1 < 2 ) ']
LOADK R10 K69 [' ( 1 >= 2 ) ']
LOADK R11 K70 [' F ( ) ']
LOADK R12 K71 ['  nil ']
SETLIST R8 R9 4 [1]
LOADN R13 4
SETTABLEKS R13 R8 K32 ['n']
REMARK allocation: table hash 1 array 4
  213: local op = {" and ", " or ", " == ", " ~= "; n=4}
NEWTABLE R9 1 4
LOADK R10 K72 [' and ']
LOADK R11 K73 [' or ']
LOADK R12 K74 [' == ']
LOADK R13 K75 [' ~= ']
SETLIST R9 R10 4 [1]
LOADN R14 4
SETTABLEKS R14 R9 K32 ['n']
REMARK allocation: table hash 1 array 2
  215: local neg = {" ", " not "; n=2}
NEWTABLE R10 1 2
LOADK R11 K76 [' ']
LOADK R12 K77 [' not ']
SETLIST R10 R11 2 [1]
LOADN R13 2
SETTABLEKS R13 R10 K32 ['n']
  217: local i = 0
LOADN R11 0
  219:   c = 1
L137: LOADN R12 1
SETGLOBAL R12 K31 ['c']
  220:   local s = f(neg, i)..'ID('..f(neg, i)..f(arg, i)..f(op, i)..f(neg, i)..'ID('..f(arg, i)..'))'
MOVE R22 R3
MOVE R23 R10
MOVE R24 R11
CALL R22 2 1
MOVE R13 R22
LOADK R14 K78 ['ID(']
MOVE R22 R3
MOVE R23 R10
MOVE R24 R11
CALL R22 2 1
MOVE R15 R22
MOVE R22 R3
MOVE R23 R8
MOVE R24 R11
CALL R22 2 1
MOVE R16 R22
MOVE R22 R3
MOVE R23 R9
MOVE R24 R11
CALL R22 2 1
MOVE R17 R22
MOVE R22 R3
MOVE R23 R10
MOVE R24 R11
CALL R22 2 1
MOVE R18 R22
LOADK R19 K78 ['ID(']
MOVE R22 R3
MOVE R23 R8
MOVE R24 R11
CALL R22 2 1
MOVE R20 R22
LOADK R21 K79 ['))']
CONCAT R12 R13 R21
  221:   local s1 = string.gsub(s, 'ID', '')
GETIMPORT R13 53 [string.gsub]
MOVE R14 R12
LOADK R15 K66 ['ID']
LOADK R16 K61 ['']
CALL R13 3 1
  222:   K,X,NX,WX1,WX2 = nil
LOADNIL R14
LOADNIL R15
LOADNIL R16
LOADNIL R17
LOADNIL R18
SETGLOBAL R14 K80 ['K']
SETGLOBAL R15 K81 ['X']
SETGLOBAL R16 K82 ['NX']
SETGLOBAL R17 K83 ['WX1']
SETGLOBAL R18 K84 ['WX2']
  223:   s = string.format([[
GETIMPORT R14 86 [string.format]
LOADK R15 K87 []
  233:   ]], s1, s, s1, s, s1, s, s1, s, s)
MOVE R16 R13
MOVE R17 R12
MOVE R18 R13
MOVE R19 R12
MOVE R20 R13
MOVE R21 R12
MOVE R22 R13
MOVE R23 R12
MOVE R24 R12
  223:   s = string.format([[
CALL R14 10 1
MOVE R12 R14
REMARK builtin assert/1+
  234:   assert(loadstring(s))()
GETIMPORT R15 57 [loadstring]
MOVE R16 R12
CALL R15 1 -1
FASTCALL 1 L138
GETIMPORT R14 4 [assert]
CALL R14 -1 1
L138: CALL R14 0 0
REMARK builtin assert/1
  235:   assert(X and not NX and not WX1 == K and not WX2 == K)
GETGLOBAL R15 K81 ['X']
JUMPIFNOT R15 L140
GETGLOBAL R16 K82 ['NX']
NOT R15 R16
JUMPIFNOT R15 L140
LOADB R15 0
GETGLOBAL R17 K83 ['WX1']
NOT R16 R17
GETGLOBAL R17 K80 ['K']
JUMPIFNOTEQ R16 R17 L140
GETGLOBAL R17 K84 ['WX2']
NOT R16 R17
GETGLOBAL R17 K80 ['K']
JUMPIFEQ R16 R17 L139
LOADB R15 0 +1
L139: LOADB R15 1
L140: FASTCALL1 1 R15 L141
GETIMPORT R14 4 [assert]
CALL R14 1 0
  236:   if i%4000 == 0 then print('+') end
L141: MODK R14 R11 K88 [4000]
JUMPXEQKN R14 K62 L142 NOT [0]
GETIMPORT R14 1 [print]
LOADK R15 K49 ['+']
CALL R14 1 0
  237:   i = i+1
L142: ADDK R11 R11 K8 [1]
  238: until i==c
GETGLOBAL R14 K31 ['c']
JUMPIFEQ R11 R14 L143
JUMPBACK L137
  240: print 'OK'
L143: GETIMPORT R12 1 [print]
LOADK R13 K89 ['OK']
CALL R12 1 0
  241: 
CLOSEUPVALS R3
RETURN R0 0

]====]
end