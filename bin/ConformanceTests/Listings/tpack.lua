--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (checkerror):
   39:   local status, err = pcall(f, ...)
GETIMPORT R2 1 [pcall]
MOVE R3 R1
GETVARARGS R4 -1
CALL R2 -1 2
REMARK builtin assert/1
   41:   assert(not status and string.find(err, msg))
NOT R5 R2
JUMPIFNOT R5 L0
GETIMPORT R5 4 [string.find]
MOVE R6 R3
MOVE R7 R0
CALL R5 2 1
L0: FASTCALL1 1 R5 L1
GETIMPORT R4 6 [assert]
CALL R4 1 0
   42: end
L1: RETURN R0 0

Function 1 (??):
    3: local pack = string.pack
GETIMPORT R0 2 [string.pack]
    4: local packsize = string.packsize
GETIMPORT R1 4 [string.packsize]
    5: local unpack = string.unpack
GETIMPORT R2 6 [string.unpack]
    7: print "testing pack/unpack"
GETIMPORT R3 8 [print]
LOADK R4 K9 ['testing pack/unpack']
CALL R3 1 0
   12: local sizeshort = packsize("h")
MOVE R3 R1
LOADK R4 K10 ['h']
CALL R3 1 1
   13: local sizeint = packsize("i")
MOVE R4 R1
LOADK R5 K11 ['i']
CALL R4 1 1
   14: local sizelong = packsize("l")
MOVE R5 R1
LOADK R6 K12 ['l']
CALL R5 1 1
   15: local sizesize_t = packsize("T")
MOVE R6 R1
LOADK R7 K13 ['T']
CALL R6 1 1
   16: local sizeLI = packsize("j")
MOVE R7 R1
LOADK R8 K14 ['j']
CALL R7 1 1
   17: local sizeMI = packsize("l")
MOVE R8 R1
LOADK R9 K12 ['l']
CALL R8 1 1
   18: local sizefloat = packsize("f")
MOVE R9 R1
LOADK R10 K15 ['f']
CALL R9 1 1
   19: local sizedouble = packsize("d")
MOVE R10 R1
LOADK R11 K16 ['d']
CALL R10 1 1
   20: local sizenumber = packsize("n")
MOVE R11 R1
LOADK R12 K17 ['n']
CALL R11 1 1
   21: local little = (pack("i2", 1) == "\1\0")
MOVE R13 R0
LOADK R14 K18 ['i2']
LOADN R15 1
CALL R13 2 1
JUMPXEQKS R13 K19 L0 []
LOADB R12 0 +1
L0: LOADB R12 1
   22: local align = packsize("!xXi16")
L1: MOVE R13 R1
LOADK R14 K20 ['!xXi16']
CALL R13 1 1
REMARK builtin assert/1
   24: assert(1 <= sizeshort and sizeshort <= sizeint and sizeint <= sizelong and
LOADB R15 0
LOADN R16 1
JUMPIFNOTLE R16 R3 L3
LOADB R15 0
JUMPIFNOTLE R3 R4 L3
LOADB R15 0
JUMPIFNOTLE R4 R5 L3
   25:        sizefloat <= sizedouble)
JUMPIFLE R9 R10 L2
LOADB R15 0 +1
L2: LOADB R15 1
L3: FASTCALL1 1 R15 L4
   24: assert(1 <= sizeshort and sizeshort <= sizeint and sizeint <= sizelong and
GETIMPORT R14 22 [assert]
CALL R14 1 0
   27: print("platform:")
L4: GETIMPORT R14 8 [print]
LOADK R15 K23 ['platform:']
CALL R14 1 0
   28: print(string.format(
GETIMPORT R14 8 [print]
GETIMPORT R15 25 [string.format]
   29:   "\tshort %d, int %d, long %d, size_t %d, float %d, double %d,\n\z
LOADK R16 K26 []
   31:    sizeshort, sizeint, sizelong, sizesize_t, sizefloat, sizedouble,
MOVE R17 R3
MOVE R18 R4
MOVE R19 R5
MOVE R20 R6
MOVE R21 R9
MOVE R22 R10
   32:    sizeLI, sizenumber))
MOVE R23 R7
MOVE R24 R11
   28: print(string.format(
CALL R15 9 -1
CALL R14 -1 0
   33: print("\t" .. (little and "little" or "big") .. " endian")
GETIMPORT R14 8 [print]
LOADK R16 K27 []
JUMPIFNOT R12 L5
LOADK R17 K28 ['little']
JUMP L6
L5: LOADK R17 K29 ['big']
L6: LOADK R18 K30 [' endian']
CONCAT R15 R16 R18
CALL R14 1 0
   34: print("\talignment: " .. align)
GETIMPORT R14 8 [print]
LOADK R16 K31 []
MOVE R17 R13
CONCAT R15 R16 R17
CALL R14 1 0
   38: function checkerror (msg, f, ...)
DUPCLOSURE R14 K32 ['checkerror']
SETGLOBAL R14 K33 ['checkerror']
REMARK builtin assert/1
   45: assert(unpack("B", pack("B", 0xff)) == 0xff)
MOVE R16 R2
LOADK R17 K34 ['B']
MOVE R18 R0
LOADK R19 K34 ['B']
LOADN R20 255
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K35 L7 [255]
LOADB R15 0 +1
L7: LOADB R15 1
L8: FASTCALL1 1 R15 L9
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   46: assert(unpack("b", pack("b", 0x7f)) == 0x7f)
L9: MOVE R16 R2
LOADK R17 K36 ['b']
MOVE R18 R0
LOADK R19 K36 ['b']
LOADN R20 127
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K37 L10 [127]
LOADB R15 0 +1
L10: LOADB R15 1
L11: FASTCALL1 1 R15 L12
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   47: assert(unpack("b", pack("b", -0x80)) == -0x80)
L12: MOVE R16 R2
LOADK R17 K36 ['b']
MOVE R18 R0
LOADK R19 K36 ['b']
LOADN R20 -128
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K38 L13 [-128]
LOADB R15 0 +1
L13: LOADB R15 1
L14: FASTCALL1 1 R15 L15
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   49: assert(unpack("H", pack("H", 0xffff)) == 0xffff)
L15: MOVE R16 R2
LOADK R17 K39 ['H']
MOVE R18 R0
LOADK R19 K39 ['H']
LOADK R20 K40 [65535]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K40 L16 [65535]
LOADB R15 0 +1
L16: LOADB R15 1
L17: FASTCALL1 1 R15 L18
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   50: assert(unpack("h", pack("h", 0x7fff)) == 0x7fff)
L18: MOVE R16 R2
LOADK R17 K10 ['h']
MOVE R18 R0
LOADK R19 K10 ['h']
LOADN R20 32767
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K41 L19 [32767]
LOADB R15 0 +1
L19: LOADB R15 1
L20: FASTCALL1 1 R15 L21
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   51: assert(unpack("h", pack("h", -0x8000)) == -0x8000)
L21: MOVE R16 R2
LOADK R17 K10 ['h']
MOVE R18 R0
LOADK R19 K10 ['h']
LOADN R20 -32768
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K42 L22 [-32768]
LOADB R15 0 +1
L22: LOADB R15 1
L23: FASTCALL1 1 R15 L24
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   53: assert(unpack("L", pack("L", 0xffffffff)) == 0xffffffff)
L24: MOVE R16 R2
LOADK R17 K43 ['L']
MOVE R18 R0
LOADK R19 K43 ['L']
LOADK R20 K44 [4294967295]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K44 L25 [4294967295]
LOADB R15 0 +1
L25: LOADB R15 1
L26: FASTCALL1 1 R15 L27
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   54: assert(unpack("l", pack("l", 0x7fffffff)) == 0x7fffffff)
L27: MOVE R16 R2
LOADK R17 K12 ['l']
MOVE R18 R0
LOADK R19 K12 ['l']
LOADK R20 K45 [2147483647]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K45 L28 [2147483647]
LOADB R15 0 +1
L28: LOADB R15 1
L29: FASTCALL1 1 R15 L30
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   55: assert(unpack("l", pack("l", -0x80000000)) == -0x80000000)
L30: MOVE R16 R2
LOADK R17 K12 ['l']
MOVE R18 R0
LOADK R19 K12 ['l']
LOADK R20 K46 [-2147483648]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K46 L31 [-2147483648]
LOADB R15 0 +1
L31: LOADB R15 1
L32: FASTCALL1 1 R15 L33
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   57: assert(unpack("J", pack("J", 0xffffffff)) == 0xffffffff)
L33: MOVE R16 R2
LOADK R17 K47 ['J']
MOVE R18 R0
LOADK R19 K47 ['J']
LOADK R20 K44 [4294967295]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K44 L34 [4294967295]
LOADB R15 0 +1
L34: LOADB R15 1
L35: FASTCALL1 1 R15 L36
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   58: assert(unpack("j", pack("j", 0x7fffffff)) == 0x7fffffff)
L36: MOVE R16 R2
LOADK R17 K14 ['j']
MOVE R18 R0
LOADK R19 K14 ['j']
LOADK R20 K45 [2147483647]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K45 L37 [2147483647]
LOADB R15 0 +1
L37: LOADB R15 1
L38: FASTCALL1 1 R15 L39
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
   59: assert(unpack("j", pack("j", -0x80000000)) == -0x80000000)
L39: MOVE R16 R2
LOADK R17 K14 ['j']
MOVE R18 R0
LOADK R19 K14 ['j']
LOADK R20 K46 [-2147483648]
CALL R18 2 -1
CALL R16 -1 1
JUMPXEQKN R16 K46 L40 [-2147483648]
LOADB R15 0 +1
L40: LOADB R15 1
L41: FASTCALL1 1 R15 L42
GETIMPORT R14 22 [assert]
CALL R14 1 0
   61: for i = 1, NB do
L42: LOADN R16 1
LOADN R14 16
LOADN R15 1
FORNPREP R14 L65
   63:   local s = string.rep("\xff", i)
L43: GETIMPORT R17 49 [string.rep]
LOADK R18 K50 ['ÿ']
MOVE R19 R16
CALL R17 2 1
REMARK builtin assert/1
   64:   assert(pack("i" .. i, -1) == s)
MOVE R20 R0
LOADK R22 K11 ['i']
MOVE R23 R16
CONCAT R21 R22 R23
LOADN R22 -1
CALL R20 2 1
JUMPIFEQ R20 R17 L44
LOADB R19 0 +1
L44: LOADB R19 1
L45: FASTCALL1 1 R19 L46
GETIMPORT R18 22 [assert]
CALL R18 1 0
REMARK builtin assert/1
   65:   assert(packsize("i" .. i) == #s)
L46: MOVE R20 R1
LOADK R22 K11 ['i']
MOVE R23 R16
CONCAT R21 R22 R23
CALL R20 1 1
LENGTH R21 R17
JUMPIFEQ R20 R21 L47
LOADB R19 0 +1
L47: LOADB R19 1
L48: FASTCALL1 1 R19 L49
GETIMPORT R18 22 [assert]
CALL R18 1 0
REMARK builtin assert/1
   66:   assert(unpack("i" .. i, s) == -1)
L49: MOVE R20 R2
LOADK R22 K11 ['i']
MOVE R23 R16
CONCAT R21 R22 R23
MOVE R22 R17
CALL R20 2 1
JUMPXEQKN R20 K51 L50 [-1]
LOADB R19 0 +1
L50: LOADB R19 1
L51: FASTCALL1 1 R19 L52
GETIMPORT R18 22 [assert]
CALL R18 1 0
   69:   s = "\xAA" .. string.rep("\0", i - 1)
L52: LOADK R18 K52 ['ª']
GETIMPORT R19 49 [string.rep]
LOADK R20 K53 []
SUBK R21 R16 K54 [1]
CALL R19 2 1
CONCAT R17 R18 R19
REMARK builtin assert/1
   70:   assert(pack("<I" .. i, 0xAA) == s)
MOVE R20 R0
LOADK R22 K55 ['<I']
MOVE R23 R16
CONCAT R21 R22 R23
LOADN R22 170
CALL R20 2 1
JUMPIFEQ R20 R17 L53
LOADB R19 0 +1
L53: LOADB R19 1
L54: FASTCALL1 1 R19 L55
GETIMPORT R18 22 [assert]
CALL R18 1 0
REMARK builtin assert/1
   71:   assert(unpack("<I" .. i, s) == 0xAA)
L55: MOVE R20 R2
LOADK R22 K55 ['<I']
MOVE R23 R16
CONCAT R21 R22 R23
MOVE R22 R17
CALL R20 2 1
JUMPXEQKN R20 K56 L56 [170]
LOADB R19 0 +1
L56: LOADB R19 1
L57: FASTCALL1 1 R19 L58
GETIMPORT R18 22 [assert]
CALL R18 1 0
REMARK builtin assert/1
   72:   assert(pack(">I" .. i, 0xAA) == s:reverse())
L58: MOVE R20 R0
LOADK R22 K57 ['>I']
MOVE R23 R16
CONCAT R21 R22 R23
LOADN R22 170
CALL R20 2 1
NAMECALL R21 R17 K58 ['reverse']
CALL R21 1 1
JUMPIFEQ R20 R21 L59
LOADB R19 0 +1
L59: LOADB R19 1
L60: FASTCALL1 1 R19 L61
GETIMPORT R18 22 [assert]
CALL R18 1 0
REMARK builtin assert/1
   73:   assert(unpack(">I" .. i, s:reverse()) == 0xAA)
L61: MOVE R20 R2
LOADK R22 K57 ['>I']
MOVE R23 R16
CONCAT R21 R22 R23
NAMECALL R22 R17 K58 ['reverse']
CALL R22 1 -1
CALL R20 -1 1
JUMPXEQKN R20 K56 L62 [170]
LOADB R19 0 +1
L62: LOADB R19 1
L63: FASTCALL1 1 R19 L64
GETIMPORT R18 22 [assert]
CALL R18 1 0
   61: for i = 1, NB do
L64: FORNLOOP R14 L43
   78:   local s = pack("<l", lnum)
L65: MOVE R14 R0
LOADK R15 K59 ['<l']
LOADK R16 K60 [6618611909121]
CALL R14 2 1
REMARK builtin assert/1
   79:   assert(unpack("<l", s) == lnum)
MOVE R17 R2
LOADK R18 K59 ['<l']
MOVE R19 R14
CALL R17 2 1
JUMPXEQKN R17 K60 L66 [6618611909121]
LOADB R16 0 +1
L66: LOADB R16 1
L67: FASTCALL1 1 R16 L68
GETIMPORT R15 22 [assert]
CALL R15 1 0
REMARK builtin assert/1
   80:   assert(unpack("<i" .. sizeMI + 1, s .. "\0") == lnum)
L68: MOVE R17 R2
LOADK R19 K61 ['<i']
ADDK R20 R8 K54 [1]
CONCAT R18 R19 R20
MOVE R20 R14
LOADK R21 K53 []
CONCAT R19 R20 R21
CALL R17 2 1
JUMPXEQKN R17 K60 L69 [6618611909121]
LOADB R16 0 +1
L69: LOADB R16 1
L70: FASTCALL1 1 R16 L71
GETIMPORT R15 22 [assert]
CALL R15 1 0
REMARK builtin assert/1
   81:   assert(unpack("<i" .. sizeMI + 1, s .. "\0") == lnum)
L71: MOVE R17 R2
LOADK R19 K61 ['<i']
ADDK R20 R8 K54 [1]
CONCAT R18 R19 R20
MOVE R20 R14
LOADK R21 K53 []
CONCAT R19 R20 R21
CALL R17 2 1
JUMPXEQKN R17 K60 L72 [6618611909121]
LOADB R16 0 +1
L72: LOADB R16 1
L73: FASTCALL1 1 R16 L74
GETIMPORT R15 22 [assert]
CALL R15 1 0
   83:   for i = sizeMI + 1, NB do
L74: ADDK R17 R8 K54 [1]
LOADN R15 16
LOADN R16 1
FORNPREP R15 L88
   84:     local s = pack("<l", -lnum)
L75: MOVE R18 R0
LOADK R19 K59 ['<l']
LOADK R20 K62 [-6618611909121]
CALL R18 2 1
REMARK builtin assert/1
   85:     assert(unpack("<l", s) == -lnum)
MOVE R21 R2
LOADK R22 K59 ['<l']
MOVE R23 R18
CALL R21 2 1
JUMPXEQKN R21 K62 L76 [-6618611909121]
LOADB R20 0 +1
L76: LOADB R20 1
L77: FASTCALL1 1 R20 L78
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
   87:     assert(unpack("<i" .. i, s .. ("\xFF"):rep(i - sizeMI)) == -lnum)
L78: MOVE R21 R2
LOADK R23 K61 ['<i']
MOVE R24 R17
CONCAT R22 R23 R24
MOVE R24 R18
LOADK R25 K50 ['ÿ']
SUB R27 R17 R8
NAMECALL R25 R25 K48 ['rep']
CALL R25 2 1
CONCAT R23 R24 R25
CALL R21 2 1
JUMPXEQKN R21 K62 L79 [-6618611909121]
LOADB R20 0 +1
L79: LOADB R20 1
L80: FASTCALL1 1 R20 L81
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
   88:     assert(unpack(">i" .. i, ("\xFF"):rep(i - sizeMI) .. s:reverse()) == -lnum)
L81: MOVE R21 R2
LOADK R23 K63 ['>i']
MOVE R24 R17
CONCAT R22 R23 R24
LOADK R26 K50 ['ÿ']
SUB R28 R17 R8
NAMECALL R26 R26 K48 ['rep']
CALL R26 2 1
MOVE R24 R26
NAMECALL R25 R18 K58 ['reverse']
CALL R25 1 1
CONCAT R23 R24 R25
CALL R21 2 1
JUMPXEQKN R21 K62 L82 [-6618611909121]
LOADB R20 0 +1
L82: LOADB R20 1
L83: FASTCALL1 1 R20 L84
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
   89:     assert(unpack("<I" .. i, s .. ("\0"):rep(i - sizeMI)) == 2^64-lnum)
L84: MOVE R21 R2
LOADK R23 K55 ['<I']
MOVE R24 R17
CONCAT R22 R23 R24
MOVE R24 R18
LOADK R25 K53 []
SUB R27 R17 R8
NAMECALL R25 R25 K48 ['rep']
CALL R25 2 1
CONCAT R23 R24 R25
CALL R21 2 1
JUMPXEQKN R21 K64 L85 [1.8446737455097643e+19]
LOADB R20 0 +1
L85: LOADB R20 1
L86: FASTCALL1 1 R20 L87
GETIMPORT R19 22 [assert]
CALL R19 1 0
   92:     checkerror("does not fit", unpack, "<I" .. i, ("\x00"):rep(i - 1) .. "\1")
L87: GETGLOBAL R19 K33 ['checkerror']
LOADK R20 K65 ['does not fit']
MOVE R21 R2
LOADK R23 K55 ['<I']
MOVE R24 R17
CONCAT R22 R23 R24
LOADK R26 K53 []
SUBK R28 R17 K54 [1]
NAMECALL R26 R26 K48 ['rep']
CALL R26 2 1
MOVE R24 R26
LOADK R25 K66 []
CONCAT R23 R24 R25
CALL R19 4 0
   93:     checkerror("does not fit", unpack, ">i" .. i, "\1" .. ("\x00"):rep(i - 1))
GETGLOBAL R19 K33 ['checkerror']
LOADK R20 K65 ['does not fit']
MOVE R21 R2
LOADK R23 K63 ['>i']
MOVE R24 R17
CONCAT R22 R23 R24
LOADK R24 K66 []
LOADK R25 K53 []
SUBK R27 R17 K54 [1]
NAMECALL R25 R25 K48 ['rep']
CALL R25 2 1
CONCAT R23 R24 R25
CALL R19 4 0
   83:   for i = sizeMI + 1, NB do
FORNLOOP R15 L75
   97: for i = 1, 4 do
L88: LOADN R16 1
LOADN R14 4
LOADN R15 1
FORNPREP R14 L103
REMARK builtin bit32.band/2+
  100:   local n = bit32.band(lnum, bit32.bnot(bit32.lshift(-1, i * 8)))
L89: LOADK R18 K67 [67305985]
REMARK builtin bit32.bnot/1+
REMARK builtin bit32.lshift/2
LOADN R21 -1
MULK R22 R16 K68 [8]
FASTCALL2 36 R21 R22 L90
GETIMPORT R20 71 [bit32.lshift]
CALL R20 2 -1
L90: FASTCALL 30 L91
GETIMPORT R19 73 [bit32.bnot]
CALL R19 -1 -1
L91: FASTCALL 29 L92
GETIMPORT R17 75 [bit32.band]
CALL R17 -1 1
REMARK builtin string.sub/3
  101:   local s = string.sub(lstr, 1, i)
L92: LOADK R19 K76 []
LOADN R20 1
MOVE R21 R16
FASTCALL 45 L93
GETIMPORT R18 78 [string.sub]
CALL R18 3 1
REMARK builtin assert/1
  102:   assert(pack("<i" .. i, n) == s)
L93: MOVE R21 R0
LOADK R23 K61 ['<i']
MOVE R24 R16
CONCAT R22 R23 R24
MOVE R23 R17
CALL R21 2 1
JUMPIFEQ R21 R18 L94
LOADB R20 0 +1
L94: LOADB R20 1
L95: FASTCALL1 1 R20 L96
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  103:   assert(pack(">i" .. i, n) == s:reverse())
L96: MOVE R21 R0
LOADK R23 K63 ['>i']
MOVE R24 R16
CONCAT R22 R23 R24
MOVE R23 R17
CALL R21 2 1
NAMECALL R22 R18 K58 ['reverse']
CALL R22 1 1
JUMPIFEQ R21 R22 L97
LOADB R20 0 +1
L97: LOADB R20 1
L98: FASTCALL1 1 R20 L99
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  104:   assert(unpack(">i" .. i, s:reverse()) == n)
L99: MOVE R21 R2
LOADK R23 K63 ['>i']
MOVE R24 R16
CONCAT R22 R23 R24
NAMECALL R23 R18 K58 ['reverse']
CALL R23 1 -1
CALL R21 -1 1
JUMPIFEQ R21 R17 L100
LOADB R20 0 +1
L100: LOADB R20 1
L101: FASTCALL1 1 R20 L102
GETIMPORT R19 22 [assert]
CALL R19 1 0
   97: for i = 1, 4 do
L102: FORNLOOP R14 L89
  109:   local u = 0xf0
L103: LOADN R14 240
  110:   for i = 1, sizeLI - 1 do
LOADN R17 1
SUBK R15 R7 K54 [1]
LOADN R16 1
FORNPREP R15 L111
REMARK builtin assert/1
  111:     assert(unpack("<i"..i, "\xf0"..("\xff"):rep(i - 1)) == -16)
L104: MOVE R20 R2
LOADK R22 K61 ['<i']
MOVE R23 R17
CONCAT R21 R22 R23
LOADK R23 K79 ['ð']
LOADK R24 K50 ['ÿ']
SUBK R26 R17 K54 [1]
NAMECALL R24 R24 K48 ['rep']
CALL R24 2 1
CONCAT R22 R23 R24
CALL R20 2 1
JUMPXEQKN R20 K80 L105 [-16]
LOADB R19 0 +1
L105: LOADB R19 1
L106: FASTCALL1 1 R19 L107
GETIMPORT R18 22 [assert]
CALL R18 1 0
REMARK builtin assert/1
  112:     assert(unpack(">I"..i, "\xf0"..("\xff"):rep(i - 1)) == u)
L107: MOVE R20 R2
LOADK R22 K57 ['>I']
MOVE R23 R17
CONCAT R21 R22 R23
LOADK R23 K79 ['ð']
LOADK R24 K50 ['ÿ']
SUBK R26 R17 K54 [1]
NAMECALL R24 R24 K48 ['rep']
CALL R24 2 1
CONCAT R22 R23 R24
CALL R20 2 1
JUMPIFEQ R20 R14 L108
LOADB R19 0 +1
L108: LOADB R19 1
L109: FASTCALL1 1 R19 L110
GETIMPORT R18 22 [assert]
CALL R18 1 0
  113:     u = u * 256 + 0xff
L110: MULK R18 R14 K81 [256]
ADDK R14 R18 K35 [255]
  110:   for i = 1, sizeLI - 1 do
FORNLOOP R15 L104
REMARK builtin assert/1
  119:   assert(pack(">i2 <i2", 10, 20) == "\0\10\20\0")
L111: MOVE R16 R0
LOADK R17 K82 ['>i2 <i2']
LOADN R18 10
LOADN R19 20
CALL R16 3 1
JUMPXEQKS R16 K83 L112 []
LOADB R15 0 +1
L112: LOADB R15 1
L113: FASTCALL1 1 R15 L114
GETIMPORT R14 22 [assert]
CALL R14 1 0
  120:   local a, b = unpack("<i2 >i2", "\10\0\0\20")
L114: MOVE R14 R2
LOADK R15 K84 ['<i2 >i2']
LOADK R16 K85 []
CALL R14 2 2
REMARK builtin assert/1
  121:   assert(a == 10 and b == 20)
LOADB R17 0
JUMPXEQKN R14 K86 L116 NOT [10]
JUMPXEQKN R15 K87 L115 [20]
LOADB R17 0 +1
L115: LOADB R17 1
L116: FASTCALL1 1 R17 L117
GETIMPORT R16 22 [assert]
CALL R16 1 0
REMARK builtin assert/1
  122:   assert(pack("=i4", 2001) == pack("i4", 2001))
L117: MOVE R18 R0
LOADK R19 K88 ['=i4']
LOADN R20 2001
CALL R18 2 1
MOVE R19 R0
LOADK R20 K89 ['i4']
LOADN R21 2001
CALL R19 2 1
JUMPIFEQ R18 R19 L118
LOADB R17 0 +1
L118: LOADB R17 1
L119: FASTCALL1 1 R17 L120
GETIMPORT R16 22 [assert]
CALL R16 1 0
  125: print("testing invalid formats")
L120: GETIMPORT R14 8 [print]
LOADK R15 K90 ['testing invalid formats']
CALL R14 1 0
  127: checkerror("out of limits", pack, "i0", 0)
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K91 ['out of limits']
MOVE R16 R0
LOADK R17 K92 ['i0']
LOADN R18 0
CALL R14 4 0
  128: checkerror("out of limits", pack, "i" .. NB + 1, 0)
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K91 ['out of limits']
MOVE R16 R0
LOADK R18 K11 ['i']
LOADN R19 17
CONCAT R17 R18 R19
LOADN R18 0
CALL R14 4 0
  129: checkerror("out of limits", pack, "!" .. NB + 1, 0)
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K91 ['out of limits']
MOVE R16 R0
LOADK R18 K93 ['!']
LOADN R19 17
CONCAT R17 R18 R19
LOADN R18 0
CALL R14 4 0
  130: checkerror("%(17%) out of limits %[1,16%]", pack, "Xi" .. NB + 1)
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K94 ['%(17%) out of limits %[1,16%]']
MOVE R16 R0
LOADK R18 K95 ['Xi']
LOADN R19 17
CONCAT R17 R18 R19
CALL R14 3 0
  131: checkerror("invalid format option 'r'", pack, "i3r", 0)
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K96 ['invalid format option 'r'']
MOVE R16 R0
LOADK R17 K97 ['i3r']
LOADN R18 0
CALL R14 4 0
  132: checkerror("16%-byte integer", unpack, "i16", string.rep('\3', 16))
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K98 ['16%-byte integer']
MOVE R16 R2
LOADK R17 K99 ['i16']
GETIMPORT R18 49 [string.rep]
LOADK R19 K100 []
LOADN R20 16
CALL R18 2 -1
CALL R14 -1 0
  133: checkerror("not power of 2", pack, "!4i3", 0);
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K101 ['not power of 2']
MOVE R16 R0
LOADK R17 K102 ['!4i3']
LOADN R18 0
CALL R14 4 0
  134: checkerror("missing size", pack, "c", "")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K103 ['missing size']
MOVE R16 R0
LOADK R17 K104 ['c']
LOADK R18 K105 ['']
CALL R14 4 0
  135: checkerror("variable%-length format", packsize, "s")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K106 ['variable%-length format']
MOVE R16 R1
LOADK R17 K107 ['s']
CALL R14 3 0
  136: checkerror("variable%-length format", packsize, "z")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K106 ['variable%-length format']
MOVE R16 R1
LOADK R17 K108 ['z']
CALL R14 3 0
  138: if packsize("i") == 4 then
MOVE R14 R1
LOADK R15 K11 ['i']
CALL R14 1 1
JUMPXEQKN R14 K109 L123 NOT [4]
  140:   local s = string.rep("c268435456", 2^3)
GETIMPORT R14 49 [string.rep]
LOADK R15 K110 ['c268435456']
LOADN R16 8
CALL R14 2 1
  141:   checkerror("too large", packsize, s)
GETGLOBAL R15 K33 ['checkerror']
LOADK R16 K111 ['too large']
MOVE R17 R1
MOVE R18 R14
CALL R15 3 0
  143:   s = string.rep("c268435456", 2^3 - 1) .. "c268435453"
GETIMPORT R17 49 [string.rep]
LOADK R18 K110 ['c268435456']
LOADN R19 7
CALL R17 2 1
MOVE R15 R17
LOADK R16 K112 ['c268435453']
CONCAT R14 R15 R16
  144:   checkerror("too large", packsize, s)
GETGLOBAL R15 K33 ['checkerror']
LOADK R16 K111 ['too large']
MOVE R17 R1
MOVE R18 R14
CALL R15 3 0
REMARK builtin assert/1
  146:   assert(packsize("c1073741824") == 2^30)
MOVE R17 R1
LOADK R18 K113 ['c1073741824']
CALL R17 1 1
JUMPXEQKN R17 K114 L121 [1073741824]
LOADB R16 0 +1
L121: LOADB R16 1
L122: FASTCALL1 1 R16 L123
GETIMPORT R15 22 [assert]
CALL R15 1 0
  150: for i = 1, 3 do
L123: LOADN R16 1
LOADN R14 3
LOADN R15 1
FORNPREP R14 L136
REMARK builtin bit32.lshift/2
  151:   local umax = bit32.lshift(1, i * 8) - 1
L124: LOADN R19 1
MULK R20 R16 K68 [8]
FASTCALL2 36 R19 R20 L125
GETIMPORT R18 71 [bit32.lshift]
CALL R18 2 1
L125: SUBK R17 R18 K54 [1]
REMARK builtin bit32.rshift/2
  152:   local max = bit32.rshift(umax, 1)
FASTCALL2K 39 R17 K54 L126 [1]
MOVE R19 R17
LOADK R20 K54 [1]
GETIMPORT R18 116 [bit32.rshift]
CALL R18 2 1
  153:   local min = -max-1
L126: MINUS R20 R18
SUBK R19 R20 K54 [1]
  154:   checkerror("overflow", pack, "<I" .. i, -1)
GETGLOBAL R20 K33 ['checkerror']
LOADK R21 K117 ['overflow']
MOVE R22 R0
LOADK R24 K55 ['<I']
MOVE R25 R16
CONCAT R23 R24 R25
LOADN R24 -1
CALL R20 4 0
  155:   checkerror("overflow", pack, "<I" .. i, min)
GETGLOBAL R20 K33 ['checkerror']
LOADK R21 K117 ['overflow']
MOVE R22 R0
LOADK R24 K55 ['<I']
MOVE R25 R16
CONCAT R23 R24 R25
MOVE R24 R19
CALL R20 4 0
  156:   checkerror("overflow", pack, ">I" .. i, umax + 1)
GETGLOBAL R20 K33 ['checkerror']
LOADK R21 K117 ['overflow']
MOVE R22 R0
LOADK R24 K57 ['>I']
MOVE R25 R16
CONCAT R23 R24 R25
ADDK R24 R17 K54 [1]
CALL R20 4 0
  158:   checkerror("overflow", pack, ">i" .. i, umax)
GETGLOBAL R20 K33 ['checkerror']
LOADK R21 K117 ['overflow']
MOVE R22 R0
LOADK R24 K63 ['>i']
MOVE R25 R16
CONCAT R23 R24 R25
MOVE R24 R17
CALL R20 4 0
  159:   checkerror("overflow", pack, ">i" .. i, max + 1)
GETGLOBAL R20 K33 ['checkerror']
LOADK R21 K117 ['overflow']
MOVE R22 R0
LOADK R24 K63 ['>i']
MOVE R25 R16
CONCAT R23 R24 R25
ADDK R24 R18 K54 [1]
CALL R20 4 0
  160:   checkerror("overflow", pack, "<i" .. i, min - 1)
GETGLOBAL R20 K33 ['checkerror']
LOADK R21 K117 ['overflow']
MOVE R22 R0
LOADK R24 K61 ['<i']
MOVE R25 R16
CONCAT R23 R24 R25
SUBK R24 R19 K54 [1]
CALL R20 4 0
REMARK builtin assert/1
  162:   assert(unpack(">i" .. i, pack(">i" .. i, max)) == max)
MOVE R22 R2
LOADK R24 K63 ['>i']
MOVE R25 R16
CONCAT R23 R24 R25
MOVE R24 R0
LOADK R26 K63 ['>i']
MOVE R27 R16
CONCAT R25 R26 R27
MOVE R26 R18
CALL R24 2 -1
CALL R22 -1 1
JUMPIFEQ R22 R18 L127
LOADB R21 0 +1
L127: LOADB R21 1
L128: FASTCALL1 1 R21 L129
GETIMPORT R20 22 [assert]
CALL R20 1 0
REMARK builtin assert/1
  163:   assert(unpack("<i" .. i, pack("<i" .. i, min)) == min)
L129: MOVE R22 R2
LOADK R24 K61 ['<i']
MOVE R25 R16
CONCAT R23 R24 R25
MOVE R24 R0
LOADK R26 K61 ['<i']
MOVE R27 R16
CONCAT R25 R26 R27
MOVE R26 R19
CALL R24 2 -1
CALL R22 -1 1
JUMPIFEQ R22 R19 L130
LOADB R21 0 +1
L130: LOADB R21 1
L131: FASTCALL1 1 R21 L132
GETIMPORT R20 22 [assert]
CALL R20 1 0
REMARK builtin assert/1
  164:   assert(unpack(">I" .. i, pack(">I" .. i, umax)) == umax)
L132: MOVE R22 R2
LOADK R24 K57 ['>I']
MOVE R25 R16
CONCAT R23 R24 R25
MOVE R24 R0
LOADK R26 K57 ['>I']
MOVE R27 R16
CONCAT R25 R26 R27
MOVE R26 R17
CALL R24 2 -1
CALL R22 -1 1
JUMPIFEQ R22 R17 L133
LOADB R21 0 +1
L133: LOADB R21 1
L134: FASTCALL1 1 R21 L135
GETIMPORT R20 22 [assert]
CALL R20 1 0
  150: for i = 1, 3 do
L135: FORNLOOP R14 L124
  167: if little then
L136: JUMPIFNOT R12 L140
REMARK builtin assert/1
  168:   assert(pack("f", 24) == pack("<f", 24))
MOVE R16 R0
LOADK R17 K15 ['f']
LOADN R18 24
CALL R16 2 1
MOVE R17 R0
LOADK R18 K118 ['<f']
LOADN R19 24
CALL R17 2 1
JUMPIFEQ R16 R17 L137
LOADB R15 0 +1
L137: LOADB R15 1
L138: FASTCALL1 1 R15 L139
GETIMPORT R14 22 [assert]
CALL R14 1 0
L139: JUMP L143
REMARK builtin assert/1
  170:   assert(pack("f", 24) == pack(">f", 24))
L140: MOVE R16 R0
LOADK R17 K15 ['f']
LOADN R18 24
CALL R16 2 1
MOVE R17 R0
LOADK R18 K119 ['>f']
LOADN R19 24
CALL R17 2 1
JUMPIFEQ R16 R17 L141
LOADB R15 0 +1
L141: LOADB R15 1
L142: FASTCALL1 1 R15 L143
GETIMPORT R14 22 [assert]
CALL R14 1 0
  173: print "testing pack/unpack of floating-point numbers" 
L143: GETIMPORT R14 8 [print]
LOADK R15 K120 ['testing pack/unpack of floating-'...]
CALL R14 1 0
  175: for _, n in ipairs{0, -1.1, 1.9, 1/0, -1/0, 1e20, -1e20, 0.1, 2000.7} do
GETIMPORT R14 122 [ipairs]
REMARK allocation: table array 9
NEWTABLE R15 0 9
LOADN R17 0
LOADK R18 K123 [-1.1000000000000001]
LOADK R19 K124 [1.8999999999999999]
LOADK R20 K125 [inf]
LOADK R21 K126 [-inf]
LOADK R22 K127 [1e+20]
LOADK R23 K128 [-1e+20]
LOADK R24 K129 [0.10000000000000001]
LOADK R25 K130 [2000.7]
SETLIST R15 R17 9 [1]
CALL R14 1 3
FORGPREP_INEXT R14 L159
REMARK builtin assert/1
  176:     assert(unpack("n", pack("n", n)) == n)
L144: MOVE R21 R2
LOADK R22 K17 ['n']
MOVE R23 R0
LOADK R24 K17 ['n']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L145
LOADB R20 0 +1
L145: LOADB R20 1
L146: FASTCALL1 1 R20 L147
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  177:     assert(unpack("<n", pack("<n", n)) == n)
L147: MOVE R21 R2
LOADK R22 K131 ['<n']
MOVE R23 R0
LOADK R24 K131 ['<n']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L148
LOADB R20 0 +1
L148: LOADB R20 1
L149: FASTCALL1 1 R20 L150
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  178:     assert(unpack(">n", pack(">n", n)) == n)
L150: MOVE R21 R2
LOADK R22 K132 ['>n']
MOVE R23 R0
LOADK R24 K132 ['>n']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L151
LOADB R20 0 +1
L151: LOADB R20 1
L152: FASTCALL1 1 R20 L153
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  179:     assert(pack("<f", n) == pack(">f", n):reverse())
L153: MOVE R21 R0
LOADK R22 K118 ['<f']
MOVE R23 R18
CALL R21 2 1
MOVE R22 R0
LOADK R23 K119 ['>f']
MOVE R24 R18
CALL R22 2 1
NAMECALL R22 R22 K58 ['reverse']
CALL R22 1 1
JUMPIFEQ R21 R22 L154
LOADB R20 0 +1
L154: LOADB R20 1
L155: FASTCALL1 1 R20 L156
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  180:     assert(pack(">d", n) == pack("<d", n):reverse())
L156: MOVE R21 R0
LOADK R22 K133 ['>d']
MOVE R23 R18
CALL R21 2 1
MOVE R22 R0
LOADK R23 K134 ['<d']
MOVE R24 R18
CALL R22 2 1
NAMECALL R22 R22 K58 ['reverse']
CALL R22 1 1
JUMPIFEQ R21 R22 L157
LOADB R20 0 +1
L157: LOADB R20 1
L158: FASTCALL1 1 R20 L159
GETIMPORT R19 22 [assert]
CALL R19 1 0
  175: for _, n in ipairs{0, -1.1, 1.9, 1/0, -1/0, 1e20, -1e20, 0.1, 2000.7} do
L159: FORGLOOP R14 L144 2 [inext]
  184: for _, n in ipairs{0, -1.5, 1/0, -1/0, 1e10, -1e9, 0.5, 2000.25} do
GETIMPORT R14 122 [ipairs]
REMARK allocation: table array 8
NEWTABLE R15 0 8
LOADN R17 0
LOADK R18 K135 [-1.5]
LOADK R19 K125 [inf]
LOADK R20 K126 [-inf]
LOADK R21 K136 [10000000000]
LOADK R22 K137 [-1000000000]
LOADK R23 K138 [0.5]
LOADK R24 K139 [2000.25]
SETLIST R15 R17 8 [1]
CALL R14 1 3
FORGPREP_INEXT R14 L172
REMARK builtin assert/1
  185:   assert(unpack("<f", pack("<f", n)) == n)
L160: MOVE R21 R2
LOADK R22 K118 ['<f']
MOVE R23 R0
LOADK R24 K118 ['<f']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L161
LOADB R20 0 +1
L161: LOADB R20 1
L162: FASTCALL1 1 R20 L163
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  186:   assert(unpack(">f", pack(">f", n)) == n)
L163: MOVE R21 R2
LOADK R22 K119 ['>f']
MOVE R23 R0
LOADK R24 K119 ['>f']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L164
LOADB R20 0 +1
L164: LOADB R20 1
L165: FASTCALL1 1 R20 L166
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  187:   assert(unpack("<d", pack("<d", n)) == n)
L166: MOVE R21 R2
LOADK R22 K134 ['<d']
MOVE R23 R0
LOADK R24 K134 ['<d']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L167
LOADB R20 0 +1
L167: LOADB R20 1
L168: FASTCALL1 1 R20 L169
GETIMPORT R19 22 [assert]
CALL R19 1 0
REMARK builtin assert/1
  188:   assert(unpack(">d", pack(">d", n)) == n)
L169: MOVE R21 R2
LOADK R22 K133 ['>d']
MOVE R23 R0
LOADK R24 K133 ['>d']
MOVE R25 R18
CALL R23 2 -1
CALL R21 -1 1
JUMPIFEQ R21 R18 L170
LOADB R20 0 +1
L170: LOADB R20 1
L171: FASTCALL1 1 R20 L172
GETIMPORT R19 22 [assert]
CALL R19 1 0
  184: for _, n in ipairs{0, -1.5, 1/0, -1/0, 1e10, -1e9, 0.5, 2000.25} do
L172: FORGLOOP R14 L160 2 [inext]
  191: print "testing pack/unpack of strings"
GETIMPORT R14 8 [print]
LOADK R15 K140 ['testing pack/unpack of strings']
CALL R14 1 0
  193:   local s = string.rep("abc", 1000)
GETIMPORT R14 49 [string.rep]
LOADK R15 K141 ['abc']
LOADN R16 1000
CALL R14 2 1
REMARK builtin assert/1
  194:   assert(pack("zB", s, 247) == s .. "\0\xF7")
MOVE R17 R0
LOADK R18 K142 ['zB']
MOVE R19 R14
LOADN R20 247
CALL R17 3 1
MOVE R19 R14
LOADK R20 K143 []
CONCAT R18 R19 R20
JUMPIFEQ R17 R18 L173
LOADB R16 0 +1
L173: LOADB R16 1
L174: FASTCALL1 1 R16 L175
GETIMPORT R15 22 [assert]
CALL R15 1 0
  195:   local s1, b = unpack("zB", s .. "\0\xF9")
L175: MOVE R15 R2
LOADK R16 K142 ['zB']
MOVE R18 R14
LOADK R19 K144 []
CONCAT R17 R18 R19
CALL R15 2 2
REMARK builtin assert/1
  196:   assert(b == 249 and s1 == s)
LOADB R18 0
JUMPXEQKN R16 K145 L177 NOT [249]
JUMPIFEQ R15 R14 L176
LOADB R18 0 +1
L176: LOADB R18 1
L177: FASTCALL1 1 R18 L178
GETIMPORT R17 22 [assert]
CALL R17 1 0
  197:   s1 = pack("s", s)
L178: MOVE R17 R0
LOADK R18 K107 ['s']
MOVE R19 R14
CALL R17 2 1
MOVE R15 R17
REMARK builtin assert/1
  198:   assert(unpack("s", s1) == s)
MOVE R19 R2
LOADK R20 K107 ['s']
MOVE R21 R15
CALL R19 2 1
JUMPIFEQ R19 R14 L179
LOADB R18 0 +1
L179: LOADB R18 1
L180: FASTCALL1 1 R18 L181
GETIMPORT R17 22 [assert]
CALL R17 1 0
  200:   checkerror("does not fit", pack, "s1", s)
L181: GETGLOBAL R17 K33 ['checkerror']
LOADK R18 K65 ['does not fit']
MOVE R19 R0
LOADK R20 K146 ['s1']
MOVE R21 R14
CALL R17 4 0
  202:   checkerror("contains zeros", pack, "z", "alo\0");
GETGLOBAL R17 K33 ['checkerror']
LOADK R18 K147 ['contains zeros']
MOVE R19 R0
LOADK R20 K108 ['z']
LOADK R21 K148 []
CALL R17 4 0
  204:   checkerror("unfinished string", unpack, "zc10000000", "alo")
GETGLOBAL R17 K33 ['checkerror']
LOADK R18 K149 ['unfinished string']
MOVE R19 R2
LOADK R20 K150 ['zc10000000']
LOADK R21 K151 ['alo']
CALL R17 4 0
  206:   for i = 2, NB do
LOADN R19 2
LOADN R17 16
LOADN R18 1
FORNPREP R17 L186
  207:     local s1 = pack("s" .. i, s)
L182: MOVE R20 R0
LOADK R22 K107 ['s']
MOVE R23 R19
CONCAT R21 R22 R23
MOVE R22 R14
CALL R20 2 1
REMARK builtin assert/1
  208:     assert(unpack("s" .. i, s1) == s and #s1 == #s + i)
LOADB R22 0
MOVE R23 R2
LOADK R25 K107 ['s']
MOVE R26 R19
CONCAT R24 R25 R26
MOVE R25 R20
CALL R23 2 1
JUMPIFNOTEQ R23 R14 L184
LENGTH R23 R20
LENGTH R25 R14
ADD R24 R25 R19
JUMPIFEQ R23 R24 L183
LOADB R22 0 +1
L183: LOADB R22 1
L184: FASTCALL1 1 R22 L185
GETIMPORT R21 22 [assert]
CALL R21 1 0
  206:   for i = 2, NB do
L185: FORNLOOP R17 L182
  213:   local x = pack("s", "alo")
L186: MOVE R14 R0
LOADK R15 K107 ['s']
LOADK R16 K151 ['alo']
CALL R14 2 1
  214:   checkerror("too short", unpack, "s", x:sub(1, -2))
GETGLOBAL R15 K33 ['checkerror']
LOADK R16 K152 ['too short']
MOVE R17 R2
LOADK R18 K107 ['s']
LOADN R21 1
LOADN R22 -2
NAMECALL R19 R14 K77 ['sub']
CALL R19 3 -1
CALL R15 -1 0
  215:   checkerror("too short", unpack, "c5", "abcd")
GETGLOBAL R15 K33 ['checkerror']
LOADK R16 K152 ['too short']
MOVE R17 R2
LOADK R18 K153 ['c5']
LOADK R19 K154 ['abcd']
CALL R15 4 0
  216:   checkerror("out of limits", pack, "s100", "alo")
GETGLOBAL R15 K33 ['checkerror']
LOADK R16 K91 ['out of limits']
MOVE R17 R0
LOADK R18 K155 ['s100']
LOADK R19 K151 ['alo']
CALL R15 4 0
REMARK builtin assert/1
  220:   assert(pack("c0", "") == "")
MOVE R16 R0
LOADK R17 K156 ['c0']
LOADK R18 K105 ['']
CALL R16 2 1
JUMPXEQKS R16 K105 L187 ['']
LOADB R15 0 +1
L187: LOADB R15 1
L188: FASTCALL1 1 R15 L189
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  221:   assert(packsize("c0") == 0)
L189: MOVE R16 R1
LOADK R17 K156 ['c0']
CALL R16 1 1
JUMPXEQKN R16 K157 L190 [0]
LOADB R15 0 +1
L190: LOADB R15 1
L191: FASTCALL1 1 R15 L192
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  222:   assert(unpack("c0", "") == "")
L192: MOVE R16 R2
LOADK R17 K156 ['c0']
LOADK R18 K105 ['']
CALL R16 2 1
JUMPXEQKS R16 K105 L193 ['']
LOADB R15 0 +1
L193: LOADB R15 1
L194: FASTCALL1 1 R15 L195
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  223:   assert(pack("<! c3", "abc") == "abc")
L195: MOVE R16 R0
LOADK R17 K158 ['<! c3']
LOADK R18 K141 ['abc']
CALL R16 2 1
JUMPXEQKS R16 K141 L196 ['abc']
LOADB R15 0 +1
L196: LOADB R15 1
L197: FASTCALL1 1 R15 L198
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  224:   assert(packsize("<! c3") == 3)
L198: MOVE R16 R1
LOADK R17 K158 ['<! c3']
CALL R16 1 1
JUMPXEQKN R16 K159 L199 [3]
LOADB R15 0 +1
L199: LOADB R15 1
L200: FASTCALL1 1 R15 L201
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  225:   assert(pack(">!4 c6", "abcdef") == "abcdef")
L201: MOVE R16 R0
LOADK R17 K160 ['>!4 c6']
LOADK R18 K161 ['abcdef']
CALL R16 2 1
JUMPXEQKS R16 K161 L202 ['abcdef']
LOADB R15 0 +1
L202: LOADB R15 1
L203: FASTCALL1 1 R15 L204
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  226:   assert(pack("c3", "123") == "123")
L204: MOVE R16 R0
LOADK R17 K162 ['c3']
LOADK R18 K163 ['123']
CALL R16 2 1
JUMPXEQKS R16 K163 L205 ['123']
LOADB R15 0 +1
L205: LOADB R15 1
L206: FASTCALL1 1 R15 L207
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  227:   assert(pack("c0", "") == "")
L207: MOVE R16 R0
LOADK R17 K156 ['c0']
LOADK R18 K105 ['']
CALL R16 2 1
JUMPXEQKS R16 K105 L208 ['']
LOADB R15 0 +1
L208: LOADB R15 1
L209: FASTCALL1 1 R15 L210
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  228:   assert(pack("c8", "123456") == "123456\0\0")
L210: MOVE R16 R0
LOADK R17 K164 ['c8']
LOADK R18 K165 ['123456']
CALL R16 2 1
JUMPXEQKS R16 K166 L211 []
LOADB R15 0 +1
L211: LOADB R15 1
L212: FASTCALL1 1 R15 L213
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  229:   assert(pack("c88", "") == string.rep("\0", 88))
L213: MOVE R16 R0
LOADK R17 K167 ['c88']
LOADK R18 K105 ['']
CALL R16 2 1
GETIMPORT R17 49 [string.rep]
LOADK R18 K53 []
LOADN R19 88
CALL R17 2 1
JUMPIFEQ R16 R17 L214
LOADB R15 0 +1
L214: LOADB R15 1
L215: FASTCALL1 1 R15 L216
GETIMPORT R14 22 [assert]
CALL R14 1 0
REMARK builtin assert/1
  230:   assert(pack("c188", "ab") == "ab" .. string.rep("\0", 188 - 2))
L216: MOVE R16 R0
LOADK R17 K168 ['c188']
LOADK R18 K169 ['ab']
CALL R16 2 1
LOADK R18 K169 ['ab']
GETIMPORT R19 49 [string.rep]
LOADK R20 K53 []
LOADN R21 186
CALL R19 2 1
CONCAT R17 R18 R19
JUMPIFEQ R16 R17 L217
LOADB R15 0 +1
L217: LOADB R15 1
L218: FASTCALL1 1 R15 L219
GETIMPORT R14 22 [assert]
CALL R14 1 0
  231:   local a, b, c = unpack("!4 z c3", "abcdefghi\0xyz")
L219: MOVE R14 R2
LOADK R15 K170 ['!4 z c3']
LOADK R16 K171 []
CALL R14 2 3
REMARK builtin assert/1
  232:   assert(a == "abcdefghi" and b == "xyz" and c == 14)
LOADB R18 0
JUMPXEQKS R14 K172 L221 NOT ['abcdefghi']
LOADB R18 0
JUMPXEQKS R15 K173 L221 NOT ['xyz']
JUMPXEQKN R16 K174 L220 [14]
LOADB R18 0 +1
L220: LOADB R18 1
L221: FASTCALL1 1 R18 L222
GETIMPORT R17 22 [assert]
CALL R17 1 0
  233:   checkerror("longer than", pack, "c3", "1234")
L222: GETGLOBAL R17 K33 ['checkerror']
LOADK R18 K175 ['longer than']
MOVE R19 R0
LOADK R20 K162 ['c3']
LOADK R21 K176 ['1234']
CALL R17 4 0
  239:   local x = pack("<b h b f d f n i", 1, 2, 3, 4, 5, 6, 7, 8)
MOVE R14 R0
LOADK R15 K177 ['<b h b f d f n i']
LOADN R16 1
LOADN R17 2
LOADN R18 3
LOADN R19 4
LOADN R20 5
LOADN R21 6
LOADN R22 7
LOADN R23 8
CALL R14 9 1
REMARK builtin assert/1
  240:   assert(#x == packsize("<b h b f d f n i"))
LENGTH R17 R14
MOVE R18 R1
LOADK R19 K177 ['<b h b f d f n i']
CALL R18 1 1
JUMPIFEQ R17 R18 L223
LOADB R16 0 +1
L223: LOADB R16 1
L224: FASTCALL1 1 R16 L225
GETIMPORT R15 22 [assert]
CALL R15 1 0
  241:   local a, b, c, d, e, f, g, h = unpack("<b h b f d f n i", x)
L225: MOVE R15 R2
LOADK R16 K177 ['<b h b f d f n i']
MOVE R17 R14
CALL R15 2 8
REMARK builtin assert/1
  242:   assert(a == 1 and b == 2 and c == 3 and d == 4 and e == 5 and f == 6 and
LOADB R24 0
JUMPXEQKN R15 K54 L227 NOT [1]
LOADB R24 0
JUMPXEQKN R16 K178 L227 NOT [2]
LOADB R24 0
JUMPXEQKN R17 K159 L227 NOT [3]
LOADB R24 0
JUMPXEQKN R18 K109 L227 NOT [4]
LOADB R24 0
JUMPXEQKN R19 K179 L227 NOT [5]
LOADB R24 0
JUMPXEQKN R20 K180 L227 NOT [6]
LOADB R24 0
JUMPXEQKN R21 K181 L227 NOT [7]
  243:          g == 7 and h == 8) 
JUMPXEQKN R22 K68 L226 [8]
LOADB R24 0 +1
L226: LOADB R24 1
L227: FASTCALL1 1 R24 L228
  242:   assert(a == 1 and b == 2 and c == 3 and d == 4 and e == 5 and f == 6 and
GETIMPORT R23 22 [assert]
CALL R23 1 0
  246: print "testing alignment"
L228: GETIMPORT R14 8 [print]
LOADK R15 K182 ['testing alignment']
CALL R14 1 0
REMARK builtin assert/1
  248:   assert(pack(" < i1 i2 ", 2, 3) == "\2\3\0")   -- no alignment by default
MOVE R16 R0
LOADK R17 K183 [' < i1 i2 ']
LOADN R18 2
LOADN R19 3
CALL R16 3 1
JUMPXEQKS R16 K184 L229 []
LOADB R15 0 +1
L229: LOADB R15 1
L230: FASTCALL1 1 R15 L231
GETIMPORT R14 22 [assert]
CALL R14 1 0
  249:   local x = pack(">!8 b Xh i4 i8 c1 Xi8", -12, 100, 200, "\xEC")
L231: MOVE R14 R0
LOADK R15 K185 ['>!8 b Xh i4 i8 c1 Xi8']
LOADN R16 -12
LOADN R17 100
LOADN R18 200
LOADK R19 K186 ['ì']
CALL R14 5 1
REMARK builtin assert/1
  250:   assert(#x == packsize(">!8 b Xh i4 i8 c1 Xi8"))
LENGTH R17 R14
MOVE R18 R1
LOADK R19 K185 ['>!8 b Xh i4 i8 c1 Xi8']
CALL R18 1 1
JUMPIFEQ R17 R18 L232
LOADB R16 0 +1
L232: LOADB R16 1
L233: FASTCALL1 1 R16 L234
GETIMPORT R15 22 [assert]
CALL R15 1 0
REMARK builtin assert/1
  251:   assert(x == "\xf4" .. "\0\0\0" ..
L234: LOADK R18 K187 ['ô']
LOADK R19 K188 []
  252:               "\0\0\0\100" ..
LOADK R20 K189 []
  253:               "\0\0\0\0\0\0\0\xC8" .. 
LOADK R21 K190 []
  254:               "\xEC" .. "\0\0\0\0\0\0\0")
LOADK R22 K186 ['ì']
LOADK R23 K191 []
CONCAT R17 R18 R23
JUMPIFEQ R14 R17 L235
LOADB R16 0 +1
L235: LOADB R16 1
L236: FASTCALL1 1 R16 L237
  251:   assert(x == "\xf4" .. "\0\0\0" ..
GETIMPORT R15 22 [assert]
CALL R15 1 0
  255:   local a, b, c, d, pos = unpack(">!8 c1 Xh i4 i8 b Xi8 XI XH", x)
L237: MOVE R15 R2
LOADK R16 K192 ['>!8 c1 Xh i4 i8 b Xi8 XI XH']
MOVE R17 R14
CALL R15 2 5
REMARK builtin assert/1
  256:   assert(a == "\xF4" and b == 100 and c == 200 and d == -20 and (pos - 1) == #x)
LOADB R21 0
JUMPXEQKS R15 K187 L239 NOT ['ô']
LOADB R21 0
JUMPXEQKN R16 K193 L239 NOT [100]
LOADB R21 0
JUMPXEQKN R17 K194 L239 NOT [200]
LOADB R21 0
JUMPXEQKN R18 K195 L239 NOT [-20]
SUBK R22 R19 K54 [1]
LENGTH R23 R14
JUMPIFEQ R22 R23 L238
LOADB R21 0 +1
L238: LOADB R21 1
L239: FASTCALL1 1 R21 L240
GETIMPORT R20 22 [assert]
CALL R20 1 0
  258:   x = pack(">!4 c3 c4 c2 z i4 c5 c2 Xi4",
L240: MOVE R20 R0
LOADK R21 K196 ['>!4 c3 c4 c2 z i4 c5 c2 Xi4']
  259:                   "abc", "abcd", "xz", "hello", 5, "world", "xy")
LOADK R22 K141 ['abc']
LOADK R23 K154 ['abcd']
LOADK R24 K197 ['xz']
LOADK R25 K198 ['hello']
LOADN R26 5
LOADK R27 K199 ['world']
LOADK R28 K200 ['xy']
  258:   x = pack(">!4 c3 c4 c2 z i4 c5 c2 Xi4",
CALL R20 8 1
MOVE R14 R20
REMARK builtin assert/1
  260:   assert(x == "abcabcdxzhello\0\0\0\0\0\5worldxy\0")
JUMPXEQKS R14 K201 L241 []
LOADB R21 0 +1
L241: LOADB R21 1
L242: FASTCALL1 1 R21 L243
GETIMPORT R20 22 [assert]
CALL R20 1 0
  261:   local a, b, c, d, e, f, g, pos = unpack(">!4 c3 c4 c2 z i4 c5 c2 Xh Xi4", x)
L243: MOVE R20 R2
LOADK R21 K202 ['>!4 c3 c4 c2 z i4 c5 c2 Xh Xi4']
MOVE R22 R14
CALL R20 2 8
REMARK builtin assert/1
  262:   assert(a == "abc" and b == "abcd" and c == "xz" and d == "hello" and
LOADB R29 0
JUMPXEQKS R20 K141 L245 NOT ['abc']
LOADB R29 0
JUMPXEQKS R21 K154 L245 NOT ['abcd']
LOADB R29 0
JUMPXEQKS R22 K197 L245 NOT ['xz']
LOADB R29 0
JUMPXEQKS R23 K198 L245 NOT ['hello']
LOADB R29 0
JUMPXEQKN R24 K179 L245 NOT [5]
LOADB R29 0
JUMPXEQKS R25 K199 L245 NOT ['world']
LOADB R29 0
JUMPXEQKS R26 K200 L245 NOT ['xy']
  263:          e == 5 and f == "world" and g == "xy" and (pos - 1) % 4 == 0)
SUBK R31 R27 K54 [1]
MODK R30 R31 K109 [4]
JUMPXEQKN R30 K157 L244 [0]
LOADB R29 0 +1
L244: LOADB R29 1
L245: FASTCALL1 1 R29 L246
  262:   assert(a == "abc" and b == "abcd" and c == "xz" and d == "hello" and
GETIMPORT R28 22 [assert]
CALL R28 1 0
  265:   x = pack(" b b Xd b Xb x", 1, 2, 3)
L246: MOVE R28 R0
LOADK R29 K203 [' b b Xd b Xb x']
LOADN R30 1
LOADN R31 2
LOADN R32 3
CALL R28 4 1
MOVE R14 R28
REMARK builtin assert/1
  266:   assert(packsize(" b b Xd b Xb x") == 4)
MOVE R30 R1
LOADK R31 K203 [' b b Xd b Xb x']
CALL R30 1 1
JUMPXEQKN R30 K109 L247 [4]
LOADB R29 0 +1
L247: LOADB R29 1
L248: FASTCALL1 1 R29 L249
GETIMPORT R28 22 [assert]
CALL R28 1 0
REMARK builtin assert/1
  267:   assert(x == "\1\2\3\0")
L249: JUMPXEQKS R14 K204 L250 []
LOADB R29 0 +1
L250: LOADB R29 1
L251: FASTCALL1 1 R29 L252
GETIMPORT R28 22 [assert]
CALL R28 1 0
  268:   a, b, c, pos = unpack("bbXdb", x)
L252: MOVE R28 R2
LOADK R29 K205 ['bbXdb']
MOVE R30 R14
CALL R28 2 4
MOVE R20 R28
MOVE R21 R29
MOVE R22 R30
MOVE R27 R31
REMARK builtin assert/1
  269:   assert(a == 1 and b == 2 and c == 3 and pos == #x)
LOADB R29 0
JUMPXEQKN R20 K54 L254 NOT [1]
LOADB R29 0
JUMPXEQKN R21 K178 L254 NOT [2]
LOADB R29 0
JUMPXEQKN R22 K159 L254 NOT [3]
LENGTH R30 R14
JUMPIFEQ R27 R30 L253
LOADB R29 0 +1
L253: LOADB R29 1
L254: FASTCALL1 1 R29 L255
GETIMPORT R28 22 [assert]
CALL R28 1 0
REMARK builtin assert/1
  272:   assert(packsize("!8 xXi8") == 8)
L255: MOVE R30 R1
LOADK R31 K206 ['!8 xXi8']
CALL R30 1 1
JUMPXEQKN R30 K68 L256 [8]
LOADB R29 0 +1
L256: LOADB R29 1
L257: FASTCALL1 1 R29 L258
GETIMPORT R28 22 [assert]
CALL R28 1 0
  273:   local pos = unpack("!8 xXi8", "0123456701234567"); assert(pos == 9)
L258: MOVE R28 R2
LOADK R29 K206 ['!8 xXi8']
LOADK R30 K207 ['0123456701234567']
CALL R28 2 1
REMARK builtin assert/1
JUMPXEQKN R28 K208 L259 [9]
LOADB R30 0 +1
L259: LOADB R30 1
L260: FASTCALL1 1 R30 L261
GETIMPORT R29 22 [assert]
CALL R29 1 0
REMARK builtin assert/1
  274:   assert(packsize("!8 xXi2") == 2)
L261: MOVE R31 R1
LOADK R32 K209 ['!8 xXi2']
CALL R31 1 1
JUMPXEQKN R31 K178 L262 [2]
LOADB R30 0 +1
L262: LOADB R30 1
L263: FASTCALL1 1 R30 L264
GETIMPORT R29 22 [assert]
CALL R29 1 0
  275:   local pos = unpack("!8 xXi2", "0123456701234567"); assert(pos == 3)
L264: MOVE R29 R2
LOADK R30 K209 ['!8 xXi2']
LOADK R31 K207 ['0123456701234567']
CALL R29 2 1
REMARK builtin assert/1
JUMPXEQKN R29 K159 L265 [3]
LOADB R31 0 +1
L265: LOADB R31 1
L266: FASTCALL1 1 R31 L267
GETIMPORT R30 22 [assert]
CALL R30 1 0
REMARK builtin assert/1
  276:   assert(packsize("!2 xXi2") == 2)
L267: MOVE R32 R1
LOADK R33 K210 ['!2 xXi2']
CALL R32 1 1
JUMPXEQKN R32 K178 L268 [2]
LOADB R31 0 +1
L268: LOADB R31 1
L269: FASTCALL1 1 R31 L270
GETIMPORT R30 22 [assert]
CALL R30 1 0
  277:   local pos = unpack("!2 xXi2", "0123456701234567"); assert(pos == 3)
L270: MOVE R30 R2
LOADK R31 K210 ['!2 xXi2']
LOADK R32 K207 ['0123456701234567']
CALL R30 2 1
REMARK builtin assert/1
JUMPXEQKN R30 K159 L271 [3]
LOADB R32 0 +1
L271: LOADB R32 1
L272: FASTCALL1 1 R32 L273
GETIMPORT R31 22 [assert]
CALL R31 1 0
REMARK builtin assert/1
  278:   assert(packsize("!2 xXi8") == 2)
L273: MOVE R33 R1
LOADK R34 K211 ['!2 xXi8']
CALL R33 1 1
JUMPXEQKN R33 K178 L274 [2]
LOADB R32 0 +1
L274: LOADB R32 1
L275: FASTCALL1 1 R32 L276
GETIMPORT R31 22 [assert]
CALL R31 1 0
  279:   local pos = unpack("!2 xXi8", "0123456701234567"); assert(pos == 3)
L276: MOVE R31 R2
LOADK R32 K211 ['!2 xXi8']
LOADK R33 K207 ['0123456701234567']
CALL R31 2 1
REMARK builtin assert/1
JUMPXEQKN R31 K159 L277 [3]
LOADB R33 0 +1
L277: LOADB R33 1
L278: FASTCALL1 1 R33 L279
GETIMPORT R32 22 [assert]
CALL R32 1 0
REMARK builtin assert/1
  280:   assert(packsize("!16 xXi16") == 16)
L279: MOVE R34 R1
LOADK R35 K212 ['!16 xXi16']
CALL R34 1 1
JUMPXEQKN R34 K213 L280 [16]
LOADB R33 0 +1
L280: LOADB R33 1
L281: FASTCALL1 1 R33 L282
GETIMPORT R32 22 [assert]
CALL R32 1 0
  281:   local pos = unpack("!16 xXi16", "0123456701234567"); assert(pos == 17)
L282: MOVE R32 R2
LOADK R33 K212 ['!16 xXi16']
LOADK R34 K207 ['0123456701234567']
CALL R32 2 1
REMARK builtin assert/1
JUMPXEQKN R32 K214 L283 [17]
LOADB R34 0 +1
L283: LOADB R34 1
L284: FASTCALL1 1 R34 L285
GETIMPORT R33 22 [assert]
CALL R33 1 0
  283:   checkerror("invalid next option", pack, "X")
L285: GETGLOBAL R33 K33 ['checkerror']
LOADK R34 K215 ['invalid next option']
MOVE R35 R0
LOADK R36 K216 ['X']
CALL R33 3 0
  284:   checkerror("invalid next option", unpack, "XXi", "")
GETGLOBAL R33 K33 ['checkerror']
LOADK R34 K215 ['invalid next option']
MOVE R35 R2
LOADK R36 K217 ['XXi']
LOADK R37 K105 ['']
CALL R33 4 0
  285:   checkerror("invalid next option", unpack, "X i", "")
GETGLOBAL R33 K33 ['checkerror']
LOADK R34 K215 ['invalid next option']
MOVE R35 R2
LOADK R36 K218 ['X i']
LOADK R37 K105 ['']
CALL R33 4 0
  286:   checkerror("invalid next option", pack, "Xc1")
GETGLOBAL R33 K33 ['checkerror']
LOADK R34 K215 ['invalid next option']
MOVE R35 R0
LOADK R36 K219 ['Xc1']
CALL R33 3 0
  290:   local x = pack("i4i4i4i4", 1, 2, 3, 4)
MOVE R14 R0
LOADK R15 K220 ['i4i4i4i4']
LOADN R16 1
LOADN R17 2
LOADN R18 3
LOADN R19 4
CALL R14 5 1
  291:   for pos = 1, 16, 4 do
LOADN R17 1
LOADN R15 16
LOADN R16 4
FORNPREP R15 L291
  292:     local i, p = unpack("i4", x, pos)
L286: MOVE R18 R2
LOADK R19 K89 ['i4']
MOVE R20 R14
MOVE R21 R17
CALL R18 3 2
REMARK builtin assert/1
  293:     assert(i == math.floor(pos/4) + 1 and p == pos + 4)
LOADB R21 0
REMARK builtin math.floor/1
DIVK R24 R17 K109 [4]
FASTCALL1 12 R24 L287
GETIMPORT R23 223 [math.floor]
CALL R23 1 1
L287: ADDK R22 R23 K54 [1]
JUMPIFNOTEQ R18 R22 L289
ADDK R22 R17 K109 [4]
JUMPIFEQ R19 R22 L288
LOADB R21 0 +1
L288: LOADB R21 1
L289: FASTCALL1 1 R21 L290
GETIMPORT R20 22 [assert]
CALL R20 1 0
  291:   for pos = 1, 16, 4 do
L290: FORNLOOP R15 L286
  297:   for pos = 0, 12 do    -- will always round position to power of 2
L291: LOADN R17 0
LOADN R15 12
LOADN R16 1
FORNPREP R15 L297
  298:     local i, p = unpack("!4 i4", x, pos + 1)
L292: MOVE R18 R2
LOADK R19 K224 ['!4 i4']
MOVE R20 R14
ADDK R21 R17 K54 [1]
CALL R18 3 2
REMARK builtin assert/1
  299:     assert(i == math.floor((pos + 3)/4) + 1 and p == i*4 + 1)
LOADB R21 0
REMARK builtin math.floor/1
ADDK R25 R17 K159 [3]
DIVK R24 R25 K109 [4]
FASTCALL1 12 R24 L293
GETIMPORT R23 223 [math.floor]
CALL R23 1 1
L293: ADDK R22 R23 K54 [1]
JUMPIFNOTEQ R18 R22 L295
MULK R23 R18 K109 [4]
ADDK R22 R23 K54 [1]
JUMPIFEQ R19 R22 L294
LOADB R21 0 +1
L294: LOADB R21 1
L295: FASTCALL1 1 R21 L296
GETIMPORT R20 22 [assert]
CALL R20 1 0
  297:   for pos = 0, 12 do    -- will always round position to power of 2
L296: FORNLOOP R15 L292
  303:   local i, p = unpack("!4 i4", x, -4)
L297: MOVE R15 R2
LOADK R16 K224 ['!4 i4']
MOVE R17 R14
LOADN R18 -4
CALL R15 3 2
REMARK builtin assert/1
  304:   assert(i == 4 and p == 17)
LOADB R18 0
JUMPXEQKN R15 K109 L299 NOT [4]
JUMPXEQKN R16 K214 L298 [17]
LOADB R18 0 +1
L298: LOADB R18 1
L299: FASTCALL1 1 R18 L300
GETIMPORT R17 22 [assert]
CALL R17 1 0
  305:   local i, p = unpack("!4 i4", x, -7)
L300: MOVE R17 R2
LOADK R18 K224 ['!4 i4']
MOVE R19 R14
LOADN R20 -7
CALL R17 3 2
REMARK builtin assert/1
  306:   assert(i == 4 and p == 17)
LOADB R20 0
JUMPXEQKN R17 K109 L302 NOT [4]
JUMPXEQKN R18 K214 L301 [17]
LOADB R20 0 +1
L301: LOADB R20 1
L302: FASTCALL1 1 R20 L303
GETIMPORT R19 22 [assert]
CALL R19 1 0
  307:   local i, p = unpack("!4 i4", x, -#x)
L303: MOVE R19 R2
LOADK R20 K224 ['!4 i4']
MOVE R21 R14
LENGTH R23 R14
MINUS R22 R23
CALL R19 3 2
REMARK builtin assert/1
  308:   assert(i == 1 and p == 5)
LOADB R22 0
JUMPXEQKN R19 K54 L305 NOT [1]
JUMPXEQKN R20 K179 L304 [5]
LOADB R22 0 +1
L304: LOADB R22 1
L305: FASTCALL1 1 R22 L306
GETIMPORT R21 22 [assert]
CALL R21 1 0
  309:   local i, p = unpack("!4 i4", x, 0)
L306: MOVE R21 R2
LOADK R22 K224 ['!4 i4']
MOVE R23 R14
LOADN R24 0
CALL R21 3 2
REMARK builtin assert/1
  310:   assert(i == 1 and p == 5)
LOADB R24 0
JUMPXEQKN R21 K54 L308 NOT [1]
JUMPXEQKN R22 K179 L307 [5]
LOADB R24 0 +1
L307: LOADB R24 1
L308: FASTCALL1 1 R24 L309
GETIMPORT R23 22 [assert]
CALL R23 1 0
  313:   for i = 1, #x + 1 do
L309: LOADN R25 1
LENGTH R26 R14
ADDK R23 R26 K54 [1]
LOADN R24 1
FORNPREP R23 L314
REMARK builtin assert/1
  314:     assert(unpack("c0", x, i) == "")
L310: MOVE R28 R2
LOADK R29 K156 ['c0']
MOVE R30 R14
MOVE R31 R25
CALL R28 3 1
JUMPXEQKS R28 K105 L311 ['']
LOADB R27 0 +1
L311: LOADB R27 1
L312: FASTCALL1 1 R27 L313
GETIMPORT R26 22 [assert]
CALL R26 1 0
  313:   for i = 1, #x + 1 do
L313: FORNLOOP R23 L310
  316:   checkerror("out of string", unpack, "c0", x, #x + 2)
L314: GETGLOBAL R23 K33 ['checkerror']
LOADK R24 K225 ['out of string']
MOVE R25 R2
LOADK R26 K156 ['c0']
MOVE R27 R14
LENGTH R29 R14
ADDK R28 R29 K178 [2]
CALL R23 5 0
  321:   checkerror("out of limits", unpack, "i17", "")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K91 ['out of limits']
MOVE R16 R2
LOADK R17 K226 ['i17']
LOADK R18 K105 ['']
CALL R14 4 0
  322:   checkerror("out of limits", unpack, "i987654321", "")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K91 ['out of limits']
MOVE R16 R2
LOADK R17 K227 ['i987654321']
LOADK R18 K105 ['']
CALL R14 4 0
  323:   checkerror("too large", unpack, "i9876543210", "")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K111 ['too large']
MOVE R16 R2
LOADK R17 K228 ['i9876543210']
LOADK R18 K105 ['']
CALL R14 4 0
  324:   checkerror("too large", unpack, "c9876543210", "")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K111 ['too large']
MOVE R16 R2
LOADK R17 K229 ['c9876543210']
LOADK R18 K105 ['']
CALL R14 4 0
  325:   checkerror("too large", packsize, "c1" .. string.rep("0", 40))
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K111 ['too large']
MOVE R16 R1
LOADK R18 K230 ['c1']
GETIMPORT R19 49 [string.rep]
LOADK R20 K231 ['0']
LOADN R21 40
CALL R19 2 1
CONCAT R17 R18 R19
CALL R14 3 0
  326:   checkerror("missing size", unpack, "c-2", "")
GETGLOBAL R14 K33 ['checkerror']
LOADK R15 K103 ['missing size']
MOVE R16 R2
LOADK R17 K232 ['c-2']
LOADK R18 K105 ['']
CALL R14 4 0
  329: print "OK"
GETIMPORT R14 8 [print]
LOADK R15 K233 ['OK']
CALL R14 1 0
  330: 
RETURN R0 0

]====]
end