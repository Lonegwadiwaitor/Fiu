--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (eqtab):
REMARK builtin assert/1
   20:     assert(t1 ~= t2)
JUMPIFNOTEQ R0 R1 L0
LOADB R3 0 +1
L0: LOADB R3 1
L1: FASTCALL1 1 R3 L2
GETIMPORT R2 1 [assert]
CALL R2 1 0
   21: end
L2: RETURN R0 0

Function 1 (foo):
   25:   local x = coroutine.running()
GETIMPORT R1 2 [coroutine.running]
CALL R1 0 1
REMARK builtin assert/1
   26:   assert(x == f)
GETUPVAL R4 0
JUMPIFEQ R1 R4 L0
LOADB R3 0 +1
L0: LOADB R3 1
L1: FASTCALL1 1 R3 L2
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK builtin assert/1
   29:   assert(coroutine.resume(f) == false)
L2: GETIMPORT R4 6 [coroutine.resume]
GETUPVAL R5 0
CALL R4 1 1
JUMPXEQKB R4 0 L3
LOADB R3 0 +1
L3: LOADB R3 1
L4: FASTCALL1 1 R3 L5
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK builtin assert/1
   30:   assert(coroutine.status(f) == "running")
L5: GETIMPORT R4 8 [coroutine.status]
GETUPVAL R5 0
CALL R4 1 1
JUMPXEQKS R4 K1 L6 ['running']
LOADB R3 0 +1
L6: LOADB R3 1
L7: FASTCALL1 1 R3 L8
GETIMPORT R2 4 [assert]
CALL R2 1 0
REMARK allocation: table array 0
   31:   local arg = {...}
L8: NEWTABLE R2 0 0
GETVARARGS R3 -1
SETLIST R2 R3 -1 [1]
REMARK builtin assert/1+
   32:   assert(coroutine.isyieldable())
GETIMPORT R4 10 [coroutine.isyieldable]
CALL R4 0 -1
FASTCALL 1 L9
GETIMPORT R3 4 [assert]
CALL R3 -1 0
   33:   for i=1,#arg do
L9: LOADN R5 1
LENGTH R3 R2
LOADN R4 1
FORNPREP R3 L12
REMARK allocation: table array 1
   34:     x = {coroutine.yield(table.unpack(arg[i]))}
L10: NEWTABLE R6 0 1
GETIMPORT R7 12 [coroutine.yield]
REMARK builtin table.unpack/1
GETTABLE R9 R2 R5
FASTCALL1 53 R9 L11
GETIMPORT R8 15 [table.unpack]
CALL R8 1 -1
L11: CALL R7 -1 -1
SETLIST R6 R7 -1 [1]
MOVE R1 R6
   33:   for i=1,#arg do
FORNLOOP R3 L10
REMARK builtin table.unpack/1
   36:   return table.unpack(a)
L12: FASTCALL1 53 R0 L13
MOVE R4 R0
GETIMPORT R3 15 [table.unpack]
CALL R3 1 -1
L13: RETURN R3 -1

Function 2 (foo):
   60: local function foo (i) return coroutine.yield(i) end
GETIMPORT R1 2 [coroutine.yield]
MOVE R2 R0
CALL R1 1 -1
RETURN R1 -1

Function 3 (??):
   62:   for i=1,10 do
LOADN R2 1
LOADN R0 10
LOADN R1 1
FORNPREP R0 L4
REMARK builtin assert/1
   63:     assert(foo(i) == x)
L0: GETUPVAL R5 0
MOVE R6 R2
CALL R5 1 1
GETGLOBAL R6 K0 ['x']
JUMPIFEQ R5 R6 L1
LOADB R4 0 +1
L1: LOADB R4 1
L2: FASTCALL1 1 R4 L3
GETIMPORT R3 2 [assert]
CALL R3 1 0
   62:   for i=1,10 do
L3: FORNLOOP R0 L0
   65:   return 'a'
L4: LOADK R0 K3 ['a']
RETURN R0 1

Function 4 (pf):
   72:   coroutine.yield(n)
GETIMPORT R2 2 [coroutine.yield]
MOVE R3 R0
CALL R2 1 0
   73:   pf(n*i, i+1)
GETGLOBAL R2 K3 ['pf']
MUL R3 R0 R1
ADDK R4 R1 K4 [1]
CALL R2 2 0
   74: end
RETURN R0 0

Function 5 (??):
   86:     for i=2,n do coroutine.yield(i) end
LOADN R2 2
GETUPVAL R0 0
LOADN R1 1
FORNPREP R0 L1
L0: GETIMPORT R3 2 [coroutine.yield]
MOVE R4 R2
CALL R3 1 0
FORNLOOP R0 L0
   87:   end)
L1: RETURN R0 0

Function 6 (gen):
   85:   return coroutine.wrap(function ()
GETIMPORT R1 2 [coroutine.wrap]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R2 P0
CAPTURE VAL R0
CALL R1 1 -1
RETURN R1 -1

Function 7 (??):
   94:       local n = g()
L0: GETUPVAL R0 0
CALL R0 0 1
   95:       if n == nil then return end
JUMPXEQKNIL R0 L1 NOT
RETURN R0 0
REMARK builtin math.fmod/2
   96:       if math.fmod(n, p) ~= 0 then coroutine.yield(n) end
L1: GETUPVAL R3 1
FASTCALL2 13 R0 R3 L2
MOVE R2 R0
GETIMPORT R1 2 [math.fmod]
CALL R1 2 1
L2: JUMPXEQKN R1 K3 L3 [0]
GETIMPORT R1 6 [coroutine.yield]
MOVE R2 R0
CALL R1 1 0
   93:     while 1 do
L3: JUMPBACK L0
   98:   end)
RETURN R0 0

Function 8 (filter):
   92:   return coroutine.wrap(function ()
GETIMPORT R2 2 [coroutine.wrap]
REMARK allocation: closure with 2 upvalues
NEWCLOSURE R3 P0
CAPTURE VAL R1
CAPTURE VAL R0
CALL R2 1 -1
RETURN R2 -1

Function 9 (??):
REMARK builtin assert/1
  117:        assert(not pcall(table.sort,{1,2,3}, coroutine.yield))
GETIMPORT R2 1 [pcall]
GETIMPORT R3 4 [table.sort]
REMARK allocation: table array 3
NEWTABLE R4 0 3
LOADN R5 1
LOADN R6 2
LOADN R7 3
SETLIST R4 R5 3 [1]
GETIMPORT R5 7 [coroutine.yield]
CALL R2 3 1
NOT R1 R2
FASTCALL1 1 R1 L0
GETIMPORT R0 9 [assert]
CALL R0 1 0
REMARK builtin assert/1+
  118:        assert(coroutine.isyieldable())
L0: GETIMPORT R1 11 [coroutine.isyieldable]
CALL R1 0 -1
FASTCALL 1 L1
GETIMPORT R0 9 [assert]
CALL R0 -1 0
  119:        coroutine.yield(20)
L1: GETIMPORT R0 7 [coroutine.yield]
LOADN R1 20
CALL R0 1 0
  120:        return 30
LOADN R0 30
RETURN R0 1

Function 10 (f):
REMARK builtin assert/1
  129:           assert(not coroutine.isyieldable())
GETIMPORT R3 2 [coroutine.isyieldable]
CALL R3 0 1
NOT R2 R3
FASTCALL1 1 R2 L0
GETIMPORT R1 4 [assert]
CALL R1 1 0
  130:           return c .. c
L0: MOVE R2 R0
MOVE R3 R0
CONCAT R1 R2 R3
RETURN R1 1

Function 11 (??):
REMARK builtin assert/1+
  134:                assert(coroutine.isyieldable())
GETIMPORT R2 2 [coroutine.isyieldable]
CALL R2 0 -1
FASTCALL 1 L0
GETIMPORT R1 4 [assert]
CALL R1 -1 0
  135:                local s = string.gsub("a", ".", f)
L0: GETIMPORT R1 7 [string.gsub]
LOADK R2 K8 ['a']
LOADK R3 K9 ['.']
GETUPVAL R4 0
CALL R1 3 1
  136:                return s
RETURN R1 1

Function 12 (foo):
  145:   coroutine.yield(3)
GETIMPORT R0 2 [coroutine.yield]
LOADN R1 3
CALL R0 1 0
  146:   error(foo)
GETIMPORT R0 4 [error]
GETUPVAL R1 0
CALL R0 1 0
  147: end
RETURN R0 0

Function 13 (goo):
  149: function goo() foo() end
GETUPVAL R0 0
CALL R0 0 0
RETURN R0 0

Function 14 (all):
  166:   if k == 0 then coroutine.yield(a)
JUMPXEQKN R2 K0 L0 NOT [0]
GETIMPORT R3 3 [coroutine.yield]
MOVE R4 R0
CALL R3 1 0
  173: end
RETURN R0 0
  168:     for i=1,n do
L0: LOADN R5 1
MOVE R3 R1
LOADN R4 1
FORNPREP R3 L2
  169:       a[k] = i
L1: SETTABLE R5 R0 R2
  170:       all(a, n, k-1)
GETGLOBAL R6 K4 ['all']
MOVE R7 R0
MOVE R8 R1
SUBK R9 R2 K5 [1]
CALL R6 3 0
  168:     for i=1,n do
FORNLOOP R3 L1
  173: end
L2: RETURN R0 0

Function 15 (??):
  176: for t in coroutine.wrap(function () all({}, 5, 4) end) do
GETGLOBAL R0 K0 ['all']
REMARK allocation: table hash 0
NEWTABLE R1 0 0
LOADN R2 5
LOADN R3 4
CALL R0 3 0
RETURN R0 0

Function 16 (f):
  186:             local function f () a = a+10; return a end
GETUPVAL R1 0
ADDK R0 R1 K0 [10]
SETUPVAL R0 0
GETUPVAL R0 0
RETURN R0 1

Function 17 (??):
  185:             local a = 10
LOADN R0 10
REMARK allocation: closure with 1 upvalues
  186:             local function f () a = a+10; return a end
NEWCLOSURE R1 P0
CAPTURE REF R0
  188:               a = a+1
L0: ADDK R0 R0 K0 [1]
  189:               coroutine.yield(f)
GETIMPORT R2 3 [coroutine.yield]
MOVE R3 R1
CALL R2 1 0
  187:             while true do
JUMPBACK L0
  191:           end)
CLOSEUPVALS R0
RETURN R0 0

Function 18 (co_func):
REMARK builtin assert/1
  206:   assert(coroutine.running() == current_co)
GETIMPORT R3 2 [coroutine.running]
CALL R3 0 1
JUMPIFEQ R3 R0 L0
LOADB R2 0 +1
L0: LOADB R2 1
L1: FASTCALL1 1 R2 L2
GETIMPORT R1 4 [assert]
CALL R1 1 0
REMARK builtin assert/1
  207:   assert(coroutine.resume(current_co) == false)
L2: GETIMPORT R3 6 [coroutine.resume]
MOVE R4 R0
CALL R3 1 1
JUMPXEQKB R3 0 L3
LOADB R2 0 +1
L3: LOADB R2 1
L4: FASTCALL1 1 R2 L5
GETIMPORT R1 4 [assert]
CALL R1 1 0
  208:   coroutine.yield(10, 20)
L5: GETIMPORT R1 8 [coroutine.yield]
LOADN R2 10
LOADN R3 20
CALL R1 2 0
REMARK builtin assert/1
  209:   assert(coroutine.resume(current_co) == false)
GETIMPORT R3 6 [coroutine.resume]
MOVE R4 R0
CALL R3 1 1
JUMPXEQKB R3 0 L6
LOADB R2 0 +1
L6: LOADB R2 1
L7: FASTCALL1 1 R2 L8
GETIMPORT R1 4 [assert]
CALL R1 1 0
  210:   coroutine.yield(23)
L8: GETIMPORT R1 8 [coroutine.yield]
LOADN R2 23
CALL R1 1 0
  211:   return 10
LOADN R1 10
RETURN R1 1

Function 19 (??):
  227: co1 = coroutine.create(function () return co2() end)
GETUPVAL R0 0
CALL R0 0 -1
RETURN R0 -1

Function 20 (??):
REMARK builtin assert/1
  229:         assert(coroutine.status(co1) == 'normal')
GETIMPORT R2 2 [coroutine.status]
GETUPVAL R3 0
CALL R2 1 1
JUMPXEQKS R2 K3 L0 ['normal']
LOADB R1 0 +1
L0: LOADB R1 1
L1: FASTCALL1 1 R1 L2
GETIMPORT R0 5 [assert]
CALL R0 1 0
REMARK builtin assert/1
  230:         assert(not coroutine.resume(co1))
L2: GETIMPORT R2 7 [coroutine.resume]
GETUPVAL R3 0
CALL R2 1 1
NOT R1 R2
FASTCALL1 1 R1 L3
GETIMPORT R0 5 [assert]
CALL R0 1 0
  231:         coroutine.yield(3)
L3: GETIMPORT R0 9 [coroutine.yield]
LOADN R1 3
CALL R0 1 0
  232:       end)
RETURN R0 0

Function 21 (??):
  240:   a = function(a) coroutine.wrap(a)(a) end
GETIMPORT R1 2 [coroutine.wrap]
MOVE R2 R0
CALL R1 1 1
MOVE R2 R0
CALL R1 1 0
RETURN R0 0

Function 22 (??):
  248:             f = function () a=a+1; return a end
GETUPVAL R1 0
ADDK R0 R1 K0 [1]
SETUPVAL R0 0
GETUPVAL R0 0
RETURN R0 1

Function 23 (??):
  247:             local a = 10
LOADN R0 10
REMARK allocation: closure with 1 upvalues
  248:             f = function () a=a+1; return a end
NEWCLOSURE R1 P0
CAPTURE REF R0
SETUPVAL R1 0
  249:             error('x')
GETIMPORT R1 1 [error]
LOADK R2 K2 ['x']
CALL R1 1 0
  250:           end)
CLOSEUPVALS R0
RETURN R0 0

Function 24 (??):
  261:       local x = function () a = a+1 end
GETUPVAL R1 0
ADDK R0 R1 K0 [1]
SETUPVAL R0 0
RETURN R0 0

Function 25 (??):
  260:       local a = 10
LOADN R0 10
REMARK allocation: closure with 1 upvalues
  261:       local x = function () a = a+1 end
NEWCLOSURE R1 P0
CAPTURE REF R0
  262:       coroutine.yield()
GETIMPORT R2 2 [coroutine.yield]
CALL R2 0 0
  263:     end)
CLOSEUPVALS R0
RETURN R0 0

Function 26 (??):
  279:   local co = coroutine.create(function() coroutine.yield(table.unpack(T)) end)
GETIMPORT R0 2 [coroutine.yield]
REMARK builtin table.unpack/1
GETUPVAL R2 0
FASTCALL1 53 R2 L0
GETIMPORT R1 5 [table.unpack]
CALL R1 1 -1
L0: CALL R0 -1 0
RETURN R0 0

Function 27 (??):
  301:     local st, msg = pcall(coroutine.close, coroutine.running())
GETIMPORT R0 1 [pcall]
GETIMPORT R1 4 [coroutine.close]
GETIMPORT R2 6 [coroutine.running]
CALL R2 0 -1
CALL R0 -1 2
REMARK builtin assert/1
  302:     assert(not st and string.find(msg, "running"))
NOT R3 R0
JUMPIFNOT R3 L0
GETIMPORT R3 9 [string.find]
MOVE R4 R1
LOADK R5 K5 ['running']
CALL R3 2 1
L0: FASTCALL1 1 R3 L1
GETIMPORT R2 11 [assert]
CALL R2 1 0
  303:   end)()
L1: RETURN R0 0

Function 28 (??):
  309:       local st, msg = pcall(coroutine.close, co)
GETIMPORT R0 1 [pcall]
GETIMPORT R1 4 [coroutine.close]
GETUPVAL R2 0
CALL R0 2 2
REMARK builtin assert/1
  310:       assert(not st and string.find(msg, "normal"))
NOT R3 R0
JUMPIFNOT R3 L0
GETIMPORT R3 7 [string.find]
MOVE R4 R1
LOADK R5 K8 ['normal']
CALL R3 2 1
L0: FASTCALL1 1 R3 L1
GETIMPORT R2 10 [assert]
CALL R2 1 0
  311:     end)()
L1: RETURN R0 0

Function 29 (??):
  307:     local co = coroutine.running()
GETIMPORT R0 2 [coroutine.running]
CALL R0 0 1
  308:     coroutine.wrap(function ()
GETIMPORT R1 4 [coroutine.wrap]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R2 P0
CAPTURE VAL R0
CALL R1 1 1
  311:     end)()
CALL R1 0 0
  312:   end)()
RETURN R0 0

Function 30 (??):
  329:     f = function() return a end
GETUPVAL R0 0
RETURN R0 1

Function 31 (??):
  328:     local a = 42
LOADN R0 42
REMARK allocation: closure with 1 upvalues
  329:     f = function() return a end
NEWCLOSURE R1 P0
CAPTURE REF R0
SETUPVAL R1 0
  330:     coroutine.yield()
GETIMPORT R1 2 [coroutine.yield]
CALL R1 0 0
  331:     a = 20
LOADN R0 20
  332:   end)
CLOSEUPVALS R0
RETURN R0 0

Function 32 (f):
  341:     local function f(depth) return if depth > 0 then f(depth - 1) + depth else 0 end
LOADN R2 0
JUMPIFNOTLT R2 R0 L0
GETUPVAL R2 0
SUBK R3 R0 K0 [1]
CALL R2 1 1
ADD R1 R2 R0
RETURN R1 1
L0: LOADN R1 0
RETURN R1 1

Function 33 (??):
  341:     local function f(depth) return if depth > 0 then f(depth - 1) + depth else 0 end
DUPCLOSURE R0 K0 ['f']
CAPTURE VAL R0
  342:     coroutine.yield(f(100))
GETIMPORT R1 3 [coroutine.yield]
MOVE R2 R0
LOADN R3 100
CALL R2 1 -1
CALL R1 -1 0
  343:   end)
RETURN R0 0

Function 34 (??):
    3: print "testing coroutines"
GETIMPORT R0 1 [print]
LOADK R1 K2 ['testing coroutines']
CALL R0 1 0
    5: local f
LOADNIL R0
REMARK builtin assert/1+
    8: assert(coroutine.isyieldable()) -- note: we run this in context of a yieldable thread like all other Lua code
GETIMPORT R2 5 [coroutine.isyieldable]
CALL R2 0 -1
FASTCALL 1 L0
GETIMPORT R1 7 [assert]
CALL R1 -1 0
REMARK builtin assert/1
   13: assert(not pcall(coroutine.resume, 0))
L0: GETIMPORT R3 9 [pcall]
GETIMPORT R4 11 [coroutine.resume]
LOADN R5 0
CALL R3 2 1
NOT R2 R3
FASTCALL1 1 R2 L1
GETIMPORT R1 7 [assert]
CALL R1 1 0
REMARK builtin assert/1
   14: assert(not pcall(coroutine.status, 0))
L1: GETIMPORT R3 9 [pcall]
GETIMPORT R4 13 [coroutine.status]
LOADN R5 0
CALL R3 2 1
NOT R2 R3
FASTCALL1 1 R2 L2
GETIMPORT R1 7 [assert]
CALL R1 1 0
   19: local function eqtab (t1, t2)
L2: DUPCLOSURE R1 K14 ['eqtab']
   23: x = nil   -- declare x
LOADNIL R2
SETGLOBAL R2 K15 ['x']
REMARK allocation: closure with 1 upvalues
   24: function foo (a, ...)
NEWCLOSURE R2 P1
CAPTURE REF R0
SETGLOBAL R2 K16 ['foo']
   39: f = coroutine.create(foo)
GETIMPORT R2 18 [coroutine.create]
GETGLOBAL R3 K16 ['foo']
CALL R2 1 1
MOVE R0 R2
REMARK builtin assert/1
   40: assert(type(f) == "thread" and coroutine.status(f) == "suspended")
LOADB R3 0
REMARK builtin type/1
FASTCALL1 40 R0 L3
MOVE R5 R0
GETIMPORT R4 20 [type]
CALL R4 1 1
L3: JUMPXEQKS R4 K21 L5 NOT ['thread']
GETIMPORT R4 13 [coroutine.status]
MOVE R5 R0
CALL R4 1 1
JUMPXEQKS R4 K22 L4 ['suspended']
LOADB R3 0 +1
L4: LOADB R3 1
L5: FASTCALL1 1 R3 L6
GETIMPORT R2 7 [assert]
CALL R2 1 0
REMARK builtin assert/1+
   41: assert(string.find(tostring(f), "thread"))
L6: GETIMPORT R3 25 [string.find]
REMARK builtin tostring/1
FASTCALL1 63 R0 L7
MOVE R5 R0
GETIMPORT R4 27 [tostring]
CALL R4 1 1
L7: LOADK R5 K21 ['thread']
CALL R3 2 -1
FASTCALL 1 L8
GETIMPORT R2 7 [assert]
CALL R2 -1 0
   42: local s,a,b,c,d
L8: LOADNIL R2
LOADNIL R3
LOADNIL R4
LOADNIL R5
LOADNIL R6
   43: s,a,b,c,d = coroutine.resume(f, {1,2,3}, {}, {1}, {'a', 'b', 'c'})
GETIMPORT R7 11 [coroutine.resume]
MOVE R8 R0
REMARK allocation: table array 3
NEWTABLE R9 0 3
LOADN R10 1
LOADN R11 2
LOADN R12 3
SETLIST R9 R10 3 [1]
REMARK allocation: table hash 0
NEWTABLE R10 0 0
REMARK allocation: table array 1
NEWTABLE R11 0 1
LOADN R12 1
SETLIST R11 R12 1 [1]
REMARK allocation: table array 3
NEWTABLE R12 0 3
LOADK R13 K28 ['a']
LOADK R14 K29 ['b']
LOADK R15 K30 ['c']
SETLIST R12 R13 3 [1]
CALL R7 5 5
MOVE R2 R7
MOVE R3 R8
MOVE R4 R9
MOVE R5 R10
MOVE R6 R11
REMARK builtin assert/1
   44: assert(s and a == nil and coroutine.status(f) == "suspended")
MOVE R8 R2
JUMPIFNOT R8 L10
LOADB R8 0
JUMPXEQKNIL R3 L10 NOT
GETIMPORT R9 13 [coroutine.status]
MOVE R10 R0
CALL R9 1 1
JUMPXEQKS R9 K22 L9 ['suspended']
LOADB R8 0 +1
L9: LOADB R8 1
L10: FASTCALL1 1 R8 L11
GETIMPORT R7 7 [assert]
CALL R7 1 0
   45: s,a,b,c,d = coroutine.resume(f)
L11: GETIMPORT R7 11 [coroutine.resume]
MOVE R8 R0
CALL R7 1 5
MOVE R2 R7
MOVE R3 R8
MOVE R4 R9
MOVE R5 R10
MOVE R6 R11
   46: eqtab(x, {})
MOVE R7 R1
GETGLOBAL R8 K15 ['x']
REMARK allocation: table hash 0
NEWTABLE R9 0 0
CALL R7 2 0
REMARK builtin assert/1
   47: assert(s and a == 1 and b == nil)
MOVE R8 R2
JUMPIFNOT R8 L13
LOADB R8 0
JUMPXEQKN R3 K31 L13 NOT [1]
JUMPXEQKNIL R4 L12
LOADB R8 0 +1
L12: LOADB R8 1
L13: FASTCALL1 1 R8 L14
GETIMPORT R7 7 [assert]
CALL R7 1 0
   48: s,a,b,c,d = coroutine.resume(f, 1, 2, 3)
L14: GETIMPORT R7 11 [coroutine.resume]
MOVE R8 R0
LOADN R9 1
LOADN R10 2
LOADN R11 3
CALL R7 4 5
MOVE R2 R7
MOVE R3 R8
MOVE R4 R9
MOVE R5 R10
MOVE R6 R11
   49: eqtab(x, {1, 2, 3})
MOVE R7 R1
GETGLOBAL R8 K15 ['x']
REMARK allocation: table array 3
NEWTABLE R9 0 3
LOADN R10 1
LOADN R11 2
LOADN R12 3
SETLIST R9 R10 3 [1]
CALL R7 2 0
REMARK builtin assert/1
   50: assert(s and a == 'a' and b == 'b' and c == 'c' and d == nil)
MOVE R8 R2
JUMPIFNOT R8 L16
LOADB R8 0
JUMPXEQKS R3 K28 L16 NOT ['a']
LOADB R8 0
JUMPXEQKS R4 K29 L16 NOT ['b']
LOADB R8 0
JUMPXEQKS R5 K30 L16 NOT ['c']
JUMPXEQKNIL R6 L15
LOADB R8 0 +1
L15: LOADB R8 1
L16: FASTCALL1 1 R8 L17
GETIMPORT R7 7 [assert]
CALL R7 1 0
   51: s,a,b,c,d = coroutine.resume(f, "xuxu")
L17: GETIMPORT R7 11 [coroutine.resume]
MOVE R8 R0
LOADK R9 K32 ['xuxu']
CALL R7 2 5
MOVE R2 R7
MOVE R3 R8
MOVE R4 R9
MOVE R5 R10
MOVE R6 R11
   52: eqtab(x, {"xuxu"})
MOVE R7 R1
GETGLOBAL R8 K15 ['x']
REMARK allocation: table array 1
NEWTABLE R9 0 1
LOADK R10 K32 ['xuxu']
SETLIST R9 R10 1 [1]
CALL R7 2 0
REMARK builtin assert/1
   53: assert(s and a == 1 and b == 2 and c == 3 and d == nil)
MOVE R8 R2
JUMPIFNOT R8 L19
LOADB R8 0
JUMPXEQKN R3 K31 L19 NOT [1]
LOADB R8 0
JUMPXEQKN R4 K33 L19 NOT [2]
LOADB R8 0
JUMPXEQKN R5 K34 L19 NOT [3]
JUMPXEQKNIL R6 L18
LOADB R8 0 +1
L18: LOADB R8 1
L19: FASTCALL1 1 R8 L20
GETIMPORT R7 7 [assert]
CALL R7 1 0
REMARK builtin assert/1
   54: assert(coroutine.status(f) == "dead")
L20: GETIMPORT R9 13 [coroutine.status]
MOVE R10 R0
CALL R9 1 1
JUMPXEQKS R9 K35 L21 ['dead']
LOADB R8 0 +1
L21: LOADB R8 1
L22: FASTCALL1 1 R8 L23
GETIMPORT R7 7 [assert]
CALL R7 1 0
   55: s, a = coroutine.resume(f, "xuxu")
L23: GETIMPORT R7 11 [coroutine.resume]
MOVE R8 R0
LOADK R9 K32 ['xuxu']
CALL R7 2 2
MOVE R2 R7
MOVE R3 R8
REMARK builtin assert/1
   56: assert(not s and string.find(a, "dead") and coroutine.status(f) == "dead")
NOT R8 R2
JUMPIFNOT R8 L25
GETIMPORT R8 25 [string.find]
MOVE R9 R3
LOADK R10 K35 ['dead']
CALL R8 2 1
JUMPIFNOT R8 L25
GETIMPORT R9 13 [coroutine.status]
MOVE R10 R0
CALL R9 1 1
JUMPXEQKS R9 K35 L24 ['dead']
LOADB R8 0 +1
L24: LOADB R8 1
L25: FASTCALL1 1 R8 L26
GETIMPORT R7 7 [assert]
CALL R7 1 0
   60: local function foo (i) return coroutine.yield(i) end
L26: DUPCLOSURE R7 K36 ['foo']
   61: f = coroutine.wrap(function ()
GETIMPORT R8 38 [coroutine.wrap]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R9 P3
CAPTURE REF R7
CALL R8 1 1
MOVE R0 R8
   67: for i=1,10 do x = i; assert(f(i) == i) end
LOADN R10 1
LOADN R8 10
LOADN R9 1
FORNPREP R8 L31
L27: SETGLOBAL R10 K15 ['x']
REMARK builtin assert/1
MOVE R13 R0
MOVE R14 R10
CALL R13 1 1
JUMPIFEQ R13 R10 L28
LOADB R12 0 +1
L28: LOADB R12 1
L29: FASTCALL1 1 R12 L30
GETIMPORT R11 7 [assert]
CALL R11 1 0
L30: FORNLOOP R8 L27
   68: x = 'xuxu'; assert(f('xuxu') == 'a')
L31: LOADK R8 K32 ['xuxu']
SETGLOBAL R8 K15 ['x']
REMARK builtin assert/1
MOVE R10 R0
LOADK R11 K32 ['xuxu']
CALL R10 1 1
JUMPXEQKS R10 K28 L32 ['a']
LOADB R9 0 +1
L32: LOADB R9 1
L33: FASTCALL1 1 R9 L34
GETIMPORT R8 7 [assert]
CALL R8 1 0
   71: function pf (n, i)
L34: DUPCLOSURE R8 K39 ['pf']
SETGLOBAL R8 K40 ['pf']
   76: f = coroutine.wrap(pf)
GETIMPORT R8 38 [coroutine.wrap]
GETGLOBAL R9 K40 ['pf']
CALL R8 1 1
MOVE R0 R8
   77: local s=1
LOADN R8 1
   78: for i=1,10 do
LOADN R11 1
LOADN R9 10
LOADN R10 1
FORNPREP R9 L39
REMARK builtin assert/1
   79:   assert(f(1, 1) == s)
L35: MOVE R14 R0
LOADN R15 1
LOADN R16 1
CALL R14 2 1
JUMPIFEQ R14 R8 L36
LOADB R13 0 +1
L36: LOADB R13 1
L37: FASTCALL1 1 R13 L38
GETIMPORT R12 7 [assert]
CALL R12 1 0
   80:   s = s*i
L38: MUL R8 R8 R11
   78: for i=1,10 do
FORNLOOP R9 L35
   84: function gen (n)
L39: DUPCLOSURE R9 K41 ['gen']
SETGLOBAL R9 K42 ['gen']
   91: function filter (p, g)
DUPCLOSURE R9 K43 ['filter']
SETGLOBAL R9 K44 ['filter']
  101: local x = gen(80)
GETGLOBAL R9 K42 ['gen']
LOADN R10 80
CALL R9 1 1
REMARK allocation: table hash 0
  102: local a = {}
NEWTABLE R10 0 0
  104:   local n = x()
L40: MOVE R11 R9
CALL R11 0 1
  105:   if n == nil then break end
JUMPXEQKNIL R11 L42
REMARK builtin table.insert/2
  106:   table.insert(a, n)
FASTCALL2 52 R10 R11 L41
MOVE R13 R10
MOVE R14 R11
GETIMPORT R12 47 [table.insert]
CALL R12 2 0
  107:   x = filter(n, x)
L41: GETGLOBAL R12 K44 ['filter']
MOVE R13 R11
MOVE R14 R9
CALL R12 2 1
MOVE R9 R12
  103: while 1 do
JUMPBACK L40
REMARK builtin assert/1
  110: assert(#a == 22 and a[#a] == 79)
L42: LOADB R12 0
LENGTH R13 R10
JUMPXEQKN R13 K48 L44 NOT [22]
LENGTH R14 R10
GETTABLE R13 R10 R14
JUMPXEQKN R13 K49 L43 [79]
LOADB R12 0 +1
L43: LOADB R12 1
L44: FASTCALL1 1 R12 L45
GETIMPORT R11 7 [assert]
CALL R11 1 0
  111: x, a = nil
L45: LOADNIL R11
LOADNIL R12
MOVE R9 R11
MOVE R10 R12
  116: co = coroutine.wrap(function()
GETIMPORT R11 38 [coroutine.wrap]
DUPCLOSURE R12 K50 []
CALL R11 1 1
SETGLOBAL R11 K51 ['co']
REMARK builtin assert/1
  123: assert(co() == 20)
GETGLOBAL R13 K51 ['co']
CALL R13 0 1
JUMPXEQKN R13 K52 L46 [20]
LOADB R12 0 +1
L46: LOADB R12 1
L47: FASTCALL1 1 R12 L48
GETIMPORT R11 7 [assert]
CALL R11 1 0
REMARK builtin assert/1
  124: assert(co() == 30)
L48: GETGLOBAL R13 K51 ['co']
CALL R13 0 1
JUMPXEQKN R13 K53 L49 [30]
LOADB R12 0 +1
L49: LOADB R12 1
L50: FASTCALL1 1 R12 L51
GETIMPORT R11 7 [assert]
CALL R11 1 0
  128:   local function f (c)
L51: DUPCLOSURE R11 K54 ['f']
  133:   local co = coroutine.wrap(function (c)
GETIMPORT R12 38 [coroutine.wrap]
DUPCLOSURE R13 K55 []
CAPTURE VAL R11
CALL R12 1 1
REMARK builtin assert/1
  138:   assert(co() == "aa")
MOVE R15 R12
CALL R15 0 1
JUMPXEQKS R15 K56 L52 ['aa']
LOADB R14 0 +1
L52: LOADB R14 1
L53: FASTCALL1 1 R14 L54
GETIMPORT R13 7 [assert]
CALL R13 1 0
REMARK allocation: closure with 1 upvalues
  144: function foo ()
L54: NEWCLOSURE R7 P10
CAPTURE REF R7
REMARK allocation: closure with 1 upvalues
  149: function goo() foo() end
NEWCLOSURE R11 P11
CAPTURE REF R7
SETGLOBAL R11 K57 ['goo']
  150: x = coroutine.wrap(goo)
GETIMPORT R11 38 [coroutine.wrap]
GETGLOBAL R12 K57 ['goo']
CALL R11 1 1
MOVE R9 R11
REMARK builtin assert/1
  151: assert(x() == 3)
MOVE R13 R9
CALL R13 0 1
JUMPXEQKN R13 K34 L55 [3]
LOADB R12 0 +1
L55: LOADB R12 1
L56: FASTCALL1 1 R12 L57
GETIMPORT R11 7 [assert]
CALL R11 1 0
  152: local a,b = pcall(x)
L57: GETIMPORT R11 9 [pcall]
MOVE R12 R9
CALL R11 1 2
REMARK builtin assert/1
  153: assert(not a and b == foo)
NOT R14 R11
JUMPIFNOT R14 L59
JUMPIFEQ R12 R7 L58
LOADB R14 0 +1
L58: LOADB R14 1
L59: FASTCALL1 1 R14 L60
GETIMPORT R13 7 [assert]
CALL R13 1 0
  155: x = coroutine.create(goo)
L60: GETIMPORT R13 18 [coroutine.create]
GETGLOBAL R14 K57 ['goo']
CALL R13 1 1
MOVE R9 R13
  156: a,b = coroutine.resume(x)
GETIMPORT R13 11 [coroutine.resume]
MOVE R14 R9
CALL R13 1 2
MOVE R11 R13
MOVE R12 R14
REMARK builtin assert/1
  157: assert(a and b == 3)
MOVE R14 R11
JUMPIFNOT R14 L62
JUMPXEQKN R12 K34 L61 [3]
LOADB R14 0 +1
L61: LOADB R14 1
L62: FASTCALL1 1 R14 L63
GETIMPORT R13 7 [assert]
CALL R13 1 0
  158: a,b = coroutine.resume(x)
L63: GETIMPORT R13 11 [coroutine.resume]
MOVE R14 R9
CALL R13 1 2
MOVE R11 R13
MOVE R12 R14
REMARK builtin assert/1
  159: assert(not a and b == foo and coroutine.status(x) == "dead")
NOT R14 R11
JUMPIFNOT R14 L65
LOADB R14 0
JUMPIFNOTEQ R12 R7 L65
GETIMPORT R15 13 [coroutine.status]
MOVE R16 R9
CALL R15 1 1
JUMPXEQKS R15 K35 L64 ['dead']
LOADB R14 0 +1
L64: LOADB R14 1
L65: FASTCALL1 1 R14 L66
GETIMPORT R13 7 [assert]
CALL R13 1 0
  160: a,b = coroutine.resume(x)
L66: GETIMPORT R13 11 [coroutine.resume]
MOVE R14 R9
CALL R13 1 2
MOVE R11 R13
MOVE R12 R14
REMARK builtin assert/1
  161: assert(not a and string.find(b, "dead") and coroutine.status(x) == "dead")
NOT R14 R11
JUMPIFNOT R14 L68
GETIMPORT R14 25 [string.find]
MOVE R15 R12
LOADK R16 K35 ['dead']
CALL R14 2 1
JUMPIFNOT R14 L68
GETIMPORT R15 13 [coroutine.status]
MOVE R16 R9
CALL R15 1 1
JUMPXEQKS R15 K35 L67 ['dead']
LOADB R14 0 +1
L67: LOADB R14 1
L68: FASTCALL1 1 R14 L69
GETIMPORT R13 7 [assert]
CALL R13 1 0
  165: function all (a, n, k)
L69: DUPCLOSURE R13 K58 ['all']
SETGLOBAL R13 K59 ['all']
  175: local a = 0
LOADN R13 0
  176: for t in coroutine.wrap(function () all({}, 5, 4) end) do
GETIMPORT R14 38 [coroutine.wrap]
DUPCLOSURE R15 K60 []
CALL R14 1 3
FORGPREP R14 L71
  177:   a = a+1
L70: ADDK R13 R13 K31 [1]
  176: for t in coroutine.wrap(function () all({}, 5, 4) end) do
L71: FORGLOOP R14 L70 1
REMARK builtin assert/1
  179: assert(a == 5^4)
JUMPXEQKN R13 K61 L72 [625]
LOADB R15 0 +1
L72: LOADB R15 1
L73: FASTCALL1 1 R15 L74
GETIMPORT R14 7 [assert]
CALL R14 1 0
REMARK allocation: table hash 0
  183: local C = {}; setmetatable(C, {__mode = "kv"})
L74: NEWTABLE R14 0 1
REMARK builtin setmetatable/2
REMARK allocation: table template 1
DUPTABLE R17 63
LOADK R18 K64 ['kv']
SETTABLEKS R18 R17 K62 ['__mode']
FASTCALL2 61 R14 R17 L75
MOVE R16 R14
GETIMPORT R15 66 [setmetatable]
CALL R15 2 0
  184: local x = coroutine.wrap (function ()
L75: GETIMPORT R15 38 [coroutine.wrap]
DUPCLOSURE R16 K67 []
CALL R15 1 1
  193: C[1] = x;
SETTABLEN R15 R14 1
  195: local f = x()
MOVE R16 R15
CALL R16 0 1
REMARK builtin assert/1
  196: assert(f() == 21 and x()() == 32 and x() == f)
LOADB R18 0
MOVE R19 R16
CALL R19 0 1
JUMPXEQKN R19 K68 L77 NOT [21]
LOADB R18 0
MOVE R19 R15
CALL R19 0 1
CALL R19 0 1
JUMPXEQKN R19 K69 L77 NOT [32]
MOVE R19 R15
CALL R19 0 1
JUMPIFEQ R19 R16 L76
LOADB R18 0 +1
L76: LOADB R18 1
L77: FASTCALL1 1 R18 L78
GETIMPORT R17 7 [assert]
CALL R17 1 0
  197: x = nil
L78: LOADNIL R15
  198: collectgarbage()
GETIMPORT R17 71 [collectgarbage]
CALL R17 0 0
REMARK builtin assert/1
  199: assert(C[1] == undef)
GETTABLEN R19 R14 1
GETIMPORT R20 73 [undef]
JUMPIFEQ R19 R20 L79
LOADB R18 0 +1
L79: LOADB R18 1
L80: FASTCALL1 1 R18 L81
GETIMPORT R17 7 [assert]
CALL R17 1 0
REMARK builtin assert/1
  200: assert(f() == 43 and f() == 53)
L81: LOADB R18 0
MOVE R19 R16
CALL R19 0 1
JUMPXEQKN R19 K74 L83 NOT [43]
MOVE R19 R16
CALL R19 0 1
JUMPXEQKN R19 K75 L82 [53]
LOADB R18 0 +1
L82: LOADB R18 1
L83: FASTCALL1 1 R18 L84
GETIMPORT R17 7 [assert]
CALL R17 1 0
  205: function co_func (current_co)
L84: DUPCLOSURE R17 K76 ['co_func']
SETGLOBAL R17 K77 ['co_func']
  214: local co = coroutine.create(co_func)
GETIMPORT R17 18 [coroutine.create]
GETGLOBAL R18 K77 ['co_func']
CALL R17 1 1
  215: local a,b,c = coroutine.resume(co, co)
GETIMPORT R18 11 [coroutine.resume]
MOVE R19 R17
MOVE R20 R17
CALL R18 2 3
REMARK builtin assert/1
  216: assert(a == true and b == 10 and c == 20)
LOADB R22 0
JUMPXEQKB R18 1 L86 NOT
LOADB R22 0
JUMPXEQKN R19 K78 L86 NOT [10]
JUMPXEQKN R20 K52 L85 [20]
LOADB R22 0 +1
L85: LOADB R22 1
L86: FASTCALL1 1 R22 L87
GETIMPORT R21 7 [assert]
CALL R21 1 0
  217: a,b = coroutine.resume(co, co)
L87: GETIMPORT R21 11 [coroutine.resume]
MOVE R22 R17
MOVE R23 R17
CALL R21 2 2
MOVE R18 R21
MOVE R19 R22
REMARK builtin assert/1
  218: assert(a == true and b == 23)
LOADB R22 0
JUMPXEQKB R18 1 L89 NOT
JUMPXEQKN R19 K79 L88 [23]
LOADB R22 0 +1
L88: LOADB R22 1
L89: FASTCALL1 1 R22 L90
GETIMPORT R21 7 [assert]
CALL R21 1 0
  219: a,b = coroutine.resume(co, co)
L90: GETIMPORT R21 11 [coroutine.resume]
MOVE R22 R17
MOVE R23 R17
CALL R21 2 2
MOVE R18 R21
MOVE R19 R22
REMARK builtin assert/1
  220: assert(a == true and b == 10)
LOADB R22 0
JUMPXEQKB R18 1 L92 NOT
JUMPXEQKN R19 K78 L91 [10]
LOADB R22 0 +1
L91: LOADB R22 1
L92: FASTCALL1 1 R22 L93
GETIMPORT R21 7 [assert]
CALL R21 1 0
REMARK builtin assert/1
  221: assert(coroutine.resume(co, co) == false)
L93: GETIMPORT R23 11 [coroutine.resume]
MOVE R24 R17
MOVE R25 R17
CALL R23 2 1
JUMPXEQKB R23 0 L94
LOADB R22 0 +1
L94: LOADB R22 1
L95: FASTCALL1 1 R22 L96
GETIMPORT R21 7 [assert]
CALL R21 1 0
REMARK builtin assert/1
  222: assert(coroutine.resume(co, co) == false)
L96: GETIMPORT R23 11 [coroutine.resume]
MOVE R24 R17
MOVE R25 R17
CALL R23 2 1
JUMPXEQKB R23 0 L97
LOADB R22 0 +1
L97: LOADB R22 1
L98: FASTCALL1 1 R22 L99
GETIMPORT R21 7 [assert]
CALL R21 1 0
  226: local co1, co2
L99: LOADNIL R21
LOADNIL R22
  227: co1 = coroutine.create(function () return co2() end)
GETIMPORT R23 18 [coroutine.create]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R24 P16
CAPTURE REF R22
CALL R23 1 1
MOVE R21 R23
  228: co2 = coroutine.wrap(function ()
GETIMPORT R23 38 [coroutine.wrap]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R24 P17
CAPTURE REF R21
CALL R23 1 1
MOVE R22 R23
  234: a,b = coroutine.resume(co1)
GETIMPORT R23 11 [coroutine.resume]
MOVE R24 R21
CALL R23 1 2
MOVE R18 R23
MOVE R19 R24
REMARK builtin assert/1
  235: assert(a and b == 3)
MOVE R24 R18
JUMPIFNOT R24 L101
JUMPXEQKN R19 K34 L100 [3]
LOADB R24 0 +1
L100: LOADB R24 1
L101: FASTCALL1 1 R24 L102
GETIMPORT R23 7 [assert]
CALL R23 1 0
REMARK builtin assert/1
  236: assert(coroutine.status(co1) == 'dead')
L102: GETIMPORT R25 13 [coroutine.status]
MOVE R26 R21
CALL R25 1 1
JUMPXEQKS R25 K35 L103 ['dead']
LOADB R24 0 +1
L103: LOADB R24 1
L104: FASTCALL1 1 R24 L105
GETIMPORT R23 7 [assert]
CALL R23 1 0
  238: if not limitedstack then
L105: GETIMPORT R23 81 [limitedstack]
JUMPIF R23 L107
  240:   a = function(a) coroutine.wrap(a)(a) end
DUPCLOSURE R18 K82 []
REMARK builtin assert/1
  241:   assert(not pcall(a, a))
GETIMPORT R25 9 [pcall]
MOVE R26 R18
MOVE R27 R18
CALL R25 2 1
NOT R24 R25
FASTCALL1 1 R24 L106
GETIMPORT R23 7 [assert]
CALL R23 1 0
  242:   a = nil
L106: LOADNIL R18
  246: local x = coroutine.create (function ()
L107: GETIMPORT R23 18 [coroutine.create]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R24 P19
CAPTURE REF R16
CALL R23 1 1
REMARK builtin assert/1
  252: assert(not coroutine.resume(x))
GETIMPORT R26 11 [coroutine.resume]
MOVE R27 R23
CALL R26 1 1
NOT R25 R26
FASTCALL1 1 R25 L108
GETIMPORT R24 7 [assert]
CALL R24 1 0
REMARK builtin assert/1
  254: assert(not coroutine.resume(x, 1, 1, 1, 1, 1, 1, 1))
L108: GETIMPORT R26 11 [coroutine.resume]
MOVE R27 R23
LOADN R28 1
LOADN R29 1
LOADN R30 1
LOADN R31 1
LOADN R32 1
LOADN R33 1
LOADN R34 1
CALL R26 8 1
NOT R25 R26
FASTCALL1 1 R25 L109
GETIMPORT R24 7 [assert]
CALL R24 1 0
REMARK builtin assert/1
  255: assert(f() == 11)
L109: MOVE R26 R16
CALL R26 0 1
JUMPXEQKN R26 K83 L110 [11]
LOADB R25 0 +1
L110: LOADB R25 1
L111: FASTCALL1 1 R25 L112
GETIMPORT R24 7 [assert]
CALL R24 1 0
REMARK builtin assert/1
  256: assert(f() == 12)
L112: MOVE R26 R16
CALL R26 0 1
JUMPXEQKN R26 K84 L113 [12]
LOADB R25 0 +1
L113: LOADB R25 1
L114: FASTCALL1 1 R25 L115
GETIMPORT R24 7 [assert]
CALL R24 1 0
  259: _X = coroutine.wrap(function ()
L115: GETIMPORT R24 38 [coroutine.wrap]
DUPCLOSURE R25 K85 []
CALL R24 1 1
SETGLOBAL R24 K86 ['_X']
  265: _X()
GETGLOBAL R24 K86 ['_X']
CALL R24 0 0
  269: local co = coroutine.create(coroutine.yield)
GETIMPORT R24 18 [coroutine.create]
GETIMPORT R25 88 [coroutine.yield]
CALL R24 1 1
REMARK builtin assert/1
  270: assert(coroutine.status(co) == "suspended")
GETIMPORT R27 13 [coroutine.status]
MOVE R28 R24
CALL R27 1 1
JUMPXEQKS R27 K22 L116 ['suspended']
LOADB R26 0 +1
L116: LOADB R26 1
L117: FASTCALL1 1 R26 L118
GETIMPORT R25 7 [assert]
CALL R25 1 0
  271: coroutine.resume(co)
L118: GETIMPORT R25 11 [coroutine.resume]
MOVE R26 R24
CALL R25 1 0
REMARK builtin assert/1
  272: assert(coroutine.status(co) == "suspended")
GETIMPORT R27 13 [coroutine.status]
MOVE R28 R24
CALL R27 1 1
JUMPXEQKS R27 K22 L119 ['suspended']
LOADB R26 0 +1
L119: LOADB R26 1
L120: FASTCALL1 1 R26 L121
GETIMPORT R25 7 [assert]
CALL R25 1 0
  273: coroutine.resume(co)
L121: GETIMPORT R25 11 [coroutine.resume]
MOVE R26 R24
CALL R25 1 0
REMARK builtin assert/1
  274: assert(coroutine.status(co) == "dead")
GETIMPORT R27 13 [coroutine.status]
MOVE R28 R24
CALL R27 1 1
JUMPXEQKS R27 K35 L122 ['dead']
LOADB R26 0 +1
L122: LOADB R26 1
L123: FASTCALL1 1 R26 L124
GETIMPORT R25 7 [assert]
CALL R25 1 0
  277: for i=0,30 do
L124: LOADN R27 0
LOADN R25 30
LOADN R26 1
FORNPREP R25 L135
  278:   local T = table.create(i, 42)
L125: GETIMPORT R28 89 [table.create]
MOVE R29 R27
LOADN R30 42
CALL R28 2 1
  279:   local co = coroutine.create(function() coroutine.yield(table.unpack(T)) end)
GETIMPORT R29 18 [coroutine.create]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R30 P21
CAPTURE VAL R28
CALL R29 1 1
  280:   local T2 = table.pack(coroutine.resume(co))
GETIMPORT R30 91 [table.pack]
GETIMPORT R31 11 [coroutine.resume]
MOVE R32 R29
CALL R31 1 -1
CALL R30 -1 1
REMARK builtin assert/1
  281:   assert(T2[1] == true)
GETTABLEN R33 R30 1
JUMPXEQKB R33 1 L126
LOADB R32 0 +1
L126: LOADB R32 1
L127: FASTCALL1 1 R32 L128
GETIMPORT R31 7 [assert]
CALL R31 1 0
REMARK builtin assert/1
  282:   assert(1 + #T == #T2)
L128: LOADN R34 1
LENGTH R35 R28
ADD R33 R34 R35
LENGTH R34 R30
JUMPIFEQ R33 R34 L129
LOADB R32 0 +1
L129: LOADB R32 1
L130: FASTCALL1 1 R32 L131
GETIMPORT R31 7 [assert]
CALL R31 1 0
REMARK builtin assert/1
  283:   assert(#T2 == 1 or T2[#T2] == 42)
L131: LOADB R32 1
LENGTH R33 R30
JUMPXEQKN R33 K31 L133 [1]
LENGTH R34 R30
GETTABLE R33 R30 R34
JUMPXEQKN R33 K92 L132 [42]
LOADB R32 0 +1
L132: LOADB R32 1
L133: FASTCALL1 1 R32 L134
GETIMPORT R31 7 [assert]
CALL R31 1 0
  277: for i=0,30 do
L134: FORNLOOP R25 L125
  289:   local co = coroutine.create(type)
L135: GETIMPORT R25 18 [coroutine.create]
GETIMPORT R26 20 [type]
CALL R25 1 1
REMARK builtin assert/1+
  290:   assert(coroutine.resume(co, "testing 'coroutine.close'"))
GETIMPORT R27 11 [coroutine.resume]
MOVE R28 R25
LOADK R29 K93 ['testing 'coroutine.close'']
CALL R27 2 -1
FASTCALL 1 L136
GETIMPORT R26 7 [assert]
CALL R26 -1 0
REMARK builtin assert/1
  291:   assert(coroutine.status(co) == "dead")
L136: GETIMPORT R28 13 [coroutine.status]
MOVE R29 R25
CALL R28 1 1
JUMPXEQKS R28 K35 L137 ['dead']
LOADB R27 0 +1
L137: LOADB R27 1
L138: FASTCALL1 1 R27 L139
GETIMPORT R26 7 [assert]
CALL R26 1 0
  292:   local st, msg = coroutine.close(co)
L139: GETIMPORT R26 95 [coroutine.close]
MOVE R27 R25
CALL R26 1 2
REMARK builtin assert/1
  293:   assert(st and msg == nil)
MOVE R29 R26
JUMPIFNOT R29 L141
JUMPXEQKNIL R27 L140
LOADB R29 0 +1
L140: LOADB R29 1
L141: FASTCALL1 1 R29 L142
GETIMPORT R28 7 [assert]
CALL R28 1 0
  295:   st, msg = coroutine.close(co)
L142: GETIMPORT R28 95 [coroutine.close]
MOVE R29 R25
CALL R28 1 2
MOVE R26 R28
MOVE R27 R29
REMARK builtin assert/1
  296:   assert(st and msg == nil)
MOVE R29 R26
JUMPIFNOT R29 L144
JUMPXEQKNIL R27 L143
LOADB R29 0 +1
L143: LOADB R29 1
L144: FASTCALL1 1 R29 L145
GETIMPORT R28 7 [assert]
CALL R28 1 0
  300:   coroutine.wrap(function()
L145: GETIMPORT R28 38 [coroutine.wrap]
DUPCLOSURE R29 K96 []
CALL R28 1 1
  303:   end)()
CALL R28 0 0
  306:   coroutine.wrap(function()
GETIMPORT R28 38 [coroutine.wrap]
DUPCLOSURE R29 K97 []
CALL R28 1 1
  312:   end)()
CALL R28 0 0
  315:   local co = coroutine.create(error)
GETIMPORT R28 18 [coroutine.create]
GETIMPORT R29 99 [error]
CALL R28 1 1
REMARK allocation: table array 1
  316:   local obj = {42}
NEWTABLE R29 0 1
LOADN R30 42
SETLIST R29 R30 1 [1]
  317:   local st, msg = coroutine.resume(co, obj)
GETIMPORT R30 11 [coroutine.resume]
MOVE R31 R28
MOVE R32 R29
CALL R30 2 2
REMARK builtin assert/1
  318:   assert(not st and msg == obj)
NOT R33 R30
JUMPIFNOT R33 L147
JUMPIFEQ R31 R29 L146
LOADB R33 0 +1
L146: LOADB R33 1
L147: FASTCALL1 1 R33 L148
GETIMPORT R32 7 [assert]
CALL R32 1 0
  319:   st, msg = coroutine.close(co)
L148: GETIMPORT R32 95 [coroutine.close]
MOVE R33 R28
CALL R32 1 2
MOVE R30 R32
MOVE R31 R33
REMARK builtin assert/1
  320:   assert(not st and msg == obj)
NOT R33 R30
JUMPIFNOT R33 L150
JUMPIFEQ R31 R29 L149
LOADB R33 0 +1
L149: LOADB R33 1
L150: FASTCALL1 1 R33 L151
GETIMPORT R32 7 [assert]
CALL R32 1 0
  322:   st, msg = coroutine.close(co)
L151: GETIMPORT R32 95 [coroutine.close]
MOVE R33 R28
CALL R32 1 2
MOVE R30 R32
MOVE R31 R33
REMARK builtin assert/1
  323:   assert(st and msg == nil)
MOVE R33 R30
JUMPIFNOT R33 L153
JUMPXEQKNIL R31 L152
LOADB R33 0 +1
L152: LOADB R33 1
L153: FASTCALL1 1 R33 L154
GETIMPORT R32 7 [assert]
CALL R32 1 0
  326:   local f
L154: LOADNIL R32
  327:   local co = coroutine.create(function()
GETIMPORT R33 18 [coroutine.create]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R34 P24
CAPTURE REF R32
CALL R33 1 1
  333:   coroutine.resume(co)
GETIMPORT R34 11 [coroutine.resume]
MOVE R35 R33
CALL R34 1 0
REMARK builtin assert/1
  334:   assert(f() == 42)
MOVE R36 R32
CALL R36 0 1
JUMPXEQKN R36 K92 L155 [42]
LOADB R35 0 +1
L155: LOADB R35 1
L156: FASTCALL1 1 R35 L157
GETIMPORT R34 7 [assert]
CALL R34 1 0
  335:   st, msg = coroutine.close(co)
L157: GETIMPORT R34 95 [coroutine.close]
MOVE R35 R33
CALL R34 1 2
MOVE R30 R34
MOVE R31 R35
REMARK builtin assert/1
  336:   assert(st and msg == nil)
MOVE R35 R30
JUMPIFNOT R35 L159
JUMPXEQKNIL R31 L158
LOADB R35 0 +1
L158: LOADB R35 1
L159: FASTCALL1 1 R35 L160
GETIMPORT R34 7 [assert]
CALL R34 1 0
REMARK builtin assert/1
  337:   assert(f() == 42)
L160: MOVE R36 R32
CALL R36 0 1
JUMPXEQKN R36 K92 L161 [42]
LOADB R35 0 +1
L161: LOADB R35 1
L162: FASTCALL1 1 R35 L163
GETIMPORT R34 7 [assert]
CALL R34 1 0
  340:   co = coroutine.create(function()
L163: GETIMPORT R34 18 [coroutine.create]
DUPCLOSURE R35 K100 []
CALL R34 1 1
MOVE R33 R34
REMARK builtin assert/1+
  344:   assert(coroutine.resume(co))
GETIMPORT R35 11 [coroutine.resume]
MOVE R36 R33
CALL R35 1 -1
FASTCALL 1 L164
GETIMPORT R34 7 [assert]
CALL R34 -1 0
  345:   st, msg = coroutine.close(co)
L164: GETIMPORT R34 95 [coroutine.close]
MOVE R35 R33
CALL R34 1 2
MOVE R30 R34
MOVE R31 R35
REMARK builtin assert/1
  346:   assert(st and msg == nil)
MOVE R35 R30
JUMPIFNOT R35 L166
JUMPXEQKNIL R31 L165
LOADB R35 0 +1
L165: LOADB R35 1
L166: FASTCALL1 1 R35 L167
GETIMPORT R34 7 [assert]
CALL R34 1 0
L167: CLOSEUPVALS R32
  349: print 'OK'
GETIMPORT R25 1 [print]
LOADK R26 K101 ['OK']
CALL R25 1 0
  350: 
CLOSEUPVALS R0
RETURN R0 0

]====]
end