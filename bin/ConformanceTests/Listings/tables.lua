--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (log2):
REMARK builtin math.log/1
   26: local function log2 (x) return math.log(x)/l2 end
FASTCALL1 17 R0 L0
MOVE R3 R0
GETIMPORT R2 2 [math.log]
CALL R2 1 1
L0: GETUPVAL R3 0
DIV R1 R2 R3
RETURN R1 1

Function 1 (mp2):
   29:   local mp = 2^math.ceil(log2(n))
LOADN R2 2
REMARK builtin math.ceil/1+
GETUPVAL R4 0
MOVE R5 R0
CALL R4 1 -1
FASTCALL 7 L0
GETIMPORT R3 2 [math.ceil]
CALL R3 -1 1
L0: POW R1 R2 R3
REMARK builtin assert/1
   30:   assert(n == 0 or (mp/2 < n and n <= mp))
LOADB R3 1
JUMPXEQKN R0 K3 L2 [0]
LOADB R3 0
DIVK R4 R1 K4 [2]
JUMPIFNOTLT R4 R0 L2
JUMPIFLE R0 R1 L1
LOADB R3 0 +1
L1: LOADB R3 1
L2: FASTCALL1 1 R3 L3
GETIMPORT R2 6 [assert]
CALL R2 1 0
   31:   return mp
L3: RETURN R1 1

Function 2 (fb):
   35:   local r, nn = T.int2fb(n)
GETIMPORT R1 2 [T.int2fb]
MOVE R2 R0
CALL R1 1 2
REMARK builtin assert/1
   36:   assert(r < 256)
LOADN R5 256
JUMPIFLT R1 R5 L0
LOADB R4 0 +1
L0: LOADB R4 1
L1: FASTCALL1 1 R4 L2
GETIMPORT R3 4 [assert]
CALL R3 1 0
   37:   return nn
L2: RETURN R2 1

Function 3 (check):
   51:   local a, h = T.querytab(t)
GETIMPORT R3 2 [T.querytab]
MOVE R4 R0
CALL R3 1 2
   52:   if a ~= na or h ~= nh then
JUMPIFNOTEQ R3 R1 L0
JUMPIFEQ R4 R2 L1
   53:     print(na, nh, a, h)
L0: GETIMPORT R5 4 [print]
MOVE R6 R1
MOVE R7 R2
MOVE R8 R3
MOVE R9 R4
CALL R5 4 0
REMARK builtin assert/1
   54:     assert(nil)
LOADNIL R6
FASTCALL1 1 R6 L1
GETIMPORT R5 6 [assert]
CALL R5 1 0
   56: end
L1: RETURN R0 0

Function 4 (foo):
REMARK allocation: table array 0
  154:   local arg = {...}
NEWTABLE R1 0 0
GETVARARGS R2 -1
SETLIST R1 R2 -1 [1]
  155:   check(arg, n, 0)
GETUPVAL R2 0
MOVE R3 R1
MOVE R4 R0
LOADN R5 0
CALL R2 3 0
REMARK builtin assert/1
REMARK builtin select/2+
  156:   assert(select('#', ...) == n)
LOADK R5 K0 ['#']
FASTCALL1 57 R5 L0
GETIMPORT R4 2 [select]
GETVARARGS R6 -1
CALL R4 -1 1
L0: JUMPIFEQ R4 R0 L1
LOADB R3 0 +1
L1: LOADB R3 1
L2: FASTCALL1 1 R3 L3
GETIMPORT R2 4 [assert]
CALL R2 1 0
  157:   arg[n+1] = true
L3: ADDK R2 R0 K5 [1]
LOADB R3 1
SETTABLE R3 R1 R2
  158:   check(arg, mp2(n+1), 0)
GETUPVAL R2 0
MOVE R3 R1
GETUPVAL R4 1
ADDK R5 R0 K5 [1]
CALL R4 1 1
LOADN R5 0
CALL R2 3 0
  159:   arg.x = true
LOADB R2 1
SETTABLEKS R2 R1 K6 ['x']
  160:   check(arg, mp2(n+1), 1)
GETUPVAL R2 0
MOVE R3 R1
GETUPVAL R4 1
ADDK R5 R0 K5 [1]
CALL R4 1 1
LOADN R5 1
CALL R2 3 0
  161: end
RETURN R0 0

Function 5 (find):
  183:   local n,v
LOADNIL R1
LOADNIL R2
  185:     n,v = next(_G, n)
L0: GETIMPORT R3 1 [next]
GETIMPORT R4 3 [_G]
MOVE R5 R1
CALL R3 2 2
MOVE R1 R3
MOVE R2 R4
  186:     if not n then return nofind end
JUMPIF R1 L1
GETUPVAL R3 0
RETURN R3 1
REMARK builtin assert/1
  187:     assert(v ~= nil)
L1: JUMPXEQKNIL R2 L2 NOT
LOADB R4 0 +1
L2: LOADB R4 1
L3: FASTCALL1 1 R4 L4
GETIMPORT R3 5 [assert]
CALL R3 1 0
  188:     if n == name then return v end
L4: JUMPIFNOTEQ R1 R0 L5
RETURN R2 1
  184:   while 1 do
L5: JUMPBACK L0
  190: end
RETURN R0 0

Function 6 (find1):
  193:   for n,v in pairs(_G) do
GETIMPORT R1 1 [pairs]
GETIMPORT R2 3 [_G]
CALL R1 1 3
FORGPREP_NEXT R1 L1
  194:     if n==name then return v end
L0: JUMPIFNOTEQ R4 R0 L1
RETURN R5 1
  193:   for n,v in pairs(_G) do
L1: FORGLOOP R1 L0 2
  196:   return nil  -- not found
LOADNIL R1
RETURN R1 1

Function 7 (??):
  206: assert(table.foreach(a, function(i,v) if i=='x' then return v end end) == 90)
JUMPXEQKS R0 K0 L0 NOT ['x']
RETURN R1 1
L0: RETURN R0 0

Function 8 (??):
  207: assert(table.foreach(a, function(i,v) if i=='a' then return v end end) == nil)
JUMPXEQKS R0 K0 L0 NOT ['a']
RETURN R1 1
L0: RETURN R0 0

Function 9 (??):
REMARK builtin assert/1
  213:   assert(a.n == i and not v)
LOADB R3 0
GETUPVAL R5 0
GETTABLEKS R4 R5 K0 ['n']
JUMPIFNOTEQ R4 R0 L0
NOT R3 R1
L0: FASTCALL1 1 R3 L1
GETIMPORT R2 2 [assert]
CALL R2 1 0
  214:   a.n=a.n+1
L1: GETUPVAL R2 0
GETUPVAL R5 0
GETTABLEKS R4 R5 K0 ['n']
ADDK R3 R4 K3 [1]
SETTABLEKS R3 R2 K0 ['n']
  215: end)
RETURN R0 0

Function 10 (??):
REMARK builtin assert/1
  217: table.foreachi(a, function (i,v) assert(a[i] == v) end)
GETUPVAL R5 0
GETTABLE R4 R5 R0
JUMPIFEQ R4 R1 L0
LOADB R3 0 +1
L0: LOADB R3 1
L1: FASTCALL1 1 R3 L2
GETIMPORT R2 1 [assert]
CALL R2 1 0
L2: RETURN R0 0

Function 11 (??):
  219:          if i==2 then return v end
JUMPXEQKN R0 K0 L0 NOT [2]
RETURN R1 1
  220:        end) == 'b')
L0: RETURN R0 0

Function 12 (foo):
  268:         getfenv, setfenv, assert, next
GETIMPORT R0 1 [getfenv]
GETIMPORT R1 3 [setfenv]
GETIMPORT R2 5 [assert]
GETIMPORT R3 7 [next]
REMARK allocation: table template 1
  269:   local n = {gl1=3}
DUPTABLE R4 9
LOADN R5 3
SETTABLEKS R5 R4 K8 ['gl1']
  270:   setfenv(foo, n)
MOVE R5 R1
GETUPVAL R6 0
MOVE R7 R4
CALL R5 2 0
REMARK builtin assert/1
  271:   assert(getfenv(foo) == getfenv(1))
MOVE R7 R0
GETUPVAL R8 0
CALL R7 1 1
MOVE R8 R0
LOADN R9 1
CALL R8 1 1
JUMPIFEQ R7 R8 L0
LOADB R6 0 +1
L0: LOADB R6 1
L1: FASTCALL1 1 R6 L2
MOVE R5 R2
CALL R5 1 0
REMARK builtin assert/1
  272:   assert(getfenv(foo) == n)
L2: MOVE R7 R0
GETUPVAL R8 0
CALL R7 1 1
JUMPIFEQ R7 R4 L3
LOADB R6 0 +1
L3: LOADB R6 1
L4: FASTCALL1 1 R6 L5
MOVE R5 R2
CALL R5 1 0
REMARK builtin assert/1
  273:   assert(print == nil and gl1 == 3)
L5: LOADB R6 0
GETIMPORT R7 11 [print]
JUMPXEQKNIL R7 L7 NOT
GETGLOBAL R7 K8 ['gl1']
JUMPXEQKN R7 K12 L6 [3]
LOADB R6 0 +1
L6: LOADB R6 1
L7: FASTCALL1 1 R6 L8
MOVE R5 R2
CALL R5 1 0
  274:   gl1 = nil
L8: LOADNIL R5
SETGLOBAL R5 K8 ['gl1']
  275:   gl = 1
LOADN R5 1
SETGLOBAL R5 K13 ['gl']
REMARK builtin assert/1
  276:   assert(n.gl == 1 and next(n, 'gl') == nil)
LOADB R6 0
GETTABLEKS R7 R4 K13 ['gl']
JUMPXEQKN R7 K14 L10 NOT [1]
MOVE R7 R3
MOVE R8 R4
LOADK R9 K13 ['gl']
CALL R7 2 1
JUMPXEQKNIL R7 L9
LOADB R6 0 +1
L9: LOADB R6 1
L10: FASTCALL1 1 R6 L11
MOVE R5 R2
CALL R5 1 0
  277: end
L11: RETURN R0 0

Function 13 (??):
  284:   table.foreach(a, function (k,v) b[k] = v end)
GETUPVAL R2 0
SETTABLE R1 R2 R0
RETURN R0 0

Function 14 (checknext):
REMARK allocation: table hash 0
  283:   local b = {}
NEWTABLE R1 0 0
  284:   table.foreach(a, function (k,v) b[k] = v end)
GETIMPORT R2 2 [table.foreach]
MOVE R3 R0
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R4 P0
CAPTURE REF R1
CALL R2 2 0
  285:   for k,v in pairs(b) do assert(a[k] == v) end
GETIMPORT R2 4 [pairs]
MOVE R3 R1
CALL R2 1 3
FORGPREP_NEXT R2 L3
REMARK builtin assert/1
L0: GETTABLE R9 R0 R5
JUMPIFEQ R9 R6 L1
LOADB R8 0 +1
L1: LOADB R8 1
L2: FASTCALL1 1 R8 L3
GETIMPORT R7 6 [assert]
CALL R7 1 0
L3: FORGLOOP R2 L0 2
  286:   for k,v in pairs(a) do assert(b[k] == v) end
GETIMPORT R2 4 [pairs]
MOVE R3 R0
CALL R2 1 3
FORGPREP_NEXT R2 L7
REMARK builtin assert/1
L4: GETTABLE R9 R1 R5
JUMPIFEQ R9 R6 L5
LOADB R8 0 +1
L5: LOADB R8 1
L6: FASTCALL1 1 R8 L7
GETIMPORT R7 6 [assert]
CALL R7 1 0
L7: FORGLOOP R2 L4 2
REMARK allocation: table hash 0
  287:   b = {}
NEWTABLE R1 0 0
  288:   do local k,v = next(a); while k do b[k] = v; k,v = next(a,k) end end
GETIMPORT R2 8 [next]
MOVE R3 R0
CALL R2 1 2
L8: JUMPIFNOT R2 L9
SETTABLE R3 R1 R2
GETIMPORT R4 8 [next]
MOVE R5 R0
MOVE R6 R2
CALL R4 2 2
MOVE R2 R4
MOVE R3 R5
JUMPBACK L8
  289:   for k,v in pairs(b) do assert(a[k] == v) end
L9: GETIMPORT R2 4 [pairs]
MOVE R3 R1
CALL R2 1 3
FORGPREP_NEXT R2 L13
REMARK builtin assert/1
L10: GETTABLE R9 R0 R5
JUMPIFEQ R9 R6 L11
LOADB R8 0 +1
L11: LOADB R8 1
L12: FASTCALL1 1 R8 L13
GETIMPORT R7 6 [assert]
CALL R7 1 0
L13: FORGLOOP R2 L10 2
  290:   for k,v in pairs(a) do assert(b[k] == v) end
GETIMPORT R2 4 [pairs]
MOVE R3 R0
CALL R2 1 3
FORGPREP_NEXT R2 L17
REMARK builtin assert/1
L14: GETTABLE R9 R1 R5
JUMPIFEQ R9 R6 L15
LOADB R8 0 +1
L15: LOADB R8 1
L16: FASTCALL1 1 R8 L17
GETIMPORT R7 6 [assert]
CALL R7 1 0
L17: FORGLOOP R2 L14 2
  291: end
CLOSEUPVALS R1
RETURN R0 0

Function 15 (test):
REMARK builtin table.insert/2
  340:   table.insert(a, 10); table.insert(a, 2, 20);
FASTCALL2K 52 R0 K0 L0 [10]
MOVE R2 R0
LOADK R3 K0 [10]
GETIMPORT R1 3 [table.insert]
CALL R1 2 0
REMARK builtin table.insert/3
L0: MOVE R2 R0
LOADN R3 2
LOADN R4 20
FASTCALL 52 L1
GETIMPORT R1 3 [table.insert]
CALL R1 3 0
REMARK builtin table.insert/3
  341:   table.insert(a, 1, -1); table.insert(a, 40);
L1: MOVE R2 R0
LOADN R3 1
LOADN R4 -1
FASTCALL 52 L2
GETIMPORT R1 3 [table.insert]
CALL R1 3 0
REMARK builtin table.insert/2
L2: FASTCALL2K 52 R0 K4 L3 [40]
MOVE R2 R0
LOADK R3 K4 [40]
GETIMPORT R1 3 [table.insert]
CALL R1 2 0
REMARK builtin table.insert/3
  342:   table.insert(a, table.getn(a)+1, 50)
L3: MOVE R2 R0
GETIMPORT R4 7 [table.getn]
MOVE R5 R0
CALL R4 1 1
ADDK R3 R4 K5 [1]
LOADN R4 50
FASTCALL 52 L4
GETIMPORT R1 3 [table.insert]
CALL R1 3 0
REMARK builtin table.insert/3
  343:   table.insert(a, 2, -2)
L4: MOVE R2 R0
LOADN R3 2
LOADN R4 -2
FASTCALL 52 L5
GETIMPORT R1 3 [table.insert]
CALL R1 3 0
REMARK builtin assert/1
  344:   assert(table.remove(a,1) == -1)
L5: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKN R3 K10 L6 [-1]
LOADB R2 0 +1
L6: LOADB R2 1
L7: FASTCALL1 1 R2 L8
GETIMPORT R1 12 [assert]
CALL R1 1 0
REMARK builtin assert/1
  345:   assert(table.remove(a,1) == -2)
L8: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKN R3 K13 L9 [-2]
LOADB R2 0 +1
L9: LOADB R2 1
L10: FASTCALL1 1 R2 L11
GETIMPORT R1 12 [assert]
CALL R1 1 0
REMARK builtin assert/1
  346:   assert(table.remove(a,1) == 10)
L11: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKN R3 K0 L12 [10]
LOADB R2 0 +1
L12: LOADB R2 1
L13: FASTCALL1 1 R2 L14
GETIMPORT R1 12 [assert]
CALL R1 1 0
REMARK builtin assert/1
  347:   assert(table.remove(a,1) == 20)
L14: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKN R3 K14 L15 [20]
LOADB R2 0 +1
L15: LOADB R2 1
L16: FASTCALL1 1 R2 L17
GETIMPORT R1 12 [assert]
CALL R1 1 0
REMARK builtin assert/1
  348:   assert(table.remove(a,1) == 40)
L17: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKN R3 K4 L18 [40]
LOADB R2 0 +1
L18: LOADB R2 1
L19: FASTCALL1 1 R2 L20
GETIMPORT R1 12 [assert]
CALL R1 1 0
REMARK builtin assert/1
  349:   assert(table.remove(a,1) == 50)
L20: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKN R3 K15 L21 [50]
LOADB R2 0 +1
L21: LOADB R2 1
L22: FASTCALL1 1 R2 L23
GETIMPORT R1 12 [assert]
CALL R1 1 0
REMARK builtin assert/1
  350:   assert(table.remove(a,1) == nil)
L23: GETIMPORT R3 9 [table.remove]
MOVE R4 R0
LOADN R5 1
CALL R3 2 1
JUMPXEQKNIL R3 L24
LOADB R2 0 +1
L24: LOADB R2 1
L25: FASTCALL1 1 R2 L26
GETIMPORT R1 12 [assert]
CALL R1 1 0
  351: end
L26: RETURN R0 0

Function 16 (??):
  437:   assert(not pcall(function() t.a = 3 end))
GETUPVAL R0 0
LOADN R1 3
SETTABLEKS R1 R0 K0 ['a']
RETURN R0 0

Function 17 (??):
  438:   assert(not pcall(function() t[1] = 3 end))
GETUPVAL R0 0
LOADN R1 3
SETTABLEN R1 R0 1
RETURN R0 0

Function 18 (order):
  521:     local r = ''
LOADK R1 K0 ['']
  522:     for k,v in pairs(t) do
GETIMPORT R2 2 [pairs]
MOVE R3 R0
CALL R2 1 3
FORGPREP_NEXT R2 L2
  523:       r ..= tostring(v)
L0: MOVE R7 R1
REMARK builtin tostring/1
FASTCALL1 63 R6 L1
MOVE R9 R6
GETIMPORT R8 4 [tostring]
CALL R8 1 1
L1: CONCAT R1 R7 R8
  522:     for k,v in pairs(t) do
L2: FORGLOOP R2 L0 2
  525:     return v
GETIMPORT R2 6 [v]
RETURN R2 1

Function 19 (??):
  585:     local a = table.create(7999, 0)
GETIMPORT R0 2 [table.create]
LOADN R1 7999
LOADN R2 0
CALL R0 2 1
  586:     local b = table.create(8000, 0)
GETIMPORT R1 2 [table.create]
LOADN R2 8000
LOADN R3 0
CALL R1 2 1
REMARK allocation: table array 1
  588:     local at = { table.unpack(a) }
NEWTABLE R2 0 1
REMARK builtin table.unpack/1
FASTCALL1 53 R0 L0
MOVE R4 R0
GETIMPORT R3 4 [table.unpack]
CALL R3 1 -1
L0: SETLIST R2 R3 -1 [1]
REMARK allocation: table array 1
  589:     local bt = { table.unpack(b) }
NEWTABLE R3 0 1
REMARK builtin table.unpack/1
FASTCALL1 53 R1 L1
MOVE R5 R1
GETIMPORT R4 4 [table.unpack]
CALL R4 1 -1
L1: SETLIST R3 R4 -1 [1]
  590:   end)
RETURN R0 0

Function 20 (??):
REMARK builtin assert/1
  601:     assert(k == "foo" and v == 10)
LOADB R4 0
JUMPXEQKS R1 K0 L1 NOT ['foo']
JUMPXEQKN R2 K1 L0 [10]
LOADB R4 0 +1
L0: LOADB R4 1
L1: FASTCALL1 1 R4 L2
GETIMPORT R3 3 [assert]
CALL R3 1 0
  602:     hit = true
L2: LOADB R3 1
SETUPVAL R3 0
  603:   end
RETURN R0 0

Function 21 (??):
  618:     for k, v in pairs(t) do
GETIMPORT R1 1 [pairs]
MOVE R2 R0
CALL R1 1 3
FORGPREP_NEXT R1 L12
  619:         local k1 = next(t)    -- all previous keys were deleted
L0: GETIMPORT R6 3 [next]
MOVE R7 R0
CALL R6 1 1
REMARK builtin assert/1
  620:         assert(k == k1)       -- current key is the first in the table
JUMPIFEQ R4 R6 L1
LOADB R8 0 +1
L1: LOADB R8 1
L2: FASTCALL1 1 R8 L3
GETIMPORT R7 5 [assert]
CALL R7 1 0
  621:         t[k] = nil
L3: LOADNIL R7
SETTABLE R7 R0 R4
REMARK builtin type/1
  622:         local expected = (type(k) == "table" and k[1] or
FASTCALL1 40 R4 L4
MOVE R9 R4
GETIMPORT R8 7 [type]
CALL R8 1 1
L4: JUMPXEQKS R8 K8 L5 NOT ['table']
GETTABLEN R7 R4 1
JUMPIF R7 L8
REMARK builtin type/1
  623:                           type(k) == "function" and k() or
L5: FASTCALL1 40 R4 L6
MOVE R9 R4
GETIMPORT R8 7 [type]
CALL R8 1 1
L6: JUMPXEQKS R8 K9 L7 NOT ['function']
MOVE R7 R4
CALL R7 0 1
JUMPIF R7 L8
REMARK builtin string.sub/3
  624:                           string.sub(k, 1, 1))
L7: MOVE R8 R4
LOADN R9 1
LOADN R10 1
FASTCALL 45 L8
GETIMPORT R7 12 [string.sub]
CALL R7 3 1
REMARK builtin assert/1
  625:         assert(expected == v)
L8: JUMPIFEQ R7 R5 L9
LOADB R9 0 +1
L9: LOADB R9 1
L10: FASTCALL1 1 R9 L11
GETIMPORT R8 5 [assert]
CALL R8 1 0
  626:         coroutine.yield(v)
L11: GETIMPORT R8 15 [coroutine.yield]
MOVE R9 R5
CALL R8 1 0
  618:     for k, v in pairs(t) do
L12: FORGLOOP R1 L0 2
  628:   end)
RETURN R0 0

Function 22 (??):
  636:   t[function () return 10 end] = 10
LOADN R0 10
RETURN R0 1

Function 23 (??):
  673:     t.foo = function(t, i) return -i end
MINUS R2 R1
RETURN R2 1

Function 24 (??):
    3: print('testing tables, next, and for')
GETIMPORT R0 1 [print]
LOADK R1 K2 ['testing tables, next, and for']
CALL R0 1 0
    5: local unpack = table.unpack
GETIMPORT R0 5 [table.unpack]
REMARK builtin assert/1
    8: assert(select('#', table.insert({}, 42)) == 0)
GETIMPORT R3 7 [select]
LOADK R4 K8 ['#']
REMARK builtin table.insert/2
REMARK allocation: table hash 0
NEWTABLE R6 0 0
FASTCALL2K 52 R6 K9 L0 [42]
LOADK R7 K9 [42]
GETIMPORT R5 11 [table.insert]
CALL R5 2 -1
L0: CALL R3 -1 1
JUMPXEQKN R3 K12 L1 [0]
LOADB R2 0 +1
L1: LOADB R2 1
L2: FASTCALL1 1 R2 L3
GETIMPORT R1 14 [assert]
CALL R1 1 0
REMARK allocation: table hash 0
   10: local a = {}
L3: NEWTABLE R1 0 0
   13: for i=1,100 do a[i.."+"] = true end
LOADN R4 1
LOADN R2 100
LOADN R3 1
FORNPREP R2 L5
L4: MOVE R6 R4
LOADK R7 K15 ['+']
CONCAT R5 R6 R7
LOADB R6 1
SETTABLE R6 R1 R5
FORNLOOP R2 L4
   14: for i=1,100 do a[i.."+"] = nil end
L5: LOADN R4 1
LOADN R2 100
LOADN R3 1
FORNPREP R2 L7
L6: MOVE R6 R4
LOADK R7 K15 ['+']
CONCAT R5 R6 R7
LOADNIL R6
SETTABLE R6 R1 R5
FORNLOOP R2 L6
   16: for i=1,100 do
L7: LOADN R4 1
LOADN R2 100
LOADN R3 1
FORNPREP R2 L12
   17:   a[i] = true
L8: LOADB R5 1
SETTABLE R5 R1 R4
REMARK builtin assert/1
   18:   assert(#a == i)
LENGTH R7 R1
JUMPIFEQ R7 R4 L9
LOADB R6 0 +1
L9: LOADB R6 1
L10: FASTCALL1 1 R6 L11
GETIMPORT R5 14 [assert]
CALL R5 1 0
   16: for i=1,100 do
L11: FORNLOOP R2 L8
   22: if T then
L12: GETIMPORT R2 17 [T]
JUMPIFNOT R2 L89
REMARK builtin math.log/1
   25: local l2 = math.log(2)
LOADN R3 2
FASTCALL1 17 R3 L13
GETIMPORT R2 20 [math.log]
CALL R2 1 1
REMARK allocation: closure with 1 upvalues
   26: local function log2 (x) return math.log(x)/l2 end
L13: NEWCLOSURE R3 P0
CAPTURE VAL R2
REMARK allocation: closure with 1 upvalues
   28: local function mp2 (n)   -- minimum power of 2 >= n
NEWCLOSURE R4 P1
CAPTURE VAL R3
REMARK allocation: closure with 0 upvalues
   34: local function fb (n)
NEWCLOSURE R5 P2
   41: local a = 1
LOADN R6 1
   43: while a < lim do
L14: LOADK R7 K21 [1073741824]
JUMPIFNOTLT R6 R7 L19
   44:   local n = fb(a)
MOVE R7 R5
MOVE R8 R6
CALL R7 1 1
REMARK builtin assert/1
   45:   assert(a <= n and n <= a*1.125)
LOADB R9 0
JUMPIFNOTLE R6 R7 L16
MULK R10 R6 K22 [1.125]
JUMPIFLE R7 R10 L15
LOADB R9 0 +1
L15: LOADB R9 1
L16: FASTCALL1 1 R9 L17
GETIMPORT R8 14 [assert]
CALL R8 1 0
REMARK builtin math.ceil/1
   46:   a = math.ceil(a*1.3)
L17: MULK R9 R6 K23 [1.3]
FASTCALL1 7 R9 L18
GETIMPORT R8 25 [math.ceil]
CALL R8 1 1
L18: MOVE R6 R8
   43: while a < lim do
JUMPBACK L14
REMARK allocation: closure with 0 upvalues
   50: local function check (t, na, nh)
L19: NEWCLOSURE R7 P3
   60: local s = 'return {'
LOADK R8 K26 ['return {']
   61: for i=1,lim do
LOADN R11 1
LOADN R9 40
LOADN R10 1
FORNPREP R9 L26
   62:   s = s..i..','
L20: MOVE R12 R8
MOVE R13 R11
LOADK R14 K27 [',']
CONCAT R8 R12 R14
   63:   local s = s
MOVE R12 R8
   64:   for k=0,lim do 
LOADN R15 0
LOADN R13 40
LOADN R14 1
FORNPREP R13 L25
   65:     local t = loadstring(s..'}')()
L21: GETIMPORT R16 29 [loadstring]
MOVE R18 R12
LOADK R19 K30 ['}']
CONCAT R17 R18 R19
CALL R16 1 1
CALL R16 0 1
REMARK builtin assert/1
   66:     assert(#t == i)
LENGTH R19 R16
JUMPIFEQ R19 R11 L22
LOADB R18 0 +1
L22: LOADB R18 1
L23: FASTCALL1 1 R18 L24
GETIMPORT R17 14 [assert]
CALL R17 1 0
   67:     check(t, fb(i), mp2(k))
L24: MOVE R17 R7
MOVE R18 R16
MOVE R19 R5
MOVE R20 R11
CALL R19 1 1
MOVE R20 R4
MOVE R21 R15
CALL R20 1 -1
CALL R17 -1 0
   68:     s = string.format('%sa%d=%d,', s, k, k)
GETIMPORT R17 33 [string.format]
LOADK R18 K34 ['%sa%d=%d,']
MOVE R19 R12
MOVE R20 R15
MOVE R21 R15
CALL R17 4 1
MOVE R12 R17
   64:   for k=0,lim do 
FORNLOOP R13 L21
   61: for i=1,lim do
L25: FORNLOOP R9 L20
REMARK allocation: table hash 0
   74: local a = {}
L26: NEWTABLE R9 0 0
   75: for i=1,lim do a[i] = i end   -- build auxiliary table
LOADN R12 1
LOADN R10 40
LOADN R11 1
FORNPREP R10 L28
L27: SETTABLE R12 R9 R12
FORNLOOP R10 L27
   76: for k=0,lim do
L28: LOADN R12 0
LOADN R10 40
LOADN R11 1
FORNPREP R10 L38
REMARK allocation: table array 1
   77:   local a = {unpack(a,1,k)}
L29: NEWTABLE R13 0 1
REMARK builtin table.unpack/3
MOVE R15 R9
LOADN R16 1
MOVE R17 R12
FASTCALL 53 L30
MOVE R14 R0
CALL R14 3 -1
L30: SETLIST R13 R14 -1 [1]
REMARK builtin assert/1
   78:   assert(#a == k)
LENGTH R16 R13
JUMPIFEQ R16 R12 L31
LOADB R15 0 +1
L31: LOADB R15 1
L32: FASTCALL1 1 R15 L33
GETIMPORT R14 14 [assert]
CALL R14 1 0
   79:   check(a, k, 0)
L33: MOVE R14 R7
MOVE R15 R13
MOVE R16 R12
LOADN R17 0
CALL R14 3 0
REMARK allocation: table array 4
   80:   a = {1,2,3,unpack(a,1,k)}
NEWTABLE R14 0 4
LOADN R15 1
LOADN R16 2
LOADN R17 3
REMARK builtin table.unpack/3
MOVE R19 R13
LOADN R20 1
MOVE R21 R12
FASTCALL 53 L34
MOVE R18 R0
CALL R18 3 -1
L34: SETLIST R14 R15 -1 [1]
MOVE R13 R14
   81:   check(a, k+3, 0)
MOVE R14 R7
MOVE R15 R13
ADDK R16 R12 K35 [3]
LOADN R17 0
CALL R14 3 0
REMARK builtin assert/1
   82:   assert(#a == k + 3)
LENGTH R16 R13
ADDK R17 R12 K35 [3]
JUMPIFEQ R16 R17 L35
LOADB R15 0 +1
L35: LOADB R15 1
L36: FASTCALL1 1 R15 L37
GETIMPORT R14 14 [assert]
CALL R14 1 0
   76: for k=0,lim do
L37: FORNLOOP R10 L29
   86: print'+'
L38: GETIMPORT R10 1 [print]
LOADK R11 K15 ['+']
CALL R10 1 0
   89: local lim = 130
LOADN R10 130
REMARK allocation: table hash 0
   92:   local a = {}; a[2] = 1; check(a, 0, 1)
NEWTABLE R11 0 1
LOADN R12 1
SETTABLEN R12 R11 2
MOVE R12 R7
MOVE R13 R11
LOADN R14 0
LOADN R15 1
CALL R12 3 0
REMARK allocation: table hash 0
   93:   a = {}; a[0] = 1; check(a, 0, 1); a[2] = 1; check(a, 0, 2)
NEWTABLE R11 0 0
LOADN R12 0
LOADN R13 1
SETTABLE R13 R11 R12
MOVE R12 R7
MOVE R13 R11
LOADN R14 0
LOADN R15 1
CALL R12 3 0
LOADN R12 1
SETTABLEN R12 R11 2
MOVE R12 R7
MOVE R13 R11
LOADN R14 0
LOADN R15 2
CALL R12 3 0
REMARK allocation: table hash 0
   94:   a = {}; a[0] = 1; a[1] = 1; check(a, 1, 1)
NEWTABLE R11 0 0
LOADN R12 0
LOADN R13 1
SETTABLE R13 R11 R12
LOADN R12 1
SETTABLEN R12 R11 1
MOVE R12 R7
MOVE R13 R11
LOADN R14 1
LOADN R15 1
CALL R12 3 0
REMARK allocation: table hash 0
   95:   a = {}
NEWTABLE R11 0 0
   96:   for i = 1,lim do
LOADN R14 1
MOVE R12 R10
LOADN R13 1
FORNPREP R12 L43
   97:     a[i] = 1
L39: LOADN R15 1
SETTABLE R15 R11 R14
REMARK builtin assert/1
   98:     assert(#a == i)
LENGTH R17 R11
JUMPIFEQ R17 R14 L40
LOADB R16 0 +1
L40: LOADB R16 1
L41: FASTCALL1 1 R16 L42
GETIMPORT R15 14 [assert]
CALL R15 1 0
   99:     check(a, mp2(i), 0)
L42: MOVE R15 R7
MOVE R16 R11
MOVE R17 R4
MOVE R18 R14
CALL R17 1 1
LOADN R18 0
CALL R15 3 0
   96:   for i = 1,lim do
FORNLOOP R12 L39
REMARK allocation: table hash 0
  104:   local a = {}
L43: NEWTABLE R11 0 0
  105:   for i = 1,lim do
LOADN R14 1
MOVE R12 R10
LOADN R13 1
FORNPREP R12 L48
  106:     a['a'..i] = 1
L44: LOADK R16 K36 ['a']
MOVE R17 R14
CONCAT R15 R16 R17
LOADN R16 1
SETTABLE R16 R11 R15
REMARK builtin assert/1
  107:     assert(#a == 0)
LENGTH R17 R11
JUMPXEQKN R17 K12 L45 [0]
LOADB R16 0 +1
L45: LOADB R16 1
L46: FASTCALL1 1 R16 L47
GETIMPORT R15 14 [assert]
CALL R15 1 0
  108:     check(a, 0, mp2(i))
L47: MOVE R15 R7
MOVE R16 R11
LOADN R17 0
MOVE R18 R4
MOVE R19 R14
CALL R18 1 -1
CALL R15 -1 0
  105:   for i = 1,lim do
FORNLOOP R12 L44
REMARK allocation: table hash 0
  113:   local a = {}
L48: NEWTABLE R11 0 16
  114:   for i=1,16 do a[i] = i end
LOADN R14 1
LOADN R12 16
LOADN R13 1
FORNPREP R12 L50
L49: SETTABLE R14 R11 R14
FORNLOOP R12 L49
  115:   check(a, 16, 0)
L50: MOVE R12 R7
MOVE R13 R11
LOADN R14 16
LOADN R15 0
CALL R12 3 0
  116:   for i=1,11 do a[i] = nil end
LOADN R14 1
LOADN R12 11
LOADN R13 1
FORNPREP R12 L52
L51: LOADNIL R15
SETTABLE R15 R11 R14
FORNLOOP R12 L51
  117:   for i=30,40 do a[i] = nil end   -- force a rehash (?)
L52: LOADN R14 30
LOADN R12 40
LOADN R13 1
FORNPREP R12 L54
L53: LOADNIL R15
SETTABLE R15 R11 R14
FORNLOOP R12 L53
  118:   check(a, 0, 8)
L54: MOVE R12 R7
MOVE R13 R11
LOADN R14 0
LOADN R15 8
CALL R12 3 0
  119:   a[10] = 1
LOADN R12 1
SETTABLEN R12 R11 10
  120:   for i=30,40 do a[i] = nil end   -- force a rehash (?)
LOADN R14 30
LOADN R12 40
LOADN R13 1
FORNPREP R12 L56
L55: LOADNIL R15
SETTABLE R15 R11 R14
FORNLOOP R12 L55
  121:   check(a, 0, 8)
L56: MOVE R12 R7
MOVE R13 R11
LOADN R14 0
LOADN R15 8
CALL R12 3 0
  122:   for i=1,14 do a[i] = nil end
LOADN R14 1
LOADN R12 14
LOADN R13 1
FORNPREP R12 L58
L57: LOADNIL R15
SETTABLE R15 R11 R14
FORNLOOP R12 L57
  123:   for i=30,50 do a[i] = nil end   -- force a rehash (?)
L58: LOADN R14 30
LOADN R12 50
LOADN R13 1
FORNPREP R12 L60
L59: LOADNIL R15
SETTABLE R15 R11 R14
FORNLOOP R12 L59
  124:   check(a, 0, 4)
L60: MOVE R12 R7
MOVE R13 R11
LOADN R14 0
LOADN R15 4
CALL R12 3 0
REMARK allocation: table hash 1
  128:   local a = {}
NEWTABLE R11 1 0
  129:   for i = 1, 100 do a[i] = i end
LOADN R14 1
LOADN R12 100
LOADN R13 1
FORNPREP R12 L62
L61: SETTABLE R14 R11 R14
FORNLOOP R12 L61
  130:   check(a, 128, 0)
L62: MOVE R12 R7
MOVE R13 R11
LOADN R14 128
LOADN R15 0
CALL R12 3 0
  132:   for i = 5, 95 do a[i] = nil end
LOADN R14 5
LOADN R12 95
LOADN R13 1
FORNPREP R12 L64
L63: LOADNIL R15
SETTABLE R15 R11 R14
FORNLOOP R12 L63
  133:   check(a, 128, 0)
L64: MOVE R12 R7
MOVE R13 R11
LOADN R14 128
LOADN R15 0
CALL R12 3 0
  135:   a.x = 1     -- force a re-hash
LOADN R12 1
SETTABLEKS R12 R11 K37 ['x']
  136:   check(a, 4, 8)
MOVE R12 R7
MOVE R13 R11
LOADN R14 4
LOADN R15 8
CALL R12 3 0
  138:   for i = 1, 4 do assert(a[i] == i) end
LOADN R14 1
LOADN R12 4
LOADN R13 1
FORNPREP R12 L69
REMARK builtin assert/1
L65: GETTABLE R17 R11 R14
JUMPIFEQ R17 R14 L66
LOADB R16 0 +1
L66: LOADB R16 1
L67: FASTCALL1 1 R16 L68
GETIMPORT R15 14 [assert]
CALL R15 1 0
L68: FORNLOOP R12 L65
  139:   for i = 5, 95 do assert(a[i] == nil) end
L69: LOADN R14 5
LOADN R12 95
LOADN R13 1
FORNPREP R12 L74
REMARK builtin assert/1
L70: GETTABLE R17 R11 R14
JUMPXEQKNIL R17 L71
LOADB R16 0 +1
L71: LOADB R16 1
L72: FASTCALL1 1 R16 L73
GETIMPORT R15 14 [assert]
CALL R15 1 0
L73: FORNLOOP R12 L70
  140:   for i = 96, 100 do assert(a[i] == i) end
L74: LOADN R14 96
LOADN R12 100
LOADN R13 1
FORNPREP R12 L79
REMARK builtin assert/1
L75: GETTABLE R17 R11 R14
JUMPIFEQ R17 R14 L76
LOADB R16 0 +1
L76: LOADB R16 1
L77: FASTCALL1 1 R16 L78
GETIMPORT R15 14 [assert]
CALL R15 1 0
L78: FORNLOOP R12 L75
REMARK builtin assert/1
  141:   assert(a.x == 1)
L79: GETTABLEKS R14 R11 K37 ['x']
JUMPXEQKN R14 K38 L80 [1]
LOADB R13 0 +1
L80: LOADB R13 1
L81: FASTCALL1 1 R13 L82
GETIMPORT R12 14 [assert]
CALL R12 1 0
  145: for i=1,lim do
L82: LOADN R13 1
MOVE R11 R10
LOADN R12 1
FORNPREP R11 L86
REMARK allocation: table hash 0
  146:   local a = {}
L83: NEWTABLE R14 0 0
  147:   for i=i,1,-1 do a[i] = i end   -- fill in reverse
MOVE R17 R13
LOADN R15 1
LOADN R16 -1
FORNPREP R15 L85
L84: SETTABLE R17 R14 R17
FORNLOOP R15 L84
  148:   check(a, mp2(i), 0)
L85: MOVE R15 R7
MOVE R16 R14
MOVE R17 R4
MOVE R18 R13
CALL R17 1 1
LOADN R18 0
CALL R15 3 0
  145: for i=1,lim do
FORNLOOP R11 L83
  152: lim = 35
L86: LOADN R10 35
REMARK allocation: closure with 2 upvalues
  153: function foo (n, ...)
NEWCLOSURE R11 P4
CAPTURE VAL R7
CAPTURE VAL R4
SETGLOBAL R11 K39 ['foo']
REMARK allocation: table hash 0
  162: local a = {}
NEWTABLE R11 0 0
  163: for i=1,lim do a[i] = true; foo(i, unpack(a)) end
LOADN R14 1
MOVE R12 R10
LOADN R13 1
FORNPREP R12 L89
L87: LOADB R15 1
SETTABLE R15 R11 R14
GETGLOBAL R15 K39 ['foo']
MOVE R16 R14
REMARK builtin table.unpack/1
FASTCALL1 53 R11 L88
MOVE R18 R11
MOVE R17 R0
CALL R17 1 -1
L88: CALL R15 -1 0
FORNLOOP R12 L87
REMARK builtin assert/1
REMARK allocation: table hash 0
  169: assert(#{} == 0)
L89: NEWTABLE R5 0 0
LENGTH R4 R5
JUMPXEQKN R4 K12 L90 [0]
LOADB R3 0 +1
L90: LOADB R3 1
L91: FASTCALL1 1 R3 L92
GETIMPORT R2 14 [assert]
CALL R2 1 0
REMARK builtin assert/1
REMARK allocation: table array 1
  170: assert(#{nil} == 0)
L92: NEWTABLE R5 0 1
LOADNIL R6
SETLIST R5 R6 1 [1]
LENGTH R4 R5
JUMPXEQKN R4 K12 L93 [0]
LOADB R3 0 +1
L93: LOADB R3 1
L94: FASTCALL1 1 R3 L95
GETIMPORT R2 14 [assert]
CALL R2 1 0
REMARK builtin assert/1
REMARK allocation: table array 2
  171: assert(#{nil, nil} == 0)
L95: NEWTABLE R5 0 2
LOADNIL R6
LOADNIL R7
SETLIST R5 R6 2 [1]
LENGTH R4 R5
JUMPXEQKN R4 K12 L96 [0]
LOADB R3 0 +1
L96: LOADB R3 1
L97: FASTCALL1 1 R3 L98
GETIMPORT R2 14 [assert]
CALL R2 1 0
REMARK builtin assert/1
REMARK allocation: table array 3
  172: assert(#{nil, nil, nil} == 0)
L98: NEWTABLE R5 0 3
LOADNIL R6
LOADNIL R7
LOADNIL R8
SETLIST R5 R6 3 [1]
LENGTH R4 R5
JUMPXEQKN R4 K12 L99 [0]
LOADB R3 0 +1
L99: LOADB R3 1
L100: FASTCALL1 1 R3 L101
GETIMPORT R2 14 [assert]
CALL R2 1 0
REMARK builtin assert/1
REMARK allocation: table array 4
  173: assert(#{nil, nil, nil, nil} == 0)
L101: NEWTABLE R5 0 4
LOADNIL R6
LOADNIL R7
LOADNIL R8
LOADNIL R9
SETLIST R5 R6 4 [1]
LENGTH R4 R5
JUMPXEQKN R4 K12 L102 [0]
LOADB R3 0 +1
L102: LOADB R3 1
L103: FASTCALL1 1 R3 L104
GETIMPORT R2 14 [assert]
CALL R2 1 0
  174: print'+'
L104: GETIMPORT R2 1 [print]
LOADK R3 K15 ['+']
CALL R2 1 0
REMARK allocation: table hash 0
  177: local nofind = {}
NEWTABLE R2 0 0
  179: a,b,c = 1,2,3
LOADN R1 1
LOADN R3 2
LOADN R4 3
SETGLOBAL R3 K40 ['b']
SETGLOBAL R4 K41 ['c']
  180: a,b,c = nil
LOADNIL R3
LOADNIL R4
LOADNIL R5
SETGLOBAL R4 K40 ['b']
SETGLOBAL R5 K41 ['c']
MOVE R1 R3
REMARK allocation: closure with 1 upvalues
  182: local function find (name)
NEWCLOSURE R3 P5
CAPTURE VAL R2
REMARK allocation: closure with 0 upvalues
  192: local function find1 (name)
NEWCLOSURE R4 P6
  199: local _G = getfenv(0)
GETIMPORT R5 43 [getfenv]
LOADN R6 0
CALL R5 1 1
  201:   for i=1,10000 do _G[i] = i end
LOADN R8 1
LOADN R6 10000
LOADN R7 1
FORNPREP R6 L106
L105: SETTABLE R8 R5 R8
FORNLOOP R6 L105
REMARK allocation: table template 3
  205: a = {x=90, y=8, z=23}
L106: DUPTABLE R6 46
LOADN R7 90
SETTABLEKS R7 R6 K37 ['x']
LOADN R7 8
SETTABLEKS R7 R6 K44 ['y']
LOADN R7 23
SETTABLEKS R7 R6 K45 ['z']
MOVE R1 R6
REMARK builtin assert/1
  206: assert(table.foreach(a, function(i,v) if i=='x' then return v end end) == 90)
GETIMPORT R8 48 [table.foreach]
MOVE R9 R1
REMARK allocation: closure with 0 upvalues
NEWCLOSURE R10 P7
CALL R8 2 1
JUMPXEQKN R8 K49 L107 [90]
LOADB R7 0 +1
L107: LOADB R7 1
L108: FASTCALL1 1 R7 L109
GETIMPORT R6 14 [assert]
CALL R6 1 0
REMARK builtin assert/1
  207: assert(table.foreach(a, function(i,v) if i=='a' then return v end end) == nil)
L109: GETIMPORT R8 48 [table.foreach]
MOVE R9 R1
REMARK allocation: closure with 0 upvalues
NEWCLOSURE R10 P8
CALL R8 2 1
JUMPXEQKNIL R8 L110
LOADB R7 0 +1
L110: LOADB R7 1
L111: FASTCALL1 1 R7 L112
GETIMPORT R6 14 [assert]
CALL R6 1 0
  208: table.foreach({}, error)
L112: GETIMPORT R6 48 [table.foreach]
REMARK allocation: table hash 0
NEWTABLE R7 0 0
GETIMPORT R8 51 [error]
CALL R6 2 0
  210: table.foreachi({x=10, y=20}, error)
GETIMPORT R6 53 [table.foreachi]
REMARK allocation: table template 2
DUPTABLE R7 54
LOADN R8 10
SETTABLEKS R8 R7 K37 ['x']
LOADN R8 20
SETTABLEKS R8 R7 K44 ['y']
GETIMPORT R8 51 [error]
CALL R6 2 0
REMARK allocation: table template 1
  211: local a = {n = 1}
DUPTABLE R6 56
LOADN R7 1
SETTABLEKS R7 R6 K55 ['n']
  212: table.foreachi({n=3}, function (i, v)
GETIMPORT R7 53 [table.foreachi]
REMARK allocation: table template 1
DUPTABLE R8 56
LOADN R9 3
SETTABLEKS R9 R8 K55 ['n']
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R9 P9
CAPTURE REF R6
CALL R7 2 0
REMARK allocation: table array 5
  216: a = {10,20,30,nil,50}
NEWTABLE R7 0 5
LOADN R8 10
LOADN R9 20
LOADN R10 30
LOADNIL R11
LOADN R12 50
SETLIST R7 R8 5 [1]
MOVE R6 R7
  217: table.foreachi(a, function (i,v) assert(a[i] == v) end)
GETIMPORT R7 53 [table.foreachi]
MOVE R8 R6
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R9 P10
CAPTURE REF R6
CALL R7 2 0
REMARK builtin assert/1
  218: assert(table.foreachi({'a', 'b', 'c'}, function (i,v)
GETIMPORT R9 53 [table.foreachi]
REMARK allocation: table array 3
NEWTABLE R10 0 3
LOADK R11 K36 ['a']
LOADK R12 K40 ['b']
LOADK R13 K41 ['c']
SETLIST R10 R11 3 [1]
REMARK allocation: closure with 0 upvalues
NEWCLOSURE R11 P11
CALL R9 2 1
JUMPXEQKS R9 K40 L113 ['b']
LOADB R8 0 +1
L113: LOADB R8 1
L114: FASTCALL1 1 R8 L115
GETIMPORT R7 14 [assert]
CALL R7 1 0
REMARK builtin assert/1
  226: assert(nofind==find("return"))
L115: MOVE R9 R3
LOADK R10 K57 ['return']
CALL R9 1 1
JUMPIFEQ R2 R9 L116
LOADB R8 0 +1
L116: LOADB R8 1
L117: FASTCALL1 1 R8 L118
GETIMPORT R7 14 [assert]
CALL R7 1 0
REMARK builtin assert/1
  227: assert(not find1("return"))
L118: MOVE R9 R4
LOADK R10 K57 ['return']
CALL R9 1 1
NOT R8 R9
FASTCALL1 1 R8 L119
GETIMPORT R7 14 [assert]
CALL R7 1 0
  228: _G["ret" .. "urn"] = nil
L119: LOADK R8 K58 ['ret']
LOADK R9 K59 ['urn']
CONCAT R7 R8 R9
LOADNIL R8
SETTABLE R8 R5 R7
REMARK builtin assert/1
  229: assert(nofind==find("return"))
MOVE R9 R3
LOADK R10 K57 ['return']
CALL R9 1 1
JUMPIFEQ R2 R9 L120
LOADB R8 0 +1
L120: LOADB R8 1
L121: FASTCALL1 1 R8 L122
GETIMPORT R7 14 [assert]
CALL R7 1 0
  230: _G["xxx"] = 1
L122: LOADN R7 1
SETTABLEKS R7 R5 K60 ['xxx']
  232: print('+')
GETIMPORT R7 1 [print]
LOADK R8 K15 ['+']
CALL R7 1 0
REMARK allocation: table hash 0
  234: a = {}
NEWTABLE R6 0 0
  235: for i=0,10000 do
LOADN R9 0
LOADN R7 10000
LOADN R8 1
FORNPREP R7 L125
  236:   if i % 10 ~= 0 then
L123: MODK R10 R9 K61 [10]
JUMPXEQKN R10 K12 L124 [0]
  237:     a['x'..i] = i
LOADK R11 K37 ['x']
MOVE R12 R9
CONCAT R10 R11 R12
SETTABLE R9 R6 R10
  235: for i=0,10000 do
L124: FORNLOOP R7 L123
REMARK allocation: table template 1
  241: n = {n=0}
L125: DUPTABLE R7 56
LOADN R8 0
SETTABLEKS R8 R7 K55 ['n']
SETGLOBAL R7 K55 ['n']
  242: for i,v in pairs(a) do
GETIMPORT R7 63 [pairs]
MOVE R8 R6
CALL R7 1 3
FORGPREP_NEXT R7 L129
  243:   n.n = n.n+1
L126: GETGLOBAL R12 K55 ['n']
GETGLOBAL R15 K55 ['n']
GETTABLEKS R14 R15 K55 ['n']
ADDK R13 R14 K38 [1]
SETTABLEKS R13 R12 K55 ['n']
REMARK builtin assert/1
  244:   assert(i and v and a[i] == v)
MOVE R13 R10
JUMPIFNOT R13 L128
MOVE R13 R11
JUMPIFNOT R13 L128
GETTABLE R14 R6 R10
JUMPIFEQ R14 R11 L127
LOADB R13 0 +1
L127: LOADB R13 1
L128: FASTCALL1 1 R13 L129
GETIMPORT R12 14 [assert]
CALL R12 1 0
  242: for i,v in pairs(a) do
L129: FORGLOOP R7 L126 2
REMARK builtin assert/1
  246: assert(n.n == 9000)
GETGLOBAL R10 K55 ['n']
GETTABLEKS R9 R10 K55 ['n']
JUMPXEQKN R9 K64 L130 [9000]
LOADB R8 0 +1
L130: LOADB R8 1
L131: FASTCALL1 1 R8 L132
GETIMPORT R7 14 [assert]
CALL R7 1 0
  247: a = nil
L132: LOADNIL R6
  250: for i=1,10000 do _G[i] = nil end
LOADN R9 1
LOADN R7 10000
LOADN R8 1
FORNPREP R7 L134
L133: LOADNIL R10
SETTABLE R10 R5 R9
FORNLOOP R7 L133
REMARK allocation: table hash 0
  253:   local a = {}
L134: NEWTABLE R7 0 0
REMARK allocation: table template 7
  254:   local preserve = {io = 1, string = 1, debug = 1, os = 1,
DUPTABLE R8 69
LOADN R9 1
SETTABLEKS R9 R8 K65 ['io']
LOADN R9 1
SETTABLEKS R9 R8 K31 ['string']
LOADN R9 1
SETTABLEKS R9 R8 K66 ['debug']
LOADN R9 1
SETTABLEKS R9 R8 K67 ['os']
  255:                     coroutine = 1, table = 1, math = 1}
LOADN R9 1
SETTABLEKS R9 R8 K68 ['coroutine']
LOADN R9 1
SETTABLEKS R9 R8 K3 ['table']
LOADN R9 1
SETTABLEKS R9 R8 K18 ['math']
  256:   for n,v in pairs(_G) do a[n]=v end
GETIMPORT R9 63 [pairs]
MOVE R10 R5
CALL R9 1 3
FORGPREP_NEXT R9 L136
L135: SETTABLE R13 R7 R12
L136: FORGLOOP R9 L135 2
  257:   for n,v in pairs(a) do
GETIMPORT R9 63 [pairs]
MOVE R10 R7
CALL R9 1 3
FORGPREP_NEXT R9 L140
  258:     if not preserve[n] and type(v) ~= "function" and
L137: GETTABLE R14 R8 R12
JUMPIF R14 L139
REMARK builtin type/1
FASTCALL1 40 R13 L138
MOVE R15 R13
GETIMPORT R14 71 [type]
CALL R14 1 1
L138: JUMPXEQKS R14 K72 L139 ['function']
  259:        not string.find(n, "^[%u_]") then
GETIMPORT R14 74 [string.find]
MOVE R15 R12
LOADK R16 K75 ['^[%u_]']
CALL R14 2 1
JUMPIF R14 L139
  260:      _G[n] = nil
LOADNIL R14
SETTABLE R14 R5 R12
  262:     collectgarbage()
L139: GETIMPORT R14 77 [collectgarbage]
CALL R14 0 0
  257:   for n,v in pairs(a) do
L140: FORGLOOP R9 L137 2
REMARK allocation: closure with 1 upvalues
  266: local function foo ()
NEWCLOSURE R7 P12
CAPTURE VAL R7
  278: foo()
MOVE R8 R7
CALL R8 0 0
  280: print'+'
GETIMPORT R8 1 [print]
LOADK R9 K15 ['+']
CALL R8 1 0
REMARK allocation: closure with 0 upvalues
  282: local function checknext (a)
NEWCLOSURE R8 P13
  293: checknext{1,x=1,y=2,z=3}
MOVE R9 R8
REMARK allocation: table hash 3 array 1
NEWTABLE R10 4 1
LOADN R11 1
SETLIST R10 R11 1 [1]
LOADN R12 1
SETTABLEKS R12 R10 K37 ['x']
LOADN R12 2
SETTABLEKS R12 R10 K44 ['y']
LOADN R12 3
SETTABLEKS R12 R10 K45 ['z']
CALL R9 1 0
  294: checknext{1,2,x=1,y=2,z=3}
MOVE R9 R8
REMARK allocation: table hash 3 array 2
NEWTABLE R10 4 2
LOADN R11 1
LOADN R12 2
SETLIST R10 R11 2 [1]
LOADN R13 1
SETTABLEKS R13 R10 K37 ['x']
LOADN R13 2
SETTABLEKS R13 R10 K44 ['y']
LOADN R13 3
SETTABLEKS R13 R10 K45 ['z']
CALL R9 1 0
  295: checknext{1,2,3,x=1,y=2,z=3}
MOVE R9 R8
REMARK allocation: table hash 3 array 3
NEWTABLE R10 4 3
LOADN R11 1
LOADN R12 2
LOADN R13 3
SETLIST R10 R11 3 [1]
LOADN R14 1
SETTABLEKS R14 R10 K37 ['x']
LOADN R14 2
SETTABLEKS R14 R10 K44 ['y']
LOADN R14 3
SETTABLEKS R14 R10 K45 ['z']
CALL R9 1 0
  296: checknext{1,2,3,4,x=1,y=2,z=3}
MOVE R9 R8
REMARK allocation: table hash 3 array 4
NEWTABLE R10 4 4
LOADN R11 1
LOADN R12 2
LOADN R13 3
LOADN R14 4
SETLIST R10 R11 4 [1]
LOADN R15 1
SETTABLEKS R15 R10 K37 ['x']
LOADN R15 2
SETTABLEKS R15 R10 K44 ['y']
LOADN R15 3
SETTABLEKS R15 R10 K45 ['z']
CALL R9 1 0
  297: checknext{1,2,3,4,5,x=1,y=2,z=3}
MOVE R9 R8
REMARK allocation: table hash 3 array 5
NEWTABLE R10 4 5
LOADN R11 1
LOADN R12 2
LOADN R13 3
LOADN R14 4
LOADN R15 5
SETLIST R10 R11 5 [1]
LOADN R16 1
SETTABLEKS R16 R10 K37 ['x']
LOADN R16 2
SETTABLEKS R16 R10 K44 ['y']
LOADN R16 3
SETTABLEKS R16 R10 K45 ['z']
CALL R9 1 0
REMARK builtin assert/1
  299: assert(table.getn{} == 0)
GETIMPORT R11 79 [table.getn]
REMARK allocation: table hash 0
NEWTABLE R12 0 0
CALL R11 1 1
JUMPXEQKN R11 K12 L141 [0]
LOADB R10 0 +1
L141: LOADB R10 1
L142: FASTCALL1 1 R10 L143
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK builtin assert/1
  300: assert(table.getn{[-1] = 2} == 0)
L143: GETIMPORT R11 79 [table.getn]
REMARK allocation: table hash 1
NEWTABLE R12 1 0
LOADN R13 -1
LOADN R14 2
SETTABLE R14 R12 R13
CALL R11 1 1
JUMPXEQKN R11 K12 L144 [0]
LOADB R10 0 +1
L144: LOADB R10 1
L145: FASTCALL1 1 R10 L146
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK builtin assert/1
  301: assert(table.getn{1,2,3,nil,nil} == 3)
L146: GETIMPORT R11 79 [table.getn]
REMARK allocation: table array 5
NEWTABLE R12 0 5
LOADN R13 1
LOADN R14 2
LOADN R15 3
LOADNIL R16
LOADNIL R17
SETLIST R12 R13 5 [1]
CALL R11 1 1
JUMPXEQKN R11 K35 L147 [3]
LOADB R10 0 +1
L147: LOADB R10 1
L148: FASTCALL1 1 R10 L149
GETIMPORT R9 14 [assert]
CALL R9 1 0
  302: for i=0,40 do
L149: LOADN R11 0
LOADN R9 40
LOADN R10 1
FORNPREP R9 L156
REMARK allocation: table hash 0
  303:   local a = {}
L150: NEWTABLE R12 0 0
  304:   for j=1,i do a[j]=j end
LOADN R15 1
MOVE R13 R11
LOADN R14 1
FORNPREP R13 L152
L151: SETTABLE R15 R12 R15
FORNLOOP R13 L151
REMARK builtin assert/1
  305:   assert(table.getn(a) == i)
L152: GETIMPORT R15 79 [table.getn]
MOVE R16 R12
CALL R15 1 1
JUMPIFEQ R15 R11 L153
LOADB R14 0 +1
L153: LOADB R14 1
L154: FASTCALL1 1 R14 L155
GETIMPORT R13 14 [assert]
CALL R13 1 0
  302: for i=0,40 do
L155: FORNLOOP R9 L150
REMARK builtin assert/1
  309: assert(table.maxn{} == 0)
L156: GETIMPORT R11 81 [table.maxn]
REMARK allocation: table hash 0
NEWTABLE R12 0 0
CALL R11 1 1
JUMPXEQKN R11 K12 L157 [0]
LOADB R10 0 +1
L157: LOADB R10 1
L158: FASTCALL1 1 R10 L159
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK builtin assert/1
  310: assert(table.maxn{["1000"] = true} == 0)
L159: GETIMPORT R11 81 [table.maxn]
REMARK allocation: table hash 1
NEWTABLE R12 1 0
LOADB R13 1
SETTABLEKS R13 R12 K82 ['1000']
CALL R11 1 1
JUMPXEQKN R11 K12 L160 [0]
LOADB R10 0 +1
L160: LOADB R10 1
L161: FASTCALL1 1 R10 L162
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK builtin assert/1
  311: assert(table.maxn{["1000"] = true, [24.5] = 3} == 24.5)
L162: GETIMPORT R11 81 [table.maxn]
REMARK allocation: table hash 2
NEWTABLE R12 2 0
LOADB R13 1
SETTABLEKS R13 R12 K82 ['1000']
LOADK R13 K83 [24.5]
LOADN R14 3
SETTABLE R14 R12 R13
CALL R11 1 1
JUMPXEQKN R11 K83 L163 [24.5]
LOADB R10 0 +1
L163: LOADB R10 1
L164: FASTCALL1 1 R10 L165
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK builtin assert/1
  312: assert(table.maxn{[1000] = true} == 1000)
L165: GETIMPORT R11 81 [table.maxn]
REMARK allocation: table hash 1
NEWTABLE R12 1 0
LOADN R13 1000
LOADB R14 1
SETTABLE R14 R12 R13
CALL R11 1 1
JUMPXEQKN R11 K84 L166 [1000]
LOADB R10 0 +1
L166: LOADB R10 1
L167: FASTCALL1 1 R10 L168
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK builtin assert/1
  313: assert(table.maxn{[10] = true, [100*math.pi] = print} == 100*math.pi)
L168: GETIMPORT R11 81 [table.maxn]
REMARK allocation: table hash 2
NEWTABLE R12 2 0
LOADB R13 1
SETTABLEN R13 R12 10
LOADN R14 100
GETIMPORT R15 86 [math.pi]
MUL R13 R14 R15
GETIMPORT R14 1 [print]
SETTABLE R14 R12 R13
CALL R11 1 1
LOADN R13 100
GETIMPORT R14 86 [math.pi]
MUL R12 R13 R14
JUMPIFEQ R11 R12 L169
LOADB R10 0 +1
L169: LOADB R10 1
L170: FASTCALL1 1 R10 L171
GETIMPORT R9 14 [assert]
CALL R9 1 0
REMARK allocation: table hash 0
  317: a = {}
L171: NEWTABLE R6 0 0
  318: for i=0,50 do a[math.pow(2,i)] = true end
LOADN R11 0
LOADN R9 50
LOADN R10 1
FORNPREP R9 L174
REMARK builtin math.pow/2
L172: LOADN R13 2
FASTCALL2 21 R13 R11 L173
MOVE R14 R11
GETIMPORT R12 88 [math.pow]
CALL R12 2 1
L173: LOADB R13 1
SETTABLE R13 R6 R12
FORNLOOP R9 L172
REMARK builtin assert/1
  319: assert(a[table.getn(a)])
L174: GETIMPORT R11 79 [table.getn]
MOVE R12 R6
CALL R11 1 1
GETTABLE R10 R6 R11
FASTCALL1 1 R10 L175
GETIMPORT R9 14 [assert]
CALL R9 1 0
  321: print("+")
L175: GETIMPORT R9 1 [print]
LOADK R10 K15 ['+']
CALL R9 1 0
REMARK allocation: table hash 5
  325: local t = {[{1}] = 1, [{2}] = 2, [string.rep("x ", 4)] = 3,
NEWTABLE R9 8 0
REMARK allocation: table array 1
NEWTABLE R10 0 1
LOADN R11 1
SETLIST R10 R11 1 [1]
LOADN R11 1
SETTABLE R11 R9 R10
REMARK allocation: table array 1
NEWTABLE R10 0 1
LOADN R11 2
SETLIST R10 R11 1 [1]
LOADN R11 2
SETTABLE R11 R9 R10
GETIMPORT R10 90 [string.rep]
LOADK R11 K91 ['x ']
LOADN R12 4
CALL R10 2 1
LOADN R11 3
SETTABLE R11 R9 R10
  326:            [100.3] = 4, [4] = 5}
LOADK R10 K92 [100.3]
LOADN R11 4
SETTABLE R11 R9 R10
LOADN R10 5
SETTABLEN R10 R9 4
  328: local n = 0
LOADN R10 0
  329: for k, v in pairs( t ) do
GETIMPORT R11 63 [pairs]
MOVE R12 R9
CALL R11 1 3
FORGPREP_NEXT R11 L182
  330:   n = n+1
L176: ADDK R10 R10 K38 [1]
REMARK builtin assert/1
  331:   assert(t[k] == v)
GETTABLE R18 R9 R14
JUMPIFEQ R18 R15 L177
LOADB R17 0 +1
L177: LOADB R17 1
L178: FASTCALL1 1 R17 L179
GETIMPORT R16 14 [assert]
CALL R16 1 0
  332:   t[k] = nil
L179: LOADNIL R16
SETTABLE R16 R9 R14
  333:   collectgarbage()
GETIMPORT R16 77 [collectgarbage]
CALL R16 0 0
REMARK builtin assert/1
  334:   assert(t[k] == nil)
GETTABLE R18 R9 R14
JUMPXEQKNIL R18 L180
LOADB R17 0 +1
L180: LOADB R17 1
L181: FASTCALL1 1 R17 L182
GETIMPORT R16 14 [assert]
CALL R16 1 0
  329: for k, v in pairs( t ) do
L182: FORGLOOP R11 L176 2
REMARK builtin assert/1
  336: assert(n == 5)
JUMPXEQKN R10 K93 L183 [5]
LOADB R12 0 +1
L183: LOADB R12 1
L184: FASTCALL1 1 R12 L185
GETIMPORT R11 14 [assert]
CALL R11 1 0
REMARK allocation: closure with 0 upvalues
  339: local function test (a)
L185: NEWCLOSURE R11 P14
REMARK allocation: table hash 2
  353: a = {n=0, [-7] = "ban"}
NEWTABLE R12 2 0
LOADN R13 0
SETTABLEKS R13 R12 K55 ['n']
LOADN R13 -7
LOADK R14 K94 ['ban']
SETTABLE R14 R12 R13
MOVE R6 R12
  354: test(a)
MOVE R12 R11
MOVE R13 R6
CALL R12 1 0
REMARK builtin assert/1
  355: assert(a.n == 0 and a[-7] == "ban")
LOADB R13 0
GETTABLEKS R14 R6 K55 ['n']
JUMPXEQKN R14 K12 L187 NOT [0]
LOADN R15 -7
GETTABLE R14 R6 R15
JUMPXEQKS R14 K94 L186 ['ban']
LOADB R13 0 +1
L186: LOADB R13 1
L187: FASTCALL1 1 R13 L188
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK allocation: table hash 1
  357: a = {[-7] = "ban"};
L188: NEWTABLE R12 1 0
LOADN R13 -7
LOADK R14 K94 ['ban']
SETTABLE R14 R12 R13
MOVE R6 R12
  358: test(a)
MOVE R12 R11
MOVE R13 R6
CALL R12 1 0
REMARK builtin assert/1
  359: assert(a.n == nil and table.getn(a) == 0 and a[-7] == "ban")
LOADB R13 0
GETTABLEKS R14 R6 K55 ['n']
JUMPXEQKNIL R14 L190 NOT
LOADB R13 0
GETIMPORT R14 79 [table.getn]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K12 L190 NOT [0]
LOADN R15 -7
GETTABLE R14 R6 R15
JUMPXEQKS R14 K94 L189 ['ban']
LOADB R13 0 +1
L189: LOADB R13 1
L190: FASTCALL1 1 R13 L191
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin table.insert/3
  362: table.insert(a, 1, 10); table.insert(a, 1, 20); table.insert(a, 1, -1)
L191: MOVE R13 R6
LOADN R14 1
LOADN R15 10
FASTCALL 52 L192
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin table.insert/3
L192: MOVE R13 R6
LOADN R14 1
LOADN R15 20
FASTCALL 52 L193
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin table.insert/3
L193: MOVE R13 R6
LOADN R14 1
LOADN R15 -1
FASTCALL 52 L194
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin assert/1
  363: assert(table.remove(a) == 10)
L194: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K61 L195 [10]
LOADB R13 0 +1
L195: LOADB R13 1
L196: FASTCALL1 1 R13 L197
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  364: assert(table.remove(a) == 20)
L197: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K97 L198 [20]
LOADB R13 0 +1
L198: LOADB R13 1
L199: FASTCALL1 1 R13 L200
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  365: assert(table.remove(a) == -1)
L200: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K98 L201 [-1]
LOADB R13 0 +1
L201: LOADB R13 1
L202: FASTCALL1 1 R13 L203
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK allocation: table array 2
  367: a = {'c', 'd'}
L203: NEWTABLE R12 0 2
LOADK R13 K41 ['c']
LOADK R14 K99 ['d']
SETLIST R12 R13 2 [1]
MOVE R6 R12
REMARK builtin table.insert/3
  368: table.insert(a, 3, 'a')
MOVE R13 R6
LOADN R14 3
LOADK R15 K36 ['a']
FASTCALL 52 L204
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin table.insert/2
  369: table.insert(a, 'b')
L204: FASTCALL2K 52 R6 K40 L205 ['b']
MOVE R13 R6
LOADK R14 K40 ['b']
GETIMPORT R12 11 [table.insert]
CALL R12 2 0
REMARK builtin assert/1
  370: assert(table.remove(a, 1) == 'c')
L205: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
LOADN R16 1
CALL R14 2 1
JUMPXEQKS R14 K41 L206 ['c']
LOADB R13 0 +1
L206: LOADB R13 1
L207: FASTCALL1 1 R13 L208
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  371: assert(table.remove(a, 1) == 'd')
L208: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
LOADN R16 1
CALL R14 2 1
JUMPXEQKS R14 K99 L209 ['d']
LOADB R13 0 +1
L209: LOADB R13 1
L210: FASTCALL1 1 R13 L211
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  372: assert(table.remove(a, 1) == 'a')
L211: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
LOADN R16 1
CALL R14 2 1
JUMPXEQKS R14 K36 L212 ['a']
LOADB R13 0 +1
L212: LOADB R13 1
L213: FASTCALL1 1 R13 L214
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  373: assert(table.remove(a, 1) == 'b')
L214: GETIMPORT R14 96 [table.remove]
MOVE R15 R6
LOADN R16 1
CALL R14 2 1
JUMPXEQKS R14 K40 L215 ['b']
LOADB R13 0 +1
L215: LOADB R13 1
L216: FASTCALL1 1 R13 L217
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  374: assert(table.getn(a) == 0 and a.n == nil)
L217: LOADB R13 0
GETIMPORT R14 79 [table.getn]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K12 L219 NOT [0]
GETTABLEKS R14 R6 K55 ['n']
JUMPXEQKNIL R14 L218
LOADB R13 0 +1
L218: LOADB R13 1
L219: FASTCALL1 1 R13 L220
GETIMPORT R12 14 [assert]
CALL R12 1 0
  375: print("+")
L220: GETIMPORT R12 1 [print]
LOADK R13 K15 ['+']
CALL R12 1 0
REMARK allocation: table array 3
  378: a = {1, 2, 3}
NEWTABLE R12 0 3
LOADN R13 1
LOADN R14 2
LOADN R15 3
SETLIST R12 R13 3 [1]
MOVE R6 R12
REMARK builtin table.insert/3
  379: table.insert(a, 0, 0)
MOVE R13 R6
LOADN R14 0
LOADN R15 0
FASTCALL 52 L221
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin assert/1
  380: assert(a[0] == 0 and table.concat(a) == "123")
L221: LOADB R13 0
LOADN R15 0
GETTABLE R14 R6 R15
JUMPXEQKN R14 K12 L223 NOT [0]
GETIMPORT R14 101 [table.concat]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKS R14 K102 L222 ['123']
LOADB R13 0 +1
L222: LOADB R13 1
L223: FASTCALL1 1 R13 L224
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin table.insert/3
  381: table.insert(a, 10, 10)
L224: MOVE R13 R6
LOADN R14 10
LOADN R15 10
FASTCALL 52 L225
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin assert/1
  382: assert(a[0] == 0 and table.concat(a) == "123" and table.maxn(a) == 10 and a[10] == 10)
L225: LOADB R13 0
LOADN R15 0
GETTABLE R14 R6 R15
JUMPXEQKN R14 K12 L227 NOT [0]
LOADB R13 0
GETIMPORT R14 101 [table.concat]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKS R14 K102 L227 NOT ['123']
LOADB R13 0
GETIMPORT R14 81 [table.maxn]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K61 L227 NOT [10]
GETTABLEN R14 R6 10
JUMPXEQKN R14 K61 L226 [10]
LOADB R13 0 +1
L226: LOADB R13 1
L227: FASTCALL1 1 R13 L228
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin table.insert/3
  383: table.insert(a, -10^9, 42)
L228: MOVE R13 R6
LOADK R14 K103 [-1000000000]
LOADN R15 42
FASTCALL 52 L229
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK builtin assert/1
  384: assert(a[0] == 0 and table.concat(a) == "123" and table.maxn(a) == 10 and a[10] == 10 and a[-10^9] == 42)
L229: LOADB R13 0
LOADN R15 0
GETTABLE R14 R6 R15
JUMPXEQKN R14 K12 L231 NOT [0]
LOADB R13 0
GETIMPORT R14 101 [table.concat]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKS R14 K102 L231 NOT ['123']
LOADB R13 0
GETIMPORT R14 81 [table.maxn]
MOVE R15 R6
CALL R14 1 1
JUMPXEQKN R14 K61 L231 NOT [10]
LOADB R13 0
GETTABLEN R14 R6 10
JUMPXEQKN R14 K61 L231 NOT [10]
LOADK R15 K103 [-1000000000]
GETTABLE R14 R6 R15
JUMPXEQKN R14 K9 L230 [42]
LOADB R13 0 +1
L230: LOADB R13 1
L231: FASTCALL1 1 R13 L232
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin table.insert/3
  385: table.insert(a, 0 / 0, 42) -- platform-dependent behavior atm so hard to validate
L232: MOVE R13 R6
LOADK R14 K104 [-nan(ind)]
LOADN R15 42
FASTCALL 52 L233
GETIMPORT R12 11 [table.insert]
CALL R12 3 0
REMARK allocation: table hash 0
  387: a = {}
L233: NEWTABLE R6 0 0
  388: for i=1,1000 do
LOADN R14 1
LOADN R12 1000
LOADN R13 1
FORNPREP R12 L235
  389:   a[i] = i; a[i-1] = nil
L234: SETTABLE R14 R6 R14
SUBK R15 R14 K38 [1]
LOADNIL R16
SETTABLE R16 R6 R15
  388: for i=1,1000 do
FORNLOOP R12 L234
REMARK builtin assert/1
  391: assert(next(a,nil) == 1000 and next(a,1000) == nil)
L235: LOADB R13 0
GETIMPORT R14 106 [next]
MOVE R15 R6
LOADNIL R16
CALL R14 2 1
JUMPXEQKN R14 K84 L237 NOT [1000]
GETIMPORT R14 106 [next]
MOVE R15 R6
LOADN R16 1000
CALL R14 2 1
JUMPXEQKNIL R14 L236
LOADB R13 0 +1
L236: LOADB R13 1
L237: FASTCALL1 1 R13 L238
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  393: assert(next({}) == nil)
L238: GETIMPORT R14 106 [next]
REMARK allocation: table hash 0
NEWTABLE R15 0 0
CALL R14 1 1
JUMPXEQKNIL R14 L239
LOADB R13 0 +1
L239: LOADB R13 1
L240: FASTCALL1 1 R13 L241
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  394: assert(next({}, nil) == nil)
L241: GETIMPORT R14 106 [next]
REMARK allocation: table hash 0
NEWTABLE R15 0 0
LOADNIL R16
CALL R14 2 1
JUMPXEQKNIL R14 L242
LOADB R13 0 +1
L242: LOADB R13 1
L243: FASTCALL1 1 R13 L244
GETIMPORT R12 14 [assert]
CALL R12 1 0
  398:   local t = table.create(5)
L244: GETIMPORT R12 108 [table.create]
LOADN R13 5
CALL R12 1 1
REMARK builtin assert/1
  399:   assert(#t == 0) -- filled with nil!
LENGTH R15 R12
JUMPXEQKN R15 K12 L245 [0]
LOADB R14 0 +1
L245: LOADB R14 1
L246: FASTCALL1 1 R14 L247
GETIMPORT R13 14 [assert]
CALL R13 1 0
  400:   t[5] = 5
L247: LOADN R13 5
SETTABLEN R13 R12 5
REMARK builtin assert/1
  401:   assert(#t == 5) -- magic
LENGTH R15 R12
JUMPXEQKN R15 K93 L248 [5]
LOADB R14 0 +1
L248: LOADB R14 1
L249: FASTCALL1 1 R14 L250
GETIMPORT R13 14 [assert]
CALL R13 1 0
  403:   local t2 = table.create(5, "nice")
L250: GETIMPORT R13 108 [table.create]
LOADN R14 5
LOADK R15 K109 ['nice']
CALL R13 2 1
REMARK builtin assert/1
  404:   assert(table.concat(t2,"!") == "nice!nice!nice!nice!nice")
GETIMPORT R16 101 [table.concat]
MOVE R17 R13
LOADK R18 K110 ['!']
CALL R16 2 1
JUMPXEQKS R16 K111 L251 ['nice!nice!nice!nice!nice']
LOADB R15 0 +1
L251: LOADB R15 1
L252: FASTCALL1 1 R15 L253
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  406:   assert(table.find(t2, "nice") == 1)
L253: GETIMPORT R16 112 [table.find]
MOVE R17 R13
LOADK R18 K109 ['nice']
CALL R16 2 1
JUMPXEQKN R16 K38 L254 [1]
LOADB R15 0 +1
L254: LOADB R15 1
L255: FASTCALL1 1 R15 L256
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  407:   assert(table.find(t2, "nice", 5) == 5)
L256: GETIMPORT R16 112 [table.find]
MOVE R17 R13
LOADK R18 K109 ['nice']
LOADN R19 5
CALL R16 3 1
JUMPXEQKN R16 K93 L257 [5]
LOADB R15 0 +1
L257: LOADB R15 1
L258: FASTCALL1 1 R15 L259
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  408:   assert(table.find(t2, "nice", 6) == nil)
L259: GETIMPORT R16 112 [table.find]
MOVE R17 R13
LOADK R18 K109 ['nice']
LOADN R19 6
CALL R16 3 1
JUMPXEQKNIL R16 L260
LOADB R15 0 +1
L260: LOADB R15 1
L261: FASTCALL1 1 R15 L262
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  410:   assert(table.find({false, true}, true) == 2)
L262: GETIMPORT R16 112 [table.find]
REMARK allocation: table array 2
NEWTABLE R17 0 2
LOADB R18 0
LOADB R19 1
SETLIST R17 R18 2 [1]
LOADB R18 1
CALL R16 2 1
JUMPXEQKN R16 K113 L263 [2]
LOADB R15 0 +1
L263: LOADB R15 1
L264: FASTCALL1 1 R15 L265
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  413:   assert(table.find({[(1)] = true}, true) == 1)
L265: GETIMPORT R16 112 [table.find]
REMARK allocation: table array 1
NEWTABLE R17 0 1
LOADB R18 1
SETTABLEN R18 R17 1
LOADB R18 1
CALL R16 2 1
JUMPXEQKN R16 K38 L266 [1]
LOADB R15 0 +1
L266: LOADB R15 1
L267: FASTCALL1 1 R15 L268
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK allocation: table hash 0
  418: 	local t = {}
L268: NEWTABLE R12 0 0
  419: 	t['start\0end'] = 1
LOADN R13 1
SETTABLEKS R13 R12 K114 []
  420: 	t['start'] = 2
LOADN R13 2
SETTABLEKS R13 R12 K115 ['start']
REMARK builtin assert/1
  421: 	assert(t['start\0end'] == 1)
GETTABLEKS R15 R12 K114 []
JUMPXEQKN R15 K38 L269 [1]
LOADB R14 0 +1
L269: LOADB R14 1
L270: FASTCALL1 1 R14 L271
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1
  422: 	assert(t['start'] == 2)
L271: GETTABLEKS R15 R12 K115 ['start']
JUMPXEQKN R15 K113 L272 [2]
LOADB R14 0 +1
L272: LOADB R14 1
L273: FASTCALL1 1 R14 L274
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table hash 1
  427:   local t = {}
L274: NEWTABLE R12 1 1
REMARK builtin assert/1
  428:   assert(not table.isfrozen(t))
GETIMPORT R15 117 [table.isfrozen]
MOVE R16 R12
CALL R15 1 1
NOT R14 R15
FASTCALL1 1 R14 L275
GETIMPORT R13 14 [assert]
CALL R13 1 0
  429:   t[1] = 1
L275: LOADN R13 1
SETTABLEN R13 R12 1
  430:   t.a = 2
LOADN R13 2
SETTABLEKS R13 R12 K36 ['a']
REMARK builtin assert/1
  433:   assert(table.freeze(t) == t)
GETIMPORT R15 119 [table.freeze]
MOVE R16 R12
CALL R15 1 1
JUMPIFEQ R15 R12 L276
LOADB R14 0 +1
L276: LOADB R14 1
L277: FASTCALL1 1 R14 L278
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1+
  434:   assert(table.isfrozen(t))
L278: GETIMPORT R14 117 [table.isfrozen]
MOVE R15 R12
CALL R14 1 -1
FASTCALL 1 L279
GETIMPORT R13 14 [assert]
CALL R13 -1 0
REMARK builtin assert/1
  435:   assert(not pcall(rawset, t, 1, 2))
L279: GETIMPORT R15 121 [pcall]
GETIMPORT R16 123 [rawset]
MOVE R17 R12
LOADN R18 1
LOADN R19 2
CALL R15 4 1
NOT R14 R15
FASTCALL1 1 R14 L280
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1
  436:   assert(not pcall(rawset, t, "a", 2))
L280: GETIMPORT R15 121 [pcall]
GETIMPORT R16 123 [rawset]
MOVE R17 R12
LOADK R18 K36 ['a']
LOADN R19 2
CALL R15 4 1
NOT R14 R15
FASTCALL1 1 R14 L281
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1
  437:   assert(not pcall(function() t.a = 3 end))
L281: GETIMPORT R15 121 [pcall]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R16 P15
CAPTURE VAL R12
CALL R15 1 1
NOT R14 R15
FASTCALL1 1 R14 L282
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1
  438:   assert(not pcall(function() t[1] = 3 end))
L282: GETIMPORT R15 121 [pcall]
REMARK allocation: closure with 1 upvalues
NEWCLOSURE R16 P16
CAPTURE VAL R12
CALL R15 1 1
NOT R14 R15
FASTCALL1 1 R14 L283
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1
  439:   assert(not pcall(setmetatable, t, {}))
L283: GETIMPORT R15 121 [pcall]
GETIMPORT R16 125 [setmetatable]
MOVE R17 R12
REMARK allocation: table hash 0
NEWTABLE R18 0 0
CALL R15 3 1
NOT R14 R15
FASTCALL1 1 R14 L284
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin assert/1
  440:   assert(not pcall(table.freeze, t)) -- already frozen
L284: GETIMPORT R15 121 [pcall]
GETIMPORT R16 119 [table.freeze]
MOVE R17 R12
CALL R15 2 1
NOT R14 R15
FASTCALL1 1 R14 L285
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table hash 0
  443:   local t = {}
L285: NEWTABLE R13 0 0
REMARK builtin setmetatable/2
REMARK allocation: table template 1
  444:   setmetatable(t, { __metatable = "nope" })
DUPTABLE R16 127
LOADK R17 K128 ['nope']
SETTABLEKS R17 R16 K126 ['__metatable']
FASTCALL2 61 R13 R16 L286
MOVE R15 R13
GETIMPORT R14 125 [setmetatable]
CALL R14 2 0
REMARK builtin assert/1
  445:   assert(not pcall(table.freeze, t))
L286: GETIMPORT R16 121 [pcall]
GETIMPORT R17 119 [table.freeze]
MOVE R18 R13
CALL R16 2 1
NOT R15 R16
FASTCALL1 1 R15 L287
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  446:   assert(not table.isfrozen(t))
L287: GETIMPORT R16 117 [table.isfrozen]
MOVE R17 R13
CALL R16 1 1
NOT R15 R16
FASTCALL1 1 R15 L288
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK allocation: table hash 1
  449:   local mt = {}
L288: NEWTABLE R14 1 0
REMARK builtin setmetatable/2
REMARK allocation: table hash 0
  450:   local t = setmetatable({}, mt)
NEWTABLE R16 0 0
FASTCALL2 61 R16 R14 L289
MOVE R17 R14
GETIMPORT R15 125 [setmetatable]
CALL R15 2 1
  451:   table.freeze(t)
L289: GETIMPORT R16 119 [table.freeze]
MOVE R17 R15
CALL R16 1 0
  452:   mt.__metatable = "nope"
LOADK R16 K128 ['nope']
SETTABLEKS R16 R14 K126 ['__metatable']
REMARK builtin assert/1+
  453:   assert(table.isfrozen(t))
GETIMPORT R17 117 [table.isfrozen]
MOVE R18 R15
CALL R17 1 -1
FASTCALL 1 L290
GETIMPORT R16 14 [assert]
CALL R16 -1 0
REMARK builtin assert/1
REMARK builtin getmetatable/1
  454:   assert(getmetatable(t) == "nope")
L290: FASTCALL1 60 R15 L291
MOVE R19 R15
GETIMPORT R18 130 [getmetatable]
CALL R18 1 1
L291: JUMPXEQKS R18 K128 L292 ['nope']
LOADB R17 0 +1
L292: LOADB R17 1
L293: FASTCALL1 1 R17 L294
GETIMPORT R16 14 [assert]
CALL R16 1 0
  459:   local t = table.create(10, 1)
L294: GETIMPORT R12 108 [table.create]
LOADN R13 10
LOADN R14 1
CALL R12 2 1
REMARK builtin assert/1
  460:   assert(#t == 10)
LENGTH R15 R12
JUMPXEQKN R15 K61 L295 [10]
LOADB R14 0 +1
L295: LOADB R14 1
L296: FASTCALL1 1 R14 L297
GETIMPORT R13 14 [assert]
CALL R13 1 0
  461:   t[5] = nil
L297: LOADNIL R13
SETTABLEN R13 R12 5
REMARK builtin assert/1
  462:   assert(#t == 10)
LENGTH R15 R12
JUMPXEQKN R15 K61 L298 [10]
LOADB R14 0 +1
L298: LOADB R14 1
L299: FASTCALL1 1 R14 L300
GETIMPORT R13 14 [assert]
CALL R13 1 0
  463:   t[10] = nil
L300: LOADNIL R13
SETTABLEN R13 R12 10
REMARK builtin assert/1
  464:   assert(#t == 9)
LENGTH R15 R12
JUMPXEQKN R15 K131 L301 [9]
LOADB R14 0 +1
L301: LOADB R14 1
L302: FASTCALL1 1 R14 L303
GETIMPORT R13 14 [assert]
CALL R13 1 0
  465:   t[9] = nil
L303: LOADNIL R13
SETTABLEN R13 R12 9
  466:   t[8] = nil
LOADNIL R13
SETTABLEN R13 R12 8
REMARK builtin assert/1
  467:   assert(#t == 7)
LENGTH R15 R12
JUMPXEQKN R15 K132 L304 [7]
LOADB R14 0 +1
L304: LOADB R14 1
L305: FASTCALL1 1 R14 L306
GETIMPORT R13 14 [assert]
CALL R13 1 0
  469:   t = table.create(10)
L306: GETIMPORT R13 108 [table.create]
LOADN R14 10
CALL R13 1 1
MOVE R12 R13
REMARK builtin assert/1
  470:   assert(#t == 0)
LENGTH R15 R12
JUMPXEQKN R15 K12 L307 [0]
LOADB R14 0 +1
L307: LOADB R14 1
L308: FASTCALL1 1 R14 L309
GETIMPORT R13 14 [assert]
CALL R13 1 0
  471:   t[1] = 1
L309: LOADN R13 1
SETTABLEN R13 R12 1
REMARK builtin assert/1
  472:   assert(#t == 1)
LENGTH R15 R12
JUMPXEQKN R15 K38 L310 [1]
LOADB R14 0 +1
L310: LOADB R14 1
L311: FASTCALL1 1 R14 L312
GETIMPORT R13 14 [assert]
CALL R13 1 0
  473:   t[2] = 1
L312: LOADN R13 1
SETTABLEN R13 R12 2
REMARK builtin assert/1
  474:   assert(#t == 2)
LENGTH R15 R12
JUMPXEQKN R15 K113 L313 [2]
LOADB R14 0 +1
L313: LOADB R14 1
L314: FASTCALL1 1 R14 L315
GETIMPORT R13 14 [assert]
CALL R13 1 0
  475:   t[3] = 1
L315: LOADN R13 1
SETTABLEN R13 R12 3
  476:   t[4] = 1
LOADN R13 1
SETTABLEN R13 R12 4
REMARK builtin assert/1
  477:   assert(#t == 4)
LENGTH R15 R12
JUMPXEQKN R15 K133 L316 [4]
LOADB R14 0 +1
L316: LOADB R14 1
L317: FASTCALL1 1 R14 L318
GETIMPORT R13 14 [assert]
CALL R13 1 0
  479:   t = table.create(10)
L318: GETIMPORT R13 108 [table.create]
LOADN R14 10
CALL R13 1 1
MOVE R12 R13
REMARK builtin assert/1
  480:   assert(#t == 0)
LENGTH R15 R12
JUMPXEQKN R15 K12 L319 [0]
LOADB R14 0 +1
L319: LOADB R14 1
L320: FASTCALL1 1 R14 L321
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin table.insert/2
  481:   table.insert(t, 1)
L321: FASTCALL2K 52 R12 K38 L322 [1]
MOVE R14 R12
LOADK R15 K38 [1]
GETIMPORT R13 11 [table.insert]
CALL R13 2 0
REMARK builtin assert/1
  482:   assert(#t == 1)
L322: LENGTH R15 R12
JUMPXEQKN R15 K38 L323 [1]
LOADB R14 0 +1
L323: LOADB R14 1
L324: FASTCALL1 1 R14 L325
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin table.insert/2
  483:   table.insert(t, 1)
L325: FASTCALL2K 52 R12 K38 L326 [1]
MOVE R14 R12
LOADK R15 K38 [1]
GETIMPORT R13 11 [table.insert]
CALL R13 2 0
REMARK builtin assert/1
  484:   assert(#t == 2)
L326: LENGTH R15 R12
JUMPXEQKN R15 K113 L327 [2]
LOADB R14 0 +1
L327: LOADB R14 1
L328: FASTCALL1 1 R14 L329
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK builtin table.insert/2
  485:   table.insert(t, 1)
L329: FASTCALL2K 52 R12 K38 L330 [1]
MOVE R14 R12
LOADK R15 K38 [1]
GETIMPORT R13 11 [table.insert]
CALL R13 2 0
REMARK builtin table.insert/2
  486:   table.insert(t, 1)
L330: FASTCALL2K 52 R12 K38 L331 [1]
MOVE R14 R12
LOADK R15 K38 [1]
GETIMPORT R13 11 [table.insert]
CALL R13 2 0
REMARK builtin assert/1
  487:   assert(#t == 4)
L331: LENGTH R15 R12
JUMPXEQKN R15 K133 L332 [4]
LOADB R14 0 +1
L332: LOADB R14 1
L333: FASTCALL1 1 R14 L334
GETIMPORT R13 14 [assert]
CALL R13 1 0
  489:   t = table.create(10, 1)
L334: GETIMPORT R13 108 [table.create]
LOADN R14 10
LOADN R15 1
CALL R13 2 1
MOVE R12 R13
REMARK builtin assert/1
  490:   assert(#t == 10)
LENGTH R15 R12
JUMPXEQKN R15 K61 L335 [10]
LOADB R14 0 +1
L335: LOADB R14 1
L336: FASTCALL1 1 R14 L337
GETIMPORT R13 14 [assert]
CALL R13 1 0
  491:   table.remove(t)
L337: GETIMPORT R13 96 [table.remove]
MOVE R14 R12
CALL R13 1 0
REMARK builtin assert/1
  492:   assert(#t == 9)
LENGTH R15 R12
JUMPXEQKN R15 K131 L338 [9]
LOADB R14 0 +1
L338: LOADB R14 1
L339: FASTCALL1 1 R14 L340
GETIMPORT R13 14 [assert]
CALL R13 1 0
  493:   table.remove(t)
L340: GETIMPORT R13 96 [table.remove]
MOVE R14 R12
CALL R13 1 0
  494:   table.remove(t)
GETIMPORT R13 96 [table.remove]
MOVE R14 R12
CALL R13 1 0
REMARK builtin assert/1
  495:   assert(#t == 7)
LENGTH R15 R12
JUMPXEQKN R15 K132 L341 [7]
LOADB R14 0 +1
L341: LOADB R14 1
L342: FASTCALL1 1 R14 L343
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table hash 2 array 3
  500:   local t = {a = 1, b = 2, 3, 4, 5}
L343: NEWTABLE R12 2 3
LOADN R16 1
SETTABLEKS R16 R12 K36 ['a']
LOADN R16 2
SETTABLEKS R16 R12 K40 ['b']
LOADN R13 3
LOADN R14 4
LOADN R15 5
SETLIST R12 R13 3 [1]
  501:   local tt = table.clone(t)
GETIMPORT R13 135 [table.clone]
MOVE R14 R12
CALL R13 1 1
REMARK builtin assert/1
  503:   assert(#tt == 3)
LENGTH R16 R13
JUMPXEQKN R16 K35 L344 [3]
LOADB R15 0 +1
L344: LOADB R15 1
L345: FASTCALL1 1 R15 L346
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  504:   assert(tt.a == 1 and tt.b == 2)
L346: LOADB R15 0
GETTABLEKS R16 R13 K36 ['a']
JUMPXEQKN R16 K38 L348 NOT [1]
GETTABLEKS R16 R13 K40 ['b']
JUMPXEQKN R16 K113 L347 [2]
LOADB R15 0 +1
L347: LOADB R15 1
L348: FASTCALL1 1 R15 L349
GETIMPORT R14 14 [assert]
CALL R14 1 0
  506:   t.c = 3
L349: LOADN R14 3
SETTABLEKS R14 R12 K41 ['c']
REMARK builtin assert/1
  507:   assert(tt.c == nil)
GETTABLEKS R16 R13 K41 ['c']
JUMPXEQKNIL R16 L350
LOADB R15 0 +1
L350: LOADB R15 1
L351: FASTCALL1 1 R15 L352
GETIMPORT R14 14 [assert]
CALL R14 1 0
  509:   t = table.freeze({"test"})
L352: GETIMPORT R14 119 [table.freeze]
REMARK allocation: table array 1
NEWTABLE R15 0 1
LOADK R16 K136 ['test']
SETLIST R15 R16 1 [1]
CALL R14 1 1
MOVE R12 R14
  510:   tt = table.clone(t)
GETIMPORT R14 135 [table.clone]
MOVE R15 R12
CALL R14 1 1
MOVE R13 R14
REMARK builtin assert/1
  511:   assert(table.isfrozen(t) and not table.isfrozen(tt))
GETIMPORT R15 117 [table.isfrozen]
MOVE R16 R12
CALL R15 1 1
JUMPIFNOT R15 L353
GETIMPORT R16 117 [table.isfrozen]
MOVE R17 R13
CALL R16 1 1
NOT R15 R16
L353: FASTCALL1 1 R15 L354
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin setmetatable/2
REMARK allocation: table hash 0
  513:   t = setmetatable({}, {})
L354: NEWTABLE R15 0 0
REMARK allocation: table hash 0
NEWTABLE R16 0 0
FASTCALL2 61 R15 R16 L355
GETIMPORT R14 125 [setmetatable]
CALL R14 2 1
L355: MOVE R12 R14
  514:   tt = table.clone(t)
GETIMPORT R14 135 [table.clone]
MOVE R15 R12
CALL R14 1 1
MOVE R13 R14
REMARK builtin assert/1
REMARK builtin getmetatable/1
  515:   assert(getmetatable(t) == getmetatable(tt))
FASTCALL1 60 R12 L356
MOVE R17 R12
GETIMPORT R16 130 [getmetatable]
CALL R16 1 1
REMARK builtin getmetatable/1
L356: FASTCALL1 60 R13 L357
MOVE R18 R13
GETIMPORT R17 130 [getmetatable]
CALL R17 1 1
L357: JUMPIFEQ R16 R17 L358
LOADB R15 0 +1
L358: LOADB R15 1
L359: FASTCALL1 1 R15 L360
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin setmetatable/2
REMARK allocation: table hash 0
  517:   t = setmetatable({}, {__metatable = "protected"})
L360: NEWTABLE R15 0 0
REMARK allocation: table template 1
DUPTABLE R16 127
LOADK R17 K137 ['protected']
SETTABLEKS R17 R16 K126 ['__metatable']
FASTCALL2 61 R15 R16 L361
GETIMPORT R14 125 [setmetatable]
CALL R14 2 1
L361: MOVE R12 R14
REMARK builtin assert/1
  518:   assert(not pcall(table.clone, t))
GETIMPORT R16 121 [pcall]
GETIMPORT R17 135 [table.clone]
MOVE R18 R12
CALL R16 2 1
NOT R15 R16
FASTCALL1 1 R15 L362
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK allocation: closure with 0 upvalues
  520:   function order(t)
L362: NEWCLOSURE R14 P17
SETGLOBAL R14 K138 ['order']
REMARK allocation: table template 6
  528:   t = {a = 1, b = 2, c = 3, d = 4, e = 5, f = 6}
DUPTABLE R14 141
LOADN R15 1
SETTABLEKS R15 R14 K36 ['a']
LOADN R15 2
SETTABLEKS R15 R14 K40 ['b']
LOADN R15 3
SETTABLEKS R15 R14 K41 ['c']
LOADN R15 4
SETTABLEKS R15 R14 K99 ['d']
LOADN R15 5
SETTABLEKS R15 R14 K139 ['e']
LOADN R15 6
SETTABLEKS R15 R14 K140 ['f']
MOVE R12 R14
  529:   tt = table.clone(t)
GETIMPORT R14 135 [table.clone]
MOVE R15 R12
CALL R14 1 1
MOVE R13 R14
REMARK builtin assert/1
  530:   assert(order(t) == order(tt))
GETGLOBAL R16 K138 ['order']
MOVE R17 R12
CALL R16 1 1
GETGLOBAL R17 K138 ['order']
MOVE R18 R13
CALL R17 1 1
JUMPIFEQ R16 R17 L363
LOADB R15 0 +1
L363: LOADB R15 1
L364: FASTCALL1 1 R15 L365
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  532:   assert(not pcall(table.clone))
L365: GETIMPORT R16 121 [pcall]
GETIMPORT R17 135 [table.clone]
CALL R16 1 1
NOT R15 R16
FASTCALL1 1 R15 L366
GETIMPORT R14 14 [assert]
CALL R14 1 0
REMARK builtin assert/1
  533:   assert(not pcall(table.clone, 42))
L366: GETIMPORT R16 121 [pcall]
GETIMPORT R17 135 [table.clone]
LOADN R18 42
CALL R16 2 1
NOT R15 R16
FASTCALL1 1 R15 L367
GETIMPORT R14 14 [assert]
CALL R14 1 0
  538:   local arr = table.create(5, 42)
L367: GETIMPORT R12 108 [table.create]
LOADN R13 5
LOADN R14 42
CALL R12 2 1
  540:   arr[1] = nil
LOADNIL R13
SETTABLEN R13 R12 1
  541:   arr.a = 'a' -- trigger rehash
LOADK R13 K36 ['a']
SETTABLEKS R13 R12 K36 ['a']
REMARK builtin assert/1
  543:   assert(#arr == 5) -- technically 0 is also valid, but it happens to be 5 because array capacity is 5
LENGTH R15 R12
JUMPXEQKN R15 K93 L368 [5]
LOADB R14 0 +1
L368: LOADB R14 1
L369: FASTCALL1 1 R14 L370
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table hash 1
  548:   local arr = {}
L370: NEWTABLE R12 1 1
  549:   arr.a = 'a'
LOADK R13 K36 ['a']
SETTABLEKS R13 R12 K36 ['a']
  550:   arr.a = nil
LOADNIL R13
SETTABLEKS R13 R12 K36 ['a']
  551:   arr[1] = 1 -- should rehash and resize array part, otherwise # won't find the boundary in array part
LOADN R13 1
SETTABLEN R13 R12 1
REMARK builtin assert/1
  553:   assert(#arr == 1)
LENGTH R15 R12
JUMPXEQKN R15 K38 L371 [1]
LOADB R14 0 +1
L371: LOADB R14 1
L372: FASTCALL1 1 R14 L373
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table hash 0
  558:   local arr = {}
L373: NEWTABLE R12 0 1
  559:   for i=5,2,-1 do
LOADN R15 5
LOADN R13 2
LOADN R14 -1
FORNPREP R13 L378
  560:     arr[i] = i
L374: SETTABLE R15 R12 R15
REMARK builtin assert/1
  561:     assert(#arr == 0)
LENGTH R18 R12
JUMPXEQKN R18 K12 L375 [0]
LOADB R17 0 +1
L375: LOADB R17 1
L376: FASTCALL1 1 R17 L377
GETIMPORT R16 14 [assert]
CALL R16 1 0
  559:   for i=5,2,-1 do
L377: FORNLOOP R13 L374
  563:   arr[1] = 1
L378: LOADN R13 1
SETTABLEN R13 R12 1
REMARK builtin assert/1
  564:   assert(#arr == 5)
LENGTH R15 R12
JUMPXEQKN R15 K93 L379 [5]
LOADB R14 0 +1
L379: LOADB R14 1
L380: FASTCALL1 1 R14 L381
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table hash 1 array 1
  569:   local arr = {[2]=2,1}
L381: NEWTABLE R12 1 1
LOADN R14 2
SETTABLEN R14 R12 2
LOADN R13 1
SETLIST R12 R13 1 [1]
REMARK builtin assert/1
  570:   assert(#arr == 2)
LENGTH R15 R12
JUMPXEQKN R15 K113 L382 [2]
LOADB R14 0 +1
L382: LOADB R14 1
L383: FASTCALL1 1 R14 L384
GETIMPORT R13 14 [assert]
CALL R13 1 0
REMARK allocation: table array 5
  575:   local t1 = {1, 2, 3, 4, 5}
L384: NEWTABLE R12 0 5
LOADN R13 1
LOADN R14 2
LOADN R15 3
LOADN R16 4
LOADN R17 5
SETLIST R12 R13 5 [1]
REMARK allocation: table hash 1
  576:   local t2 = {[6] = 6}
NEWTABLE R13 1 0
LOADN R14 6
SETTABLEN R14 R13 6
  578:   table.move(t1, 1, 5, 1, t2)
GETIMPORT R14 143 [table.move]
MOVE R15 R12
LOADN R16 1
LOADN R17 5
LOADN R18 1
MOVE R19 R13
CALL R14 5 0
REMARK builtin assert/1
  579:   assert(#t2 == 6)
LENGTH R16 R13
JUMPXEQKN R16 K144 L385 [6]
LOADB R15 0 +1
L385: LOADB R15 1
L386: FASTCALL1 1 R15 L387
GETIMPORT R14 14 [assert]
CALL R14 1 0
  584:   local ok, res = pcall(function()
L387: GETIMPORT R12 121 [pcall]
REMARK allocation: closure with 0 upvalues
NEWCLOSURE R13 P18
CALL R12 1 2
REMARK builtin assert/1
  592:   assert(not ok)
NOT R15 R12
FASTCALL1 1 R15 L388
GETIMPORT R14 14 [assert]
CALL R14 1 0
  597:   local hit = false
L388: LOADB R12 0
REMARK allocation: table hash 1
  599:   local grandparent = {}
NEWTABLE R13 1 0
REMARK allocation: closure with 1 upvalues
  600:   grandparent.__newindex = function(s,k,v)
NEWCLOSURE R14 P19
CAPTURE REF R12
SETTABLEKS R14 R13 K145 ['__newindex']
REMARK allocation: table hash 1
  605:   local parent = {}
NEWTABLE R14 1 0
  606:   parent.__newindex = parent
SETTABLEKS R14 R14 K145 ['__newindex']
REMARK builtin setmetatable/2
  607:   setmetatable(parent, grandparent)
FASTCALL2 61 R14 R13 L389
MOVE R16 R14
MOVE R17 R13
GETIMPORT R15 125 [setmetatable]
CALL R15 2 0
REMARK builtin setmetatable/2
REMARK allocation: table hash 1
  609:   local child = setmetatable({}, parent)
L389: NEWTABLE R16 1 0
FASTCALL2 61 R16 R14 L390
MOVE R17 R14
GETIMPORT R15 125 [setmetatable]
CALL R15 2 1
  610:   child.foo = 10
L390: LOADN R16 10
SETTABLEKS R16 R15 K39 ['foo']
REMARK builtin assert/1
  612:   assert(hit and child.foo == nil and parent.foo == nil)
MOVE R17 R12
JUMPIFNOT R17 L392
LOADB R17 0
GETTABLEKS R18 R15 K39 ['foo']
JUMPXEQKNIL R18 L392 NOT
GETTABLEKS R18 R14 K39 ['foo']
JUMPXEQKNIL R18 L391
LOADB R17 0 +1
L391: LOADB R17 1
L392: FASTCALL1 1 R17 L393
GETIMPORT R16 14 [assert]
CALL R16 1 0
L393: CLOSEUPVALS R12
  617:   local co = coroutine.wrap(function (t)
GETIMPORT R12 147 [coroutine.wrap]
REMARK allocation: closure with 0 upvalues
NEWCLOSURE R13 P20
CALL R12 1 1
REMARK allocation: table hash 0
  629:   local t = {}
NEWTABLE R13 0 0
REMARK allocation: table array 1
  630:   t[{1}] = 1    -- add several unanchored, collectable keys
NEWTABLE R14 0 1
LOADN R15 1
SETLIST R14 R15 1 [1]
LOADN R15 1
SETTABLE R15 R13 R14
REMARK allocation: table array 1
  631:   t[{2}] = 2
NEWTABLE R14 0 1
LOADN R15 2
SETLIST R14 R15 1 [1]
LOADN R15 2
SETTABLE R15 R13 R14
  632:   t[string.rep("a", 50)] = "a"    -- long string
GETIMPORT R14 90 [string.rep]
LOADK R15 K36 ['a']
LOADN R16 50
CALL R14 2 1
LOADK R15 K36 ['a']
SETTABLE R15 R13 R14
  633:   t[string.rep("b", 50)] = "b"
GETIMPORT R14 90 [string.rep]
LOADK R15 K40 ['b']
LOADN R16 50
CALL R14 2 1
LOADK R15 K40 ['b']
SETTABLE R15 R13 R14
REMARK allocation: table array 1
  634:   t[{3}] = 3
NEWTABLE R14 0 1
LOADN R15 3
SETLIST R14 R15 1 [1]
LOADN R15 3
SETTABLE R15 R13 R14
  635:   t[string.rep("c", 10)] = "c"    -- short string
GETIMPORT R14 90 [string.rep]
LOADK R15 K41 ['c']
LOADN R16 10
CALL R14 2 1
LOADK R15 K41 ['c']
SETTABLE R15 R13 R14
REMARK allocation: closure with 0 upvalues
  636:   t[function () return 10 end] = 10
NEWCLOSURE R14 P21
LOADN R15 10
SETTABLE R15 R13 R14
  637:   local count = 7
LOADN R14 7
  638:   while co(t) do
L394: MOVE R15 R12
MOVE R16 R13
CALL R15 1 1
JUMPIFNOT R15 L395
  639:     collectgarbage("collect")   -- collect dead keys
GETIMPORT R15 77 [collectgarbage]
LOADK R16 K148 ['collect']
CALL R15 1 0
  640:     count = count - 1
SUBK R14 R14 K38 [1]
  638:   while co(t) do
JUMPBACK L394
REMARK builtin assert/1
  642:   assert(count == 0 and next(t) == nil)    -- traversed the whole table
L395: LOADB R16 0
JUMPXEQKN R14 K12 L397 NOT [0]
GETIMPORT R17 106 [next]
MOVE R18 R13
CALL R17 1 1
JUMPXEQKNIL R17 L396
LOADB R16 0 +1
L396: LOADB R16 1
L397: FASTCALL1 1 R16 L398
GETIMPORT R15 14 [assert]
CALL R15 1 0
REMARK builtin assert/1
  647:   assert(pcall(table.insert, {}) == false)
L398: GETIMPORT R14 121 [pcall]
GETIMPORT R15 11 [table.insert]
REMARK allocation: table hash 0
NEWTABLE R16 0 0
CALL R14 2 1
JUMPXEQKB R14 0 L399
LOADB R13 0 +1
L399: LOADB R13 1
L400: FASTCALL1 1 R13 L401
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  648:   assert(pcall(table.insert, {}, 1, 2, 3) == false)
L401: GETIMPORT R14 121 [pcall]
GETIMPORT R15 11 [table.insert]
REMARK allocation: table hash 0
NEWTABLE R16 0 0
LOADN R17 1
LOADN R18 2
LOADN R19 3
CALL R14 5 1
JUMPXEQKB R14 0 L402
LOADB R13 0 +1
L402: LOADB R13 1
L403: FASTCALL1 1 R13 L404
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  649:   assert(pcall(table.insert, table.freeze({1, 2, 3}), 4) == false)
L404: GETIMPORT R14 121 [pcall]
GETIMPORT R15 11 [table.insert]
GETIMPORT R16 119 [table.freeze]
REMARK allocation: table array 3
NEWTABLE R17 0 3
LOADN R18 1
LOADN R19 2
LOADN R20 3
SETLIST R17 R18 3 [1]
CALL R16 1 1
LOADN R17 4
CALL R14 3 1
JUMPXEQKB R14 0 L405
LOADB R13 0 +1
L405: LOADB R13 1
L406: FASTCALL1 1 R13 L407
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  650:   assert(pcall(table.insert, table.freeze({1, 2, 3}), 1, 4) == false)
L407: GETIMPORT R14 121 [pcall]
GETIMPORT R15 11 [table.insert]
GETIMPORT R16 119 [table.freeze]
REMARK allocation: table array 3
NEWTABLE R17 0 3
LOADN R18 1
LOADN R19 2
LOADN R20 3
SETLIST R17 R18 3 [1]
CALL R16 1 1
LOADN R17 1
LOADN R18 4
CALL R14 4 1
JUMPXEQKB R14 0 L408
LOADB R13 0 +1
L408: LOADB R13 1
L409: FASTCALL1 1 R13 L410
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  652:   assert(pcall(table.remove, table.freeze({1})) == false)
L410: GETIMPORT R14 121 [pcall]
GETIMPORT R15 96 [table.remove]
GETIMPORT R16 119 [table.freeze]
REMARK allocation: table array 1
NEWTABLE R17 0 1
LOADN R18 1
SETLIST R17 R18 1 [1]
CALL R16 1 -1
CALL R14 -1 1
JUMPXEQKB R14 0 L411
LOADB R13 0 +1
L411: LOADB R13 1
L412: FASTCALL1 1 R13 L413
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  654:   assert(pcall(table.concat, {true}) == false)
L413: GETIMPORT R14 121 [pcall]
GETIMPORT R15 101 [table.concat]
REMARK allocation: table array 1
NEWTABLE R16 0 1
LOADB R17 1
SETLIST R16 R17 1 [1]
CALL R14 2 1
JUMPXEQKB R14 0 L414
LOADB R13 0 +1
L414: LOADB R13 1
L415: FASTCALL1 1 R13 L416
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  656:   assert(pcall(table.create) == false)
L416: GETIMPORT R14 121 [pcall]
GETIMPORT R15 108 [table.create]
CALL R14 1 1
JUMPXEQKB R14 0 L417
LOADB R13 0 +1
L417: LOADB R13 1
L418: FASTCALL1 1 R13 L419
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  657:   assert(pcall(table.create, -1) == false)
L419: GETIMPORT R14 121 [pcall]
GETIMPORT R15 108 [table.create]
LOADN R16 -1
CALL R14 2 1
JUMPXEQKB R14 0 L420
LOADB R13 0 +1
L420: LOADB R13 1
L421: FASTCALL1 1 R13 L422
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  658:   assert(pcall(table.create, 1e9) == false)
L422: GETIMPORT R14 121 [pcall]
GETIMPORT R15 108 [table.create]
LOADK R16 K149 [1000000000]
CALL R14 2 1
JUMPXEQKB R14 0 L423
LOADB R13 0 +1
L423: LOADB R13 1
L424: FASTCALL1 1 R13 L425
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  660:   assert(pcall(table.find, {}, 42, 0) == false)
L425: GETIMPORT R14 121 [pcall]
GETIMPORT R15 112 [table.find]
REMARK allocation: table hash 0
NEWTABLE R16 0 0
LOADN R17 42
LOADN R18 0
CALL R14 4 1
JUMPXEQKB R14 0 L426
LOADB R13 0 +1
L426: LOADB R13 1
L427: FASTCALL1 1 R13 L428
GETIMPORT R12 14 [assert]
CALL R12 1 0
REMARK builtin assert/1
  662:   assert(pcall(table.clear, table.freeze({})) == false)
L428: GETIMPORT R14 121 [pcall]
GETIMPORT R15 151 [table.clear]
GETIMPORT R16 119 [table.freeze]
REMARK allocation: table hash 0
NEWTABLE R17 0 0
CALL R16 1 -1
CALL R14 -1 1
JUMPXEQKB R14 0 L429
LOADB R13 0 +1
L429: LOADB R13 1
L430: FASTCALL1 1 R13 L431
GETIMPORT R12 14 [assert]
CALL R12 1 0
  667:   for i = 1,10 do
L431: LOADN R14 1
LOADN R12 10
LOADN R13 1
FORNPREP R12 L440
REMARK builtin setmetatable/2
REMARK allocation: table hash 1
  668:     local t = setmetatable({}, { __index = { foo = 1 }})
L432: NEWTABLE R16 1 0
REMARK allocation: table template 1
DUPTABLE R17 153
REMARK allocation: table template 1
DUPTABLE R18 154
LOADN R19 1
SETTABLEKS R19 R18 K39 ['foo']
SETTABLEKS R18 R17 K152 ['__index']
FASTCALL2 61 R16 R17 L433
GETIMPORT R15 125 [setmetatable]
CALL R15 2 1
REMARK builtin assert/1
  670:     assert(t.foo == 1)
L433: GETTABLEKS R18 R15 K39 ['foo']
JUMPXEQKN R18 K38 L434 [1]
LOADB R17 0 +1
L434: LOADB R17 1
L435: FASTCALL1 1 R17 L436
GETIMPORT R16 14 [assert]
CALL R16 1 0
  672:     t[-i] = 2
L436: MINUS R16 R14
LOADN R17 2
SETTABLE R17 R15 R16
REMARK allocation: closure with 0 upvalues
  673:     t.foo = function(t, i) return -i end
NEWCLOSURE R16 P22
SETTABLEKS R16 R15 K39 ['foo']
REMARK builtin assert/1
  675:     assert(t:foo(i) == -i)
MOVE R20 R14
NAMECALL R18 R15 K39 ['foo']
CALL R18 2 1
MINUS R19 R14
JUMPIFEQ R18 R19 L437
LOADB R17 0 +1
L437: LOADB R17 1
L438: FASTCALL1 1 R17 L439
GETIMPORT R16 14 [assert]
CALL R16 1 0
  667:   for i = 1,10 do
L439: FORNLOOP R12 L432
  679: print"OK"
L440: GETIMPORT R12 1 [print]
LOADK R13 K155 ['OK']
CALL R12 1 0
  680: 
CLOSEUPVALS R6
RETURN R0 0

]====]
end