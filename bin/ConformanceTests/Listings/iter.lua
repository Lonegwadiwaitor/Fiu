--[====[Generated by CreateTests.lua v2]====]
return function()
	return [====[Function 0 (??):
   38:              if n > 0 then
LOADN R2 0
JUMPIFNOTLT R2 R1 L1
   39:                n = n-1
SUBK R1 R1 K0 [1]
   40:                return n, unpack(t)
MOVE R2 R1
REMARK builtin unpack/1
GETUPVAL R4 0
FASTCALL1 53 R4 L0
GETIMPORT R3 2 [unpack]
CALL R3 1 -1
L0: RETURN R2 -1
   42:            end, nil, n
L1: RETURN R0 0

Function 1 (f):
REMARK allocation: table hash 0
   36:     local t = {}; for i=1,p do t[i] = i*10 end
NEWTABLE R2 0 0
LOADN R5 1
MOVE R3 R1
LOADN R4 1
FORNPREP R3 L1
L0: MULK R6 R5 K0 [10]
SETTABLE R6 R2 R5
FORNLOOP R3 L0
REMARK allocation: closure with 1 upvalues
   37:     return function (_,n)
L1: NEWCLOSURE R3 P0
CAPTURE VAL R2
   42:            end, nil, n
LOADNIL R4
MOVE R5 R0
RETURN R3 3

Function 2 (__call):
   56:   setmetatable(f, { __call = function(_, _, n) if n > 0 then return n - 1 end end })
LOADN R3 0
JUMPIFNOTLT R3 R2 L0
SUBK R3 R2 K0 [1]
RETURN R3 1
L0: RETURN R0 0

Function 3 (??):
   68:   getmetatable(f).__call = function(_, _, n) if n > 0 then return n - 1 end end
LOADN R3 0
JUMPIFNOTLT R3 R2 L0
SUBK R3 R2 K0 [1]
RETURN R3 1
L0: RETURN R0 0

Function 4 (__iter):
REMARK builtin assert/1
  108:     assert(f == x)
GETUPVAL R3 0
JUMPIFEQ R3 R0 L0
LOADB R2 0 +1
L0: LOADB R2 1
L1: FASTCALL1 1 R2 L2
GETIMPORT R1 1 [assert]
CALL R1 1 0
  109:     return next, {1, 2, 3, 4}
L2: GETIMPORT R1 3 [next]
REMARK allocation: table array 4
NEWTABLE R2 0 4
LOADN R3 1
LOADN R4 2
LOADN R5 3
LOADN R6 4
SETLIST R2 R3 4 [1]
RETURN R1 2

Function 5 (??):
REMARK builtin assert/1
  123:     assert(f == x)
GETUPVAL R3 0
JUMPIFEQ R3 R0 L0
LOADB R2 0 +1
L0: LOADB R2 1
L1: FASTCALL1 1 R2 L2
GETIMPORT R1 1 [assert]
CALL R1 1 0
  124:     return next, {1, 2, 3, 4}
L2: GETIMPORT R1 3 [next]
REMARK allocation: table array 4
NEWTABLE R2 0 4
LOADN R3 1
LOADN R4 2
LOADN R5 3
LOADN R6 4
SETLIST R2 R3 4 [1]
RETURN R1 2

Function 6 (??):
  164:   local ok, err = pcall(function() for x in 42 do end end)
LOADN R0 42
LOADNIL R1
LOADNIL R2
FORGPREP R0 L0
L0: FORGLOOP R0 L0 1
RETURN R0 0

Function 7 (__iter):
  171:   setmetatable(obj, { __iter = function() end })
RETURN R0 0

Function 8 (??):
  173:   local ok, err = pcall(function() for x in obj do end end)
GETUPVAL R0 0
LOADNIL R1
LOADNIL R2
FORGPREP R0 L0
L0: FORGLOOP R0 L0 1
RETURN R0 0

Function 9 (??):
  200:   env.pairs = function() return "nope" end
LOADK R0 K0 ['nope']
RETURN R0 1

Function 10 (??):
  201:   env.ipairs = function() return "nope" end
LOADK R0 K0 ['nope']
RETURN R0 1

Function 11 (??):
  204:   local ok, err = pcall(function() for k, v in pairs({}) do end end)
GETIMPORT R0 1 [pairs]
REMARK allocation: table hash 0
NEWTABLE R1 0 0
CALL R0 1 3
FORGPREP_NEXT R0 L0
L0: FORGLOOP R0 L0 2
RETURN R0 0

Function 12 (??):
  207:   local ok, err = pcall(function() for k, v in ipairs({}) do end end)
GETIMPORT R0 1 [ipairs]
REMARK allocation: table hash 0
NEWTABLE R1 0 0
CALL R0 1 3
FORGPREP_INEXT R0 L0
L0: FORGLOOP R0 L0 2 [inext]
RETURN R0 0

Function 13 (??):
  210:   local ok, err = pcall(function() for k, v in next, {} do end end)
GETIMPORT R0 1 [next]
REMARK allocation: table hash 0
NEWTABLE R1 0 0
LOADNIL R2
FORGPREP_NEXT R0 L0
L0: FORGLOOP R0 L0 2
RETURN R0 0

Function 14 (testgetfenv):
  199:   local env = getfenv(1)
GETIMPORT R0 1 [getfenv]
LOADN R1 1
CALL R0 1 1
  200:   env.pairs = function() return "nope" end
DUPCLOSURE R1 K2 []
SETTABLEKS R1 R0 K3 ['pairs']
  201:   env.ipairs = function() return "nope" end
DUPCLOSURE R1 K4 []
SETTABLEKS R1 R0 K5 ['ipairs']
REMARK allocation: table array 3
  202:   env.next = {1, 2, 3}
NEWTABLE R1 0 3
LOADN R2 1
LOADN R3 2
LOADN R4 3
SETLIST R1 R2 3 [1]
SETTABLEKS R1 R0 K6 ['next']
  204:   local ok, err = pcall(function() for k, v in pairs({}) do end end)
GETIMPORT R1 8 [pcall]
DUPCLOSURE R2 K9 []
CALL R1 1 2
REMARK builtin assert/1
  205:   assert(not ok and err:match("attempt to iterate over a string value"))
NOT R4 R1
JUMPIFNOT R4 L0
LOADK R6 K10 ['attempt to iterate over a string'...]
NAMECALL R4 R2 K11 ['match']
CALL R4 2 1
L0: FASTCALL1 1 R4 L1
GETIMPORT R3 13 [assert]
CALL R3 1 0
  207:   local ok, err = pcall(function() for k, v in ipairs({}) do end end)
L1: GETIMPORT R3 8 [pcall]
DUPCLOSURE R4 K14 []
CALL R3 1 2
REMARK builtin assert/1
  208:   assert(not ok and err:match("attempt to iterate over a string value"))
NOT R6 R3
JUMPIFNOT R6 L2
LOADK R8 K10 ['attempt to iterate over a string'...]
NAMECALL R6 R4 K11 ['match']
CALL R6 2 1
L2: FASTCALL1 1 R6 L3
GETIMPORT R5 13 [assert]
CALL R5 1 0
  210:   local ok, err = pcall(function() for k, v in next, {} do end end)
L3: GETIMPORT R5 8 [pcall]
DUPCLOSURE R6 K15 []
CALL R5 1 2
REMARK builtin assert/1
  211:   assert(not ok and err:match("attempt to iterate over a table value"))
NOT R8 R5
JUMPIFNOT R8 L4
LOADK R10 K16 ['attempt to iterate over a table '...]
NAMECALL R8 R6 K11 ['match']
CALL R8 2 1
L4: FASTCALL1 1 R8 L5
GETIMPORT R7 13 [assert]
CALL R7 1 0
  212: end
L5: RETURN R0 0

Function 15 (??):
    3: print('testing iteration')
GETIMPORT R0 1 [print]
LOADK R1 K2 ['testing iteration']
CALL R0 1 0
    7:   local a
LOADNIL R0
    8:   for a,b in pairs{} do error("not here") end
GETIMPORT R1 4 [pairs]
REMARK allocation: table hash 0
NEWTABLE R2 0 0
CALL R1 1 3
FORGPREP_NEXT R1 L1
L0: GETIMPORT R6 6 [error]
LOADK R7 K7 ['not here']
CALL R6 1 0
L1: FORGLOOP R1 L0 2
    9:   for i=1,0 do error("not here") end
LOADN R3 1
LOADN R1 0
LOADN R2 1
FORNPREP R1 L3
L2: GETIMPORT R4 6 [error]
LOADK R5 K7 ['not here']
CALL R4 1 0
FORNLOOP R1 L2
   10:   for i=0,1,-1 do error("not here") end
L3: LOADN R3 0
LOADN R1 1
LOADN R2 -1
FORNPREP R1 L5
L4: GETIMPORT R4 6 [error]
LOADK R5 K7 ['not here']
CALL R4 1 0
FORNLOOP R1 L4
   11:   a = nil; for i=1,1 do assert(not a); a=1 end; assert(a)
L5: LOADNIL R0
LOADN R3 1
LOADN R1 1
LOADN R2 1
FORNPREP R1 L8
REMARK builtin assert/1
L6: NOT R5 R0
FASTCALL1 1 R5 L7
GETIMPORT R4 9 [assert]
CALL R4 1 0
L7: LOADN R0 1
FORNLOOP R1 L6
REMARK builtin assert/1
L8: FASTCALL1 1 R0 L9
MOVE R2 R0
GETIMPORT R1 9 [assert]
CALL R1 1 0
   12:   a = nil; for i=1,1,-1 do assert(not a); a=1 end; assert(a)
L9: LOADNIL R0
LOADN R3 1
LOADN R1 1
LOADN R2 -1
FORNPREP R1 L12
REMARK builtin assert/1
L10: NOT R5 R0
FASTCALL1 1 R5 L11
GETIMPORT R4 9 [assert]
CALL R4 1 0
L11: LOADN R0 1
FORNLOOP R1 L10
REMARK builtin assert/1
L12: FASTCALL1 1 R0 L13
MOVE R2 R0
GETIMPORT R1 9 [assert]
CALL R1 1 0
   13:   a = 0; for i=0, 1, 0.1 do a=a+1 end; assert(a==11)
L13: LOADN R0 0
LOADN R3 0
LOADN R1 1
LOADK R2 K10 [0.10000000000000001]
FORNPREP R1 L15
L14: ADDK R0 R0 K11 [1]
FORNLOOP R1 L14
REMARK builtin assert/1
L15: JUMPXEQKN R0 K12 L16 [11]
LOADB R2 0 +1
L16: LOADB R2 1
L17: FASTCALL1 1 R2 L18
GETIMPORT R1 9 [assert]
CALL R1 1 0
   18:   local a
L18: LOADNIL R0
   20:   a = 0; for i=0, 0.999999999, 0.1 do a=a+1 end; assert(a==10)
LOADN R0 0
LOADN R3 0
LOADK R1 K13 [0.99999999900000003]
LOADK R2 K10 [0.10000000000000001]
FORNPREP R1 L20
L19: ADDK R0 R0 K11 [1]
FORNLOOP R1 L19
REMARK builtin assert/1
L20: JUMPXEQKN R0 K14 L21 [10]
LOADB R2 0 +1
L21: LOADB R2 1
L22: FASTCALL1 1 R2 L23
GETIMPORT R1 9 [assert]
CALL R1 1 0
   21:   a = 0; for i=1, 1, 1 do a=a+1 end; assert(a==1)
L23: LOADN R0 0
LOADN R3 1
LOADN R1 1
LOADN R2 1
FORNPREP R1 L25
L24: ADDK R0 R0 K11 [1]
FORNLOOP R1 L24
REMARK builtin assert/1
L25: JUMPXEQKN R0 K11 L26 [1]
LOADB R2 0 +1
L26: LOADB R2 1
L27: FASTCALL1 1 R2 L28
GETIMPORT R1 9 [assert]
CALL R1 1 0
   22:   a = 0; for i=1e10, 1e10, -1 do a=a+1 end; assert(a==1)
L28: LOADN R0 0
LOADK R3 K15 [10000000000]
LOADK R1 K15 [10000000000]
LOADN R2 -1
FORNPREP R1 L30
L29: ADDK R0 R0 K11 [1]
FORNLOOP R1 L29
REMARK builtin assert/1
L30: JUMPXEQKN R0 K11 L31 [1]
LOADB R2 0 +1
L31: LOADB R2 1
L32: FASTCALL1 1 R2 L33
GETIMPORT R1 9 [assert]
CALL R1 1 0
   23:   a = 0; for i=1, 0.99999, 1 do a=a+1 end; assert(a==0)
L33: LOADN R0 0
LOADN R3 1
LOADK R1 K16 [0.99999000000000005]
LOADN R2 1
FORNPREP R1 L35
L34: ADDK R0 R0 K11 [1]
FORNLOOP R1 L34
REMARK builtin assert/1
L35: JUMPXEQKN R0 K17 L36 [0]
LOADB R2 0 +1
L36: LOADB R2 1
L37: FASTCALL1 1 R2 L38
GETIMPORT R1 9 [assert]
CALL R1 1 0
   24:   a = 0; for i=99999, 1e5, -1 do a=a+1 end; assert(a==0)
L38: LOADN R0 0
LOADK R3 K18 [99999]
LOADK R1 K19 [100000]
LOADN R2 -1
FORNPREP R1 L40
L39: ADDK R0 R0 K11 [1]
FORNLOOP R1 L39
REMARK builtin assert/1
L40: JUMPXEQKN R0 K17 L41 [0]
LOADB R2 0 +1
L41: LOADB R2 1
L42: FASTCALL1 1 R2 L43
GETIMPORT R1 9 [assert]
CALL R1 1 0
   25:   a = 0; for i=1, 0.99999, -1 do a=a+1 end; assert(a==1)
L43: LOADN R0 0
LOADN R3 1
LOADK R1 K16 [0.99999000000000005]
LOADN R2 -1
FORNPREP R1 L45
L44: ADDK R0 R0 K11 [1]
FORNLOOP R1 L44
REMARK builtin assert/1
L45: JUMPXEQKN R0 K11 L46 [1]
LOADB R2 0 +1
L46: LOADB R2 1
L47: FASTCALL1 1 R2 L48
GETIMPORT R1 9 [assert]
CALL R1 1 0
   30:   local a = 0; for i="10","1","-2" do a=a+1 end; assert(a==5)
L48: LOADN R0 0
LOADK R3 K20 ['10']
LOADK R1 K21 ['1']
LOADK R2 K22 ['-2']
FORNPREP R1 L50
L49: ADDK R0 R0 K11 [1]
FORNLOOP R1 L49
REMARK builtin assert/1
L50: JUMPXEQKN R0 K23 L51 [5]
LOADB R2 0 +1
L51: LOADB R2 1
L52: FASTCALL1 1 R2 L53
GETIMPORT R1 9 [assert]
CALL R1 1 0
   35:   local function f (n, p)
L53: DUPCLOSURE R0 K24 ['f']
   45:   local x = 0
LOADN R1 0
   46:   for n,a,b,c,d in f(5,3) do
MOVE R2 R0
LOADN R3 5
LOADN R4 3
CALL R2 2 3
FORGPREP R2 L57
   47:     x = x+1
L54: ADDK R1 R1 K11 [1]
REMARK builtin assert/1
   48:     assert(a == 10 and b == 20 and c == 30 and d == nil)
LOADB R11 0
JUMPXEQKN R6 K14 L56 NOT [10]
LOADB R11 0
JUMPXEQKN R7 K25 L56 NOT [20]
LOADB R11 0
JUMPXEQKN R8 K26 L56 NOT [30]
JUMPXEQKNIL R9 L55
LOADB R11 0 +1
L55: LOADB R11 1
L56: FASTCALL1 1 R11 L57
GETIMPORT R10 9 [assert]
CALL R10 1 0
   46:   for n,a,b,c,d in f(5,3) do
L57: FORGLOOP R2 L54 5
REMARK builtin assert/1
   50:   assert(x == 5)
JUMPXEQKN R1 K23 L58 [5]
LOADB R3 0 +1
L58: LOADB R3 1
L59: FASTCALL1 1 R3 L60
GETIMPORT R2 9 [assert]
CALL R2 1 0
REMARK allocation: table hash 0
   55:   local f = {}
L60: NEWTABLE R0 0 0
REMARK builtin setmetatable/2
REMARK allocation: table template 1
   56:   setmetatable(f, { __call = function(_, _, n) if n > 0 then return n - 1 end end })
DUPTABLE R3 28
DUPCLOSURE R4 K29 ['__call']
SETTABLEKS R4 R3 K27 ['__call']
FASTCALL2 61 R0 R3 L61
MOVE R2 R0
GETIMPORT R1 31 [setmetatable]
CALL R1 2 0
   58:   local x = 0
L61: LOADN R1 0
   59:   for n in f, nil, 5 do
MOVE R2 R0
LOADNIL R3
LOADN R4 5
FORGPREP R2 L63
   60:     x += n
L62: ADD R1 R1 R5
   59:   for n in f, nil, 5 do
L63: FORGLOOP R2 L62 1
REMARK builtin assert/1
   62:   assert(x == 10)
JUMPXEQKN R1 K14 L64 [10]
LOADB R3 0 +1
L64: LOADB R3 1
L65: FASTCALL1 1 R3 L66
GETIMPORT R2 9 [assert]
CALL R2 1 0
   67:   local f = newproxy(true)
L66: GETIMPORT R0 33 [newproxy]
LOADB R1 1
CALL R0 1 1
REMARK builtin getmetatable/1
   68:   getmetatable(f).__call = function(_, _, n) if n > 0 then return n - 1 end end
FASTCALL1 60 R0 L67
MOVE R2 R0
GETIMPORT R1 35 [getmetatable]
CALL R1 1 1
L67: DUPCLOSURE R2 K36 []
SETTABLEKS R2 R1 K27 ['__call']
   70:   local x = 0
LOADN R1 0
   71:   for n in f, nil, 5 do
MOVE R2 R0
LOADNIL R3
LOADN R4 5
FORGPREP R2 L69
   72:     x += n
L68: ADD R1 R1 R5
   71:   for n in f, nil, 5 do
L69: FORGLOOP R2 L68 1
REMARK builtin assert/1
   74:   assert(x == 10)
JUMPXEQKN R1 K14 L70 [10]
LOADB R3 0 +1
L70: LOADB R3 1
L71: FASTCALL1 1 R3 L72
GETIMPORT R2 9 [assert]
CALL R2 1 0
   79:   local x = 0
L72: LOADN R0 0
   80:   for k, v in pairs({a = 1, b = 2, c = 3}) do
GETIMPORT R1 4 [pairs]
REMARK allocation: table template 3
DUPTABLE R2 40
LOADN R4 1
SETTABLEKS R4 R2 K37 ['a']
LOADN R4 2
SETTABLEKS R4 R2 K38 ['b']
LOADN R4 3
SETTABLEKS R4 R2 K39 ['c']
CALL R1 1 3
FORGPREP_NEXT R1 L74
   81:     x += v
L73: ADD R0 R0 R5
   80:   for k, v in pairs({a = 1, b = 2, c = 3}) do
L74: FORGLOOP R1 L73 2
REMARK builtin assert/1
   83:   assert(x == 6)
JUMPXEQKN R0 K41 L75 [6]
LOADB R2 0 +1
L75: LOADB R2 1
L76: FASTCALL1 1 R2 L77
GETIMPORT R1 9 [assert]
CALL R1 1 0
   88:   local x = 0
L77: LOADN R0 0
   89:   for k, v in pairs({1, 2, 3, nil, 5}) do
GETIMPORT R1 4 [pairs]
REMARK allocation: table array 5
NEWTABLE R2 0 5
LOADN R4 1
LOADN R5 2
LOADN R6 3
LOADNIL R7
LOADN R8 5
SETLIST R2 R4 5 [1]
CALL R1 1 3
FORGPREP_NEXT R1 L79
   90:     x += v
L78: ADD R0 R0 R5
   89:   for k, v in pairs({1, 2, 3, nil, 5}) do
L79: FORGLOOP R1 L78 2
REMARK builtin assert/1
   92:   assert(x == 11)
JUMPXEQKN R0 K12 L80 [11]
LOADB R2 0 +1
L80: LOADB R2 1
L81: FASTCALL1 1 R2 L82
GETIMPORT R1 9 [assert]
CALL R1 1 0
   97:   local x = 0
L82: LOADN R0 0
   98:   for k, v in ipairs({1, 2, 3, nil, 5}) do
GETIMPORT R1 43 [ipairs]
REMARK allocation: table array 5
NEWTABLE R2 0 5
LOADN R4 1
LOADN R5 2
LOADN R6 3
LOADNIL R7
LOADN R8 5
SETLIST R2 R4 5 [1]
CALL R1 1 3
FORGPREP_INEXT R1 L84
   99:     x += v
L83: ADD R0 R0 R5
   98:   for k, v in ipairs({1, 2, 3, nil, 5}) do
L84: FORGLOOP R1 L83 2 [inext]
REMARK builtin assert/1
  101:   assert(x == 6)
JUMPXEQKN R0 K41 L85 [6]
LOADB R2 0 +1
L85: LOADB R2 1
L86: FASTCALL1 1 R2 L87
GETIMPORT R1 9 [assert]
CALL R1 1 0
REMARK allocation: table hash 0
  106:   local f = {}
L87: NEWTABLE R0 0 0
REMARK builtin setmetatable/2
REMARK allocation: table template 1
  107:   setmetatable(f, { __iter = function(x)
DUPTABLE R3 45
DUPCLOSURE R4 K46 ['__iter']
CAPTURE VAL R0
SETTABLEKS R4 R3 K44 ['__iter']
FASTCALL2 61 R0 R3 L88
MOVE R2 R0
GETIMPORT R1 31 [setmetatable]
CALL R1 2 0
  112:   local x = 0
L88: LOADN R1 0
  113:   for n in f do
MOVE R2 R0
LOADNIL R3
LOADNIL R4
FORGPREP R2 L90
  114:     x += n
L89: ADD R1 R1 R5
  113:   for n in f do
L90: FORGLOOP R2 L89 1
REMARK builtin assert/1
  116:   assert(x == 10)
JUMPXEQKN R1 K14 L91 [10]
LOADB R3 0 +1
L91: LOADB R3 1
L92: FASTCALL1 1 R3 L93
GETIMPORT R2 9 [assert]
CALL R2 1 0
  121:   local f = newproxy(true)
L93: GETIMPORT R0 33 [newproxy]
LOADB R1 1
CALL R0 1 1
REMARK builtin getmetatable/1
  122:   getmetatable(f).__iter = function(x)
FASTCALL1 60 R0 L94
MOVE R2 R0
GETIMPORT R1 35 [getmetatable]
CALL R1 1 1
L94: DUPCLOSURE R2 K47 []
CAPTURE VAL R0
SETTABLEKS R2 R1 K44 ['__iter']
  127:   local x = 0
LOADN R1 0
  128:   for n in f do
MOVE R2 R0
LOADNIL R3
LOADNIL R4
FORGPREP R2 L96
  129:     x += n
L95: ADD R1 R1 R5
  128:   for n in f do
L96: FORGLOOP R2 L95 1
REMARK builtin assert/1
  131:   assert(x == 10)
JUMPXEQKN R1 K14 L97 [10]
LOADB R3 0 +1
L97: LOADB R3 1
L98: FASTCALL1 1 R3 L99
GETIMPORT R2 9 [assert]
CALL R2 1 0
  136:   local x = 0
L99: LOADN R0 0
REMARK allocation: table template 3
  137:   for k, v in {a = 1, b = 2, c = 3} do
DUPTABLE R1 40
LOADN R4 1
SETTABLEKS R4 R1 K37 ['a']
LOADN R4 2
SETTABLEKS R4 R1 K38 ['b']
LOADN R4 3
SETTABLEKS R4 R1 K39 ['c']
LOADNIL R2
LOADNIL R3
FORGPREP R1 L101
  138:     print(k, v)
L100: GETIMPORT R6 1 [print]
MOVE R7 R4
MOVE R8 R5
CALL R6 2 0
  139:     x += v
ADD R0 R0 R5
  137:   for k, v in {a = 1, b = 2, c = 3} do
L101: FORGLOOP R1 L100 2
REMARK builtin assert/1
  141:   assert(x == 6)
JUMPXEQKN R0 K41 L102 [6]
LOADB R2 0 +1
L102: LOADB R2 1
L103: FASTCALL1 1 R2 L104
GETIMPORT R1 9 [assert]
CALL R1 1 0
  146:   local x = ''
L104: LOADK R0 K48 ['']
REMARK allocation: table array 5
  147:   for k, v in {1, 2, 3, nil, 5} do
NEWTABLE R1 0 5
LOADN R4 1
LOADN R5 2
LOADN R6 3
LOADNIL R7
LOADN R8 5
SETLIST R1 R4 5 [1]
LOADNIL R2
LOADNIL R3
FORGPREP R1 L107
  148:     x ..= tostring(v)
L105: MOVE R6 R0
REMARK builtin tostring/1
FASTCALL1 63 R5 L106
MOVE R8 R5
GETIMPORT R7 50 [tostring]
CALL R7 1 1
L106: CONCAT R0 R6 R7
  147:   for k, v in {1, 2, 3, nil, 5} do
L107: FORGLOOP R1 L105 2
REMARK builtin assert/1
  150:   assert(x == "1235")
JUMPXEQKS R0 K51 L108 ['1235']
LOADB R2 0 +1
L108: LOADB R2 1
L109: FASTCALL1 1 R2 L110
GETIMPORT R1 9 [assert]
CALL R1 1 0
  155:   local x = 0
L110: LOADN R0 0
REMARK allocation: table hash 3 array 5
  156:   for k, v in {1, 2, 3, nil, 5, a = 1, b = 2, c = 3} do
NEWTABLE R1 4 5
LOADN R4 1
LOADN R5 2
LOADN R6 3
LOADNIL R7
LOADN R8 5
SETLIST R1 R4 5 [1]
LOADN R9 1
SETTABLEKS R9 R1 K37 ['a']
LOADN R9 2
SETTABLEKS R9 R1 K38 ['b']
LOADN R9 3
SETTABLEKS R9 R1 K39 ['c']
LOADNIL R2
LOADNIL R3
FORGPREP R1 L112
  157:     x += v
L111: ADD R0 R0 R5
  156:   for k, v in {1, 2, 3, nil, 5, a = 1, b = 2, c = 3} do
L112: FORGLOOP R1 L111 2
REMARK builtin assert/1
  159:   assert(x == 17)
JUMPXEQKN R0 K52 L113 [17]
LOADB R2 0 +1
L113: LOADB R2 1
L114: FASTCALL1 1 R2 L115
GETIMPORT R1 9 [assert]
CALL R1 1 0
  164:   local ok, err = pcall(function() for x in 42 do end end)
L115: GETIMPORT R0 54 [pcall]
DUPCLOSURE R1 K55 []
CALL R0 1 2
REMARK builtin assert/1
  165:   assert(not ok and err:match("attempt to iterate"))
NOT R3 R0
JUMPIFNOT R3 L116
LOADK R5 K56 ['attempt to iterate']
NAMECALL R3 R1 K57 ['match']
CALL R3 2 1
L116: FASTCALL1 1 R3 L117
GETIMPORT R2 9 [assert]
CALL R2 1 0
REMARK allocation: table hash 0
  170:   local obj = {}
L117: NEWTABLE R0 0 0
REMARK builtin setmetatable/2
REMARK allocation: table template 1
  171:   setmetatable(obj, { __iter = function() end })
DUPTABLE R3 45
DUPCLOSURE R4 K58 ['__iter']
SETTABLEKS R4 R3 K44 ['__iter']
FASTCALL2 61 R0 R3 L118
MOVE R2 R0
GETIMPORT R1 31 [setmetatable]
CALL R1 2 0
  173:   local ok, err = pcall(function() for x in obj do end end)
L118: GETIMPORT R1 54 [pcall]
DUPCLOSURE R2 K59 []
CAPTURE VAL R0
CALL R1 1 2
REMARK builtin assert/1
  174:   assert(not ok and err:match("attempt to call a nil value"))
NOT R4 R1
JUMPIFNOT R4 L119
LOADK R6 K60 ['attempt to call a nil value']
NAMECALL R4 R2 K57 ['match']
CALL R4 2 1
L119: FASTCALL1 1 R4 L120
GETIMPORT R3 9 [assert]
CALL R3 1 0
  179:   local x = 0
L120: LOADN R0 0
REMARK allocation: table array 5
  180:   for k in {1, 2, 3, 4, 5} do
NEWTABLE R1 0 5
LOADN R4 1
LOADN R5 2
LOADN R6 3
LOADN R7 4
LOADN R8 5
SETLIST R1 R4 5 [1]
LOADNIL R2
LOADNIL R3
FORGPREP R1 L122
  181:     x += k
L121: ADD R0 R0 R4
  180:   for k in {1, 2, 3, 4, 5} do
L122: FORGLOOP R1 L121 1
REMARK builtin assert/1
  183:   assert(x == 15)
JUMPXEQKN R0 K61 L123 [15]
LOADB R2 0 +1
L123: LOADB R2 1
L124: FASTCALL1 1 R2 L125
GETIMPORT R1 9 [assert]
CALL R1 1 0
  188:   local x = 0
L125: LOADN R0 0
REMARK allocation: table array 5
  189:   for k,v,a,b,c,d,e in {1, 2, 3, 4, 5} do
NEWTABLE R1 0 5
LOADN R4 1
LOADN R5 2
LOADN R6 3
LOADN R7 4
LOADN R8 5
SETLIST R1 R4 5 [1]
LOADNIL R2
LOADNIL R3
FORGPREP R1 L129
  190:     x += k
L126: ADD R0 R0 R4
REMARK builtin assert/1
  191:     assert(a == nil and b == nil and c == nil and d == nil and e == nil)
LOADB R12 0
JUMPXEQKNIL R6 L128 NOT
LOADB R12 0
JUMPXEQKNIL R7 L128 NOT
LOADB R12 0
JUMPXEQKNIL R8 L128 NOT
LOADB R12 0
JUMPXEQKNIL R9 L128 NOT
JUMPXEQKNIL R10 L127
LOADB R12 0 +1
L127: LOADB R12 1
L128: FASTCALL1 1 R12 L129
GETIMPORT R11 9 [assert]
CALL R11 1 0
  189:   for k,v,a,b,c,d,e in {1, 2, 3, 4, 5} do
L129: FORGLOOP R1 L126 7
REMARK builtin assert/1
  193:   assert(x == 15)
JUMPXEQKN R0 K61 L130 [15]
LOADB R2 0 +1
L130: LOADB R2 1
L131: FASTCALL1 1 R2 L132
GETIMPORT R1 9 [assert]
CALL R1 1 0
  198: function testgetfenv()
L132: DUPCLOSURE R0 K62 ['testgetfenv']
SETGLOBAL R0 K63 ['testgetfenv']
  214: testgetfenv() -- DONT MOVE THIS LINE
GETGLOBAL R0 K63 ['testgetfenv']
CALL R0 0 0
  216: print"OK"
GETIMPORT R0 1 [print]
LOADK R1 K64 ['OK']
CALL R0 1 0
  217: 
RETURN R0 0

]====]
end